<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html lang="ja-JP">
    <head>
    <meta http-equiv="Content-type" content="text/html; charset=Shift_JIS">
    <title>ＤＸライブラリ置き場　３Ｄ関係関数リファレンスページ</title>
    </head>
    <body bgcolor="#ffffff" text="#000000" link="#0033CC" vlink="#800040">
    <table align="center" width="840"  cellspacing="0" cellpadding="0" >
        <tr><td align="center" colspan="2">
        <center>
        <font size="5"><b>ＤＸライブラリ　関数リファレンスページ　３Ｄ関係関数リファレンス<br></b></font>
        <hr></center>
        </td></tr>

        <tr><td align="left" colspan="2">
        <font size="3"><b>
        <br>
        　このページではＤＸライブラリの３Ｄ表現を扱うための主な関数の説明と簡単な<br>
        サンプルプログラムを載せています。<br><br><br>
        </b></font>
        </td></tr>

        <tr><td colspan="2">
            <a name="G1"><font size="3" color="#005500"><b>３Ｄ図形描画関係関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R14N1">DrawLine3D</a></b></td><td>　３Ｄ空間に線分を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N2">DrawTriangle3D</a></b></td><td>　３Ｄ空間に三角形を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N4">DrawSphere3D</a></b></td><td>　３Ｄ空間に球を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N5">DrawCapsule3D</a></b></td><td>　３Ｄ空間にカプセルを描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N6">DrawCone3D</a></b></td><td>　３Ｄ空間に円錐を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N9">DrawBillboard3D</a></b></td><td>　３Ｄ空間に画像を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N20">DrawModiBillboard3D</a></b></td><td>　３Ｄ空間に２次元的な変形を加えた画像を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N7">DrawPolygon3D</a></b></td><td>　３Ｄ空間に三角形ポリゴンの集合を描画する</td></tr>
        <tr><td valign="top"><b><a href="#R14N8">DrawPolygonIndexed3D</a></b></td><td>　３Ｄ空間に三角形ポリゴンの集合を描画する(インデックス)<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R14N22">SetMaterialUseVertDifColor</a></b></td><td>　３Ｄ図形描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R14N10">SetMaterialUseVertSpcColor</a></b></td><td>　３Ｄ図形描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R14N11">SetMaterialParam</a></b></td><td>　３Ｄ図形描画のライティング計算に使用するマテリアルパラメータを設定する<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R14N12">SetUseZBuffer3D</a></b></td><td>　Ｚバッファを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R14N13">SetWriteZBuffer3D</a></b></td><td>　Ｚバッファに書き込みを行うかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R14N19">SetUseBackCulling</a></b></td><td>　ポリゴンのバックカリングを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R14N21">SetTextureAddressModeUV</a></b></td><td>　テクスチャアドレスモードを設定する</td></tr>

        <tr><td valign="top"><b><a href="#R14N16">SetFogEnable</a></b></td><td>　フォグを有効にするかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R14N17">SetFogColor</a></b></td><td>　フォグの色を変更する</td></tr>
        <tr><td valign="top"><b><a href="#R14N18">SetFogStartEnd</a></b></td><td>　フォグが始まる距離と終了する距離を設定する</td></tr>

        <tr><td valign="top"><b><a href="#R14N14">GetColorF</a></b></td><td>　浮動小数点型のカラー値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R14N15">GetColorU8</a></b></td><td>　符号なし整数８ビットのカラー値を取得する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G2"><font size="3" color="#005500"><b>カメラ関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R12N1">SetCameraNearFar</a></b></td><td>　カメラの 手前クリップ距離と 奥クリップ距離を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N2">SetCameraPositionAndTarget_UpVecY</a></b></td><td>　カメラの視点、注視点を設定する( 上方向はＹ軸から算出 )</td></tr>
        <tr><td valign="top"><b><a href="#R12N3">SetCameraPositionAndTargetAndUpVec</a></b></td><td>　カメラの視点、注視点、上方向を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N4">SetCameraPositionAndAngle</a></b></td><td>　カメラの視点、垂直回転角度、水平回転角度、捻り回転角度を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N5">SetCameraViewMatrix</a></b></td><td>　ビュー行列を直接設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N6">SetupCamera_Perspective</a></b></td><td>　遠近法カメラをセットアップする</td></tr>
        <tr><td valign="top"><b><a href="#R12N7">SetupCamera_Ortho</a></b></td><td>　正射影カメラをセットアップする</td></tr>
        <tr><td valign="top"><b><a href="#R12N8">SetupCamera_ProjectionMatrix</a></b></td><td>　射影行列を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N9">SetCameraDotAspect</a></b></td><td>　カメラのドットアスペクト比を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N10">ConvWorldPosToScreenPos</a></b></td><td>　ワールド座標をスクリーン座標に変換する</td></tr>
        <tr><td valign="top"><b><a href="#R12N11">ConvScreenPosToWorldPos</a></b></td><td>　スクリーン座標をワールド座標に変換する</td></tr>
        <tr><td valign="top"><b><a href="#R12N12">SetCameraScreenCenter</a></b></td><td>　画面上でのカメラが見ている映像の中心座標を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N13">CheckCameraViewClip</a></b></td><td>　指定の座標がカメラの視界に入っていないかどうかを判定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N14">CheckCameraViewClip_Box</a></b></td><td>　二つの座標で表されるボックスがカメラの視界に入っていないかどうかを判定する</td></tr>
        <tr><td valign="top"><b><a href="#R12N15">GetCameraViewMatrix</a></b></td><td>　カメラのビュー行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R12N16">GetCameraProjectionMatrix</a></b></td><td>　カメラの射影行列を取得する<br><br><br></td></tr>


        <tr><td colspan="2">
            <a name="G3"><font size="3" color="#005500"><b>ライト関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R13N44">SetUseLighting</a></b></td><td>　ライティング計算処理を使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N45">SetGlobalAmbientLight</a></b></td><td>　グローバルアンビエントライトカラーを設定する<br><br></td></tr>

        <tr><td colspan="2">
            <a name="G4"><font size="3" color="#752400"><b>　　標準ライト関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R13N1">ChangeLightTypeDir</a></b></td><td>　標準ライトのタイプをディレクショナルライトにする</td></tr>
        <tr><td valign="top"><b><a href="#R13N2">ChangeLightTypePoint</a></b></td><td>　標準ライトのタイプをポイントライトにする</td></tr>
        <tr><td valign="top"><b><a href="#R13N3">ChangeLightTypeSpot</a></b></td><td>　標準ライトのタイプをスポットライトにする</td></tr>
        <tr><td valign="top"><b><a href="#R13N4">SetLightEnable</a></b></td><td>　標準ライトの有効、無効をセットする</td></tr>
        <tr><td valign="top"><b><a href="#R13N5">SetLightDifColor</a></b></td><td>　標準ライトのディフューズカラーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N6">SetLightSpcColor</a></b></td><td>　標準ライトのスペキュラカラーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N7">SetLightAmbColor</a></b></td><td>　標準ライトのアンビエントカラーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N8">SetLightDirection</a></b></td><td>　標準ライトの方向を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N9">SetLightPosition</a></b></td><td>　標準ライトの位置を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N10">SetLightRangeAtten</a></b></td><td>　標準ライトの有効距離と距離減衰パラメータを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N11">SetLightAngle</a></b></td><td>　標準ライトの照射角度パラメータを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N12">GetLightType</a></b></td><td>　標準ライトのタイプを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N13">GetLightEnable</a></b></td><td>　標準ライトの有効、無効を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N14">GetLightDifColor</a></b></td><td>　標準ライトのディフューズカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N15">GetLightSpcColor</a></b></td><td>　標準ライトのスペキュラカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N16">GetLightAmbColor</a></b></td><td>　標準ライトのアンビエントカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N17">GetLightDirection</a></b></td><td>　標準ライトの向きを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N18">GetLightPosition</a></b></td><td>　標準ライトの位置を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N19">GetLightRangeAtten</a></b></td><td>　標準ライトの有効距離と距離減衰パラメータを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N20">GetLightAngle</a></b></td><td>　標準ライトの照射角度パラメータを取得する<br><br></td></tr>

        <tr><td colspan="2">
            <a name="G5"><font size="3" color="#752400"><b>　　ライトハンドル関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R13N21">CreateDirLightHandle</a></b></td><td>　ディレクショナルタイプのライトハンドルを作成する</td></tr>
        <tr><td valign="top"><b><a href="#R13N22">CreatePointLightHandle</a></b></td><td>　ポイントタイプのライトハンドルを作成する</td></tr>
        <tr><td valign="top"><b><a href="#R13N23">CreateSpotLightHandle</a></b></td><td>　スポットタイプのライトハンドルを作成する</td></tr>
        <tr><td valign="top"><b><a href="#R13N24">DeleteLightHandle</a></b></td><td>　ライトハンドルを削除する</td></tr>
        <tr><td valign="top"><b><a href="#R13N25">DeleteLightHandleAll</a></b></td><td>　ライトハンドルを全て削除する</td></tr>
        <tr><td valign="top"><b><a href="#R13N26">SetLightTypeHandle</a></b></td><td>　ライトハンドルのタイプを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R13N27">SetLightEnableHandle</a></b></td><td>　ライトハンドルのライトの有効、無効を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N28">SetLightDifColorHandle</a></b></td><td>　ライトハンドルのライトのディフューズカラーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N29">SetLightSpcColorHandle</a></b></td><td>　ライトハンドルのライトのスペキュラカラーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N30">SetLightAmbColorHandle</a></b></td><td>　ライトハンドルのライトのアンビエントカラーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N31">SetLightDirectionHandle</a></b></td><td>　ライトハンドルのライトの方向を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N32">SetLightPositionHandle</a></b></td><td>　ライトハンドルのライトの位置を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N33">SetLightRangeAttenHandle</a></b></td><td>　ライトハンドルのライトの有効距離と距離減衰パラメータを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N34">SetLightAngleHandle</a></b></td><td>　ライトハンドルのライトの照射角度パラメータを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R13N35">GetLightTypeHandle</a></b></td><td>　ライトハンドルのライトのタイプを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N36">GetLightEnableHandle</a></b></td><td>　ライトハンドルのライトの有効、無効を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N37">GetLightDifColorHandle</a></b></td><td>　ライトハンドルのライトのディフューズカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N38">GetLightSpcColorHandle</a></b></td><td>　ライトハンドルのライトのスペキュラカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N39">GetLightAmbColorHandle</a></b></td><td>　ライトハンドルのライトのアンビエントカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N40">GetLightDirectionHandle</a></b></td><td>　ライトハンドルのライトの方向を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N41">GetLightPositionHandle</a></b></td><td>　ライトハンドルのライトの位置を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N42">GetLightRangeAttenHandle</a></b></td><td>　ライトハンドルのライトの有効距離と距離減衰パラメータを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N43">GetLightAngleHandle</a></b></td><td>　ライトハンドルのライトの照射角度パラメータを取得する<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R13N46">GetEnableLightHandleNum</a></b></td><td>　有効になっているライトハンドルの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R13N47">GetEnableLightHandle</a></b></td><td>　有効になっているライトハンドルを取得する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G6"><font size="3" color="#005500"><b>算術演算関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R11N1">VGet</a></b></td><td>　ベクトルを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N2">VAdd</a></b></td><td>　二つのベクトルを加算する</td></tr>
        <tr><td valign="top"><b><a href="#R11N3">VSub</a></b></td><td>　二つのベクトルを減算する</td></tr>
        <tr><td valign="top"><b><a href="#R11N4">VDot</a></b></td><td>　二つのベクトルの内積を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N5">VCross</a></b></td><td>　二つのベクトルの外積を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N6">VScale</a></b></td><td>　ベクトルのスケーリングをする</td></tr>
        <tr><td valign="top"><b><a href="#R11N9">VSize</a></b></td><td>　ベクトルのサイズを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N10">VSquareSize</a></b></td><td>　ベクトルのサイズの２乗を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N11">VNorm</a></b></td><td>　正規化ベクトルを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N12">VTransform</a></b></td><td>　行列を使ったベクトルの変換</td></tr>
        <tr><td valign="top"><b><a href="#R11N13">VTransformSR</a></b></td><td>　行列を使ったベクトルの変換( スケーリング＋回転成分のみ )<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R11N14">MGetIdent</a></b></td><td>　単位行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N15">MGetScale</a></b></td><td>　拡大行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N16">MGetTranslate</a></b></td><td>　平行移動行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N17">MGetRotX</a></b></td><td>　Ｘ軸回転行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N18">MGetRotY</a></b></td><td>　Ｙ軸回転行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N19">MGetRotZ</a></b></td><td>　Ｚ軸回転行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N20">MGetRotAxis</a></b></td><td>　指定軸で指定角度回転する行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N21">MGetRotVec2</a></b></td><td>　ある向きからある向きへ変換する回転行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N22">MGetAxis1</a></b></td><td>　指定の３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N23">MGetAxis2</a></b></td><td>　基本軸上のベクトルを指定の３軸上のベクトルに変換する行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N24">MAdd</a></b></td><td>　二つの行列の足し算を行う</td></tr>
        <tr><td valign="top"><b><a href="#R11N25">MMult</a></b></td><td>　二つの行列の乗算を行う</td></tr>
        <tr><td valign="top"><b><a href="#R11N26">MScale</a></b></td><td>　行列のスケーリングを行う</td></tr>
        <tr><td valign="top"><b><a href="#R11N27">MTranspose</a></b></td><td>　転置行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R11N28">MInverse</a></b></td><td>　逆行列を取得する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G18"><font size="3" color="#005500"><b>衝突検出系関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R16N1">Segment_Segment_MinLength</a></b></td><td>　二つの線分の最近点間の距離を得る</td></tr>
        <tr><td valign="top"><b><a href="#R16N2">Segment_Triangle_MinLength</a></b></td><td>　線分と三角形の最近点間の距離を得る</td></tr>
        <tr><td valign="top"><b><a href="#R16N3">Segment_Point_MinLength</a></b></td><td>　線分と点の一番近い距離を得る</td></tr>
        <tr><td valign="top"><b><a href="#R16N4">HitCheck_Line_Triangle</a></b></td><td>　三角形と線分の当たり判定<br><br><br></td></tr>
<!--    <tr><td valign="top"><b><a href="#R16N5">HitCheck_Sphere_Sphere</a></b></td><td>　球と球の当たり判定</td></tr>
        <tr><td valign="top"><b><a href="#R16N6">HitCheck_Sphere_Triangle</a></b></td><td>　三角形と球の当たり判定</td></tr>
        <tr><td valign="top"><b><a href="#R16N7">HitCheck_Capsule_Capsule</a></b></td><td>　カプセル同士の当たり判定</td></tr>
        <tr><td valign="top"><b><a href="#R16N8">HitCheck_Capsule_Triangle</a></b></td><td>　カプセルと三角形の当たり判定<br><br><br></td></tr>
-->

        <tr><td colspan="2">
            <a name="G7"><font size="3" color="#005500"><b>３Ｄモデル関係の関数</b></font></a><br><br>
        </td></tr>

        <tr><td colspan="2">
            <a name="G8"><font size="3" color="#752400"><b>　　モデルの読み込み・複製関係の関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R1N1">MV1LoadModel</a></b></td><td>　モデルの読み込み</td></tr>
        <tr><td valign="top"><b><a href="#R1N2">MV1DuplicateModel</a></b></td><td>　指定のモデルと同じ基礎データを使用してモデルを作成する</td></tr>

        <tr><td valign="top"><b><a href="#R1N3">MV1DeleteModel</a></b></td><td>　モデルを削除する</td></tr>
        <tr><td valign="top"><b><a href="#R1N4">MV1SetLoadModelUsePhysicsMode</a></b></td><td>　読み込むモデルの物理演算モードを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R1N5">MV1SetLoadModelPhysicsWorldGravity</a></b></td><td>　読み込むモデルの物理演算に適用する重力パラメータを設定する<br><br><br></td></tr>


        <tr><td colspan="2">
            <a name="G9"><font size="3" color="#752400"><b>　　モデル描画関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R2N1">MV1DrawModel</a></b></td><td>　モデルを描画する</td></tr>
        <tr><td valign="top"><b><a href="#R2N2">MV1DrawFrame</a></b></td><td>　モデルの指定のフレームを描画する</td></tr>
        <tr><td valign="top"><b><a href="#R2N3">MV1DrawMesh</a></b></td><td>　モデルの指定のメッシュを描画する</td></tr>
        <tr><td valign="top"><b><a href="#R2N4">MV1DrawTriangleList</a></b></td><td>　モデルの指定のトライアングルリストを描画する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G21"><font size="3" color="#752400"><b>　　モデル描画設定関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R19N1">MV1SetUseOrigShader</a></b></td><td>　モデルの描画にオリジナルシェーダープログラムを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R19N2">MV1SetSemiTransDrawMode</a></b></td><td>　モデルの半透明要素がある部分についての描画モードを設定する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G10"><font size="3" color="#752400"><b>　　モデル基本制御関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R3N2">MV1SetPosition</a></b></td><td>　モデルの座標をセットする</td></tr>
        <tr><td valign="top"><b><a href="#R3N3">MV1GetPosition</a></b></td><td>　モデルの座標を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N4">MV1SetScale</a></b></td><td>　モデルの拡大値をセットする</td></tr>
        <tr><td valign="top"><b><a href="#R3N5">MV1GetScale</a></b></td><td>　モデルの拡大値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N6">MV1SetRotationXYZ</a></b></td><td>　モデルの回転値をセットする</td></tr>
        <tr><td valign="top"><b><a href="#R3N7">MV1GetRotationXYZ</a></b></td><td>　モデルの回転値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N8">MV1SetRotationZYAxis</a></b></td><td>　モデルのＺ軸とＹ軸の方向をセットする</td></tr>
        <tr><td valign="top"><b><a href="#R3N11">MV1SetMatrix</a></b></td><td>　モデルの座標変換用行列をセットする</td></tr>
        <tr><td valign="top"><b><a href="#R3N12">MV1GetMatrix</a></b></td><td>　モデルの座標変換用行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N13">MV1SetVisible</a></b></td><td>　モデルを描画するかどうかを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R3N14">MV1GetVisible</a></b></td><td>　モデルを描画するかどうかを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N15">MV1SetDifColorScale</a></b></td><td>　モデルのディフューズカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N16">MV1GetDifColorScale</a></b></td><td>　モデルのディフューズカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N17">MV1SetSpcColorScale</a></b></td><td>　モデルのスペキュラカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N18">MV1GetSpcColorScale </a></b></td><td>　モデルのスペキュラカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N19">MV1SetEmiColorScale</a></b></td><td>　モデルのエミッシブカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N20">MV1GetEmiColorScale</a></b></td><td>　モデルのエミッシブカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N21">MV1SetAmbColorScale</a></b></td><td>　モデルのアンビエントカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N22">MV1GetAmbColorScale</a></b></td><td>　モデルのアンビエントカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N23">MV1GetSemiTransState</a></b></td><td>　モデルに半透明要素があるかどうかを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N24">MV1SetOpacityRate</a></b></td><td>　モデルの不透明度を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N25">MV1GetOpacityRate</a></b></td><td>　モデルの不透明度を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R3N26">MV1SetUseZBuffer</a></b></td><td>　モデルを描画する際にＺバッファを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N27">MV1SetWriteZBuffer</a></b></td><td>　モデルを描画する際にＺバッファに書き込みを行うかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N28">MV1SetUseVertDifColor</a></b></td><td>　モデル描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N29">MV1SetUseVertSpcColor</a></b></td><td>　モデル描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R3N30">MV1PhysicsCalculation</a></b></td><td>　モデルの物理演算を指定時間分経過したと仮定して計算する</td></tr>
        <tr><td valign="top"><b><a href="#R3N31">MV1PhysicsResetState</a></b></td><td>　モデルの物理演算の状態をリセットする<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G11"><font size="3" color="#752400"><b>　　アニメーション関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R4N1">MV1AttachAnim</a></b></td><td>　アニメーションをアタッチする</td></tr>
        <tr><td valign="top"><b><a href="#R4N2">MV1DetachAnim</a></b></td><td>　アニメーションをデタッチする</td></tr>
        <tr><td valign="top"><b><a href="#R4N3">MV1SetAttachAnimTime</a></b></td><td>　アタッチしているアニメーションの再生時間を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R4N4">MV1GetAttachAnimTime</a></b></td><td>　アタッチしているアニメーションの再生時間を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b></td><td>　アタッチしているアニメーションの総時間を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R4N6">MV1SetAttachAnimBlendRate</a></b></td><td>　アタッチしているアニメーションのブレンド率を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R4N7">MV1GetAttachAnimBlendRate</a></b></td><td>　アタッチしているアニメーションのブレンド率を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R4N8">MV1GetAttachAnim</a></b></td><td>　アタッチしているアニメーションのアニメーション番号を取得する</td></tr>
	<tr><td valign="top"><b><a href="#R4N13">MV1GetAttachAnimFrameLocalPosition</a></b></td><td>　アタッチしているアニメーションの指定フレーム( ボーン )のローカル座標を取得する</td></tr>

        <tr><td valign="top"><b><a href="#R4N9">MV1GetAnimNum</a></b></td><td>　アニメーションの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R4N10">MV1GetAnimName</a></b></td><td>　指定番号のアニメーション名を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R4N11">MV1GetAnimIndex</a></b></td><td>　指定名のアニメーション番号を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R4N12">MV1GetAnimTotalTime</a></b></td><td>　指定番号のアニメーションの総時間を得る<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G12"><font size="3" color="#752400"><b>　　マテリアル関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R5N1">MV1GetMaterialNum</a></b></td><td>　モデルで使用しているマテリアルの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N2">MV1GetMaterialName</a></b></td><td>　指定のマテリアルの名前を取得する</td></tr>
<!--    <tr><td valign="top"><b><a href="#R5N33">MV1SetMaterialType</a></b></td><td>　指定のマテリアルのタイプを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N34">MV1GetMaterialType</a></b></td><td>　指定のマテリアルのタイプを取得する</td></tr>
-->        <tr><td valign="top"><b><a href="#R5N3">MV1SetMaterialDifColor</a></b></td><td>　指定のマテリアルのディフューズカラーを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N4">MV1GetMaterialDifColor</a></b></td><td>　指定のマテリアルのディフューズカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N5">MV1SetMaterialSpcColor</a></b></td><td>　指定のマテリアルのスペキュラカラーを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N6">MV1GetMaterialSpcColor</a></b></td><td>　指定のマテリアルのスペキュラカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N7">MV1SetMaterialEmiColor</a></b></td><td>　指定のマテリアルのエミッシブカラーを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N8">MV1GetMaterialEmiColor</a></b></td><td>　指定のマテリアルのエミッシブカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N9">MV1SetMaterialAmbColor</a></b></td><td>　指定のマテリアルのアンビエントカラーを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N10">MV1GetMaterialAmbColor</a></b></td><td>　指定のマテリアルのアンビエントカラーを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N11">MV1SetMaterialSpcPower</a></b></td><td>　指定のマテリアルのスペキュラの強さを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N12">MV1GetMaterialSpcPower</a></b></td><td>　指定のマテリアルのスペキュラの強さを取得する</td></tr>
<!--    <tr><td valign="top"><b><a href="#R5N13">MV1SetMaterialDifMapTexPath</a></b></td><td>　指定のマテリアルのディフューズマップテクスチャのパスを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N14">MV1GetMaterialDifMapTexPath</a></b></td><td>　指定のマテリアルのディフューズマップテクスチャのパスを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N15">MV1SetMaterialSpcMapTexPath</a></b></td><td>　指定のマテリアルのスペキュラマップテクスチャのパスを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N16">MV1GetMaterialSpcMapTexPath</a></b></td><td>　指定のマテリアルのスペキュラマップテクスチャのパスを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N17">MV1GetMaterialNormalMapTexPath</a></b></td><td>　指定のマテリアルの法線マップテクスチャのパスを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N18">MV1GetMaterialBumpMapTexPath</a></b></td><td>　指定のマテリアルの凸凹マップテクスチャのパスを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N19">MV1GetMaterialBumpMapNextPixelLength</a></b></td><td>　指定のマテリアルの凸凹マップテクスチャの１ピクセル辺りの距離を取得する</td></tr>
-->
        <tr><td valign="top"><b><a href="#R5N24">MV1GetMaterialDifMapTexture</a></b></td><td>　指定のマテリアルでディフューズマップとして使用されているテクスチャ番号を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N25">MV1GetMaterialSpcMapTexture</a></b></td><td>　指定のマテリアルでスペキュラマップとして使用されているテクスチャ番号を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N26">MV1GetMaterialNormalMapTexture</a></b></td><td>　指定のマテリアルで法線マップとして使用されているテクスチャ番号を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N20">MV1SetMaterialDrawBlendMode</a></b></td><td>　指定のマテリアルの描画ブレンドモードを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N21">MV1GetMaterialDrawBlendMode</a></b></td><td>　指定のマテリアルの描画ブレンドモードを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N22">MV1SetMaterialDrawBlendParam</a></b></td><td>　指定のマテリアルの描画ブレンドパラメータを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R5N23">MV1GetMaterialDrawBlendParam</a></b></td><td>　指定のマテリアルの描画ブレンドパラメータを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N35">MV1SetMaterialDrawAlphaTest</a></b></td><td>　指定のマテリアルの描画アルファテストの設定を行う</td></tr>
        <tr><td valign="top"><b><a href="#R5N36">MV1SetMaterialDrawAlphaTestAll</a></b></td><td>　全てのマテリアルの描画アルファテストの設定を行う</td></tr>
        <tr><td valign="top"><b><a href="#R5N27">MV1SetMaterialOutLineWidth</a></b></td><td>　指定のマテリアルのトゥーンレンダリングで使用する輪郭線の太さを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R5N28">MV1GetMaterialOutLineWidth</a></b></td><td>　指定のマテリアルのトゥーンレンダリングで使用する輪郭線の太さを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N29">MV1SetMaterialOutLineDotWidth</a></b></td><td>　指定のマテリアルのトゥーンレンダリングで使用する輪郭線のドット単位の太さを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R5N30">MV1GetMaterialOutLineDotWidth</a></b></td><td>　指定のマテリアルのトゥーンレンダリングで使用する輪郭線のドット単位の太さを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R5N31">MV1SetMaterialOutLineColor</a></b></td><td>　指定のマテリアルのトゥーンレンダリングで使用する輪郭線の色を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R5N32">MV1GetMaterialOutLineColor</a></b></td><td>　指定のマテリアルのトゥーンレンダリングで使用する輪郭線の色を取得する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G13"><font size="3" color="#752400"><b>　　テクスチャ関係</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R15N1">MV1GetTextureNum</a></b></td><td>　モデルで使用されているテクスチャの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R15N2">MV1GetTextureName</a></b></td><td>　テクスチャの名前を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R15N3">MV1SetTextureGraphHandle</a></b></td><td>　テクスチャとして使用するグラフィックハンドルを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R15N4">MV1GetTextureGraphHandle</a></b></td><td>　テクスチャのグラフィックハンドルを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R15N5">MV1SetTextureAddressMode</a></b></td><td>　テクスチャのアドレスモードを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R15N6">MV1GetTextureAddressModeU</a></b></td><td>　テクスチャのＵ値のアドレスモードを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R15N7">MV1GetTextureAddressModeV</a></b></td><td>　テクスチャのＶ値のアドレスモードを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R15N8">MV1SetTextureSampleFilterMode</a></b></td><td>　テクスチャのフィルタリングモードを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R15N9">MV1GetTextureSampleFilterMode</a></b></td><td>　テクスチャのフィルタリングモードを取得する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G14"><font size="3" color="#752400"><b>　　フレーム関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R6N1">MV1GetFrameNum</a></b></td><td>　フレームの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N2">MV1SearchFrame</a></b></td><td>　指定名のフレームをモデル中から検索する</td></tr>
        <tr><td valign="top"><b><a href="#R6N3">MV1SearchFrameChild</a></b></td><td>　指定名のフレームを指定のフレームの子フレームの中から検索する</td></tr>
        <tr><td valign="top"><b><a href="#R6N4">MV1GetFrameName</a></b></td><td>　フレームの名前を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N5">MV1GetFrameParent</a></b></td><td>　フレームの親フレームを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N6">MV1GetFrameChildNum</a></b></td><td>　フレームの子フレームの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N7">MV1GetFrameChild</a></b></td><td>　フレームの子フレームを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N8">MV1GetFramePosition</a></b></td><td>　フレームの座標を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N10">MV1GetFrameLocalMatrix</a></b></td><td>　フレームの座標変換行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N9">MV1GetFrameLocalWorldMatrix</a></b></td><td>　フレームのローカル座標からワールド座標に変換する行列を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N11">MV1SetFrameUserLocalMatrix</a></b></td><td>　フレームの座標変換行列を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N12">MV1ResetFrameUserLocalMatrix</a></b></td><td>　フレームの座標変換行列をデフォルトに戻す</td></tr>
        <tr><td valign="top"><b><a href="#R6N13">MV1SetFrameVisible</a></b></td><td>　フレームの表示・非表示状態を変更する</td></tr>
        <tr><td valign="top"><b><a href="#R6N14">MV1GetFrameVisible</a></b></td><td>　フレームの表示・非表示状態を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N15">MV1SetFrameDifColorScale</a></b></td><td>　フレームのディフューズカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N16">MV1GetFrameDifColorScale</a></b></td><td>　フレームのディフューズカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N17">MV1SetFrameSpcColorScale</a></b></td><td>　フレームのスペキュラカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N18">MV1GetFrameSpcColorScale</a></b></td><td>　フレームのスペキュラカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N19">MV1SetFrameEmiColorScale</a></b></td><td>　フレームのエミッシブカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N20">MV1GetFrameEmiColorScale</a></b></td><td>　フレームのエミッシブカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N21">MV1SetFrameAmbColorScale</a></b></td><td>　フレームのアンビエントカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N22">MV1GetFrameAmbColorScale</a></b></td><td>　フレームのアンビエントカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N23">MV1GetFrameSemiTransState</a></b></td><td>　フレームに半透明要素があるかどうかを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N24">MV1SetFrameOpacityRate</a></b></td><td>　フレームの不透明度を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N25">MV1GetFrameOpacityRate</a></b></td><td>　フレームの不透明度を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N29">MV1SetFrameTextureAddressTransform</a></b></td><td>　フレームのテクスチャ座標変換パラメータを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R6N30">MV1ResetFrameTextureAddressTransform</a></b></td><td>　フレームのテクスチャ座標変換パラメータをリセットする</td></tr>
        <tr><td valign="top"><b><a href="#R6N26">MV1GetFrameTriangleNum</a></b></td><td>　フレームに含まれるポリゴンの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N27">MV1GetFrameMeshNum</a></b></td><td>　フレームに含まれるメッシュの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R6N28">MV1GetFrameMesh</a></b></td><td>　フレームに含まれるメッシュを取得する<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G15"><font size="3" color="#752400"><b>　　メッシュ関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R7N1">MV1GetMeshNum</a></b></td><td>　モデルに含まれるメッシュの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N2">MV1GetMeshMaterial</a></b></td><td>　メッシュが使用しているマテリアルの番号を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N3">MV1GetMeshTriangleNum</a></b></td><td>　メッシュに含まれる三角形ポリゴンの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N4">MV1SetMeshVisible</a></b></td><td>　メッシュの表示・非表示状態を変更する</td></tr>
        <tr><td valign="top"><b><a href="#R7N5">MV1GetMeshVisible</a></b></td><td>　メッシュの表示・非表示状態を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N6">MV1SetMeshDifColorScale</a></b></td><td>　メッシュのディフューズカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N7">MV1GetMeshDifColorScale</a></b></td><td>　メッシュのディフューズカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N8">MV1SetMeshSpcColorScale</a></b></td><td>　メッシュのスペキュラカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N9">MV1GetMeshSpcColorScale</a></b></td><td>　メッシュのスペキュラカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N10">MV1SetMeshEmiColorScale</a></b></td><td>　メッシュのエミッシブカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N11">MV1GetMeshEmiColorScale</a></b></td><td>　メッシュのエミッシブカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N12">MV1SetMeshAmbColorScale</a></b></td><td>　メッシュのアンビエントカラーのスケール値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N13">MV1GetMeshAmbColorScale</a></b></td><td>　メッシュのアンビエントカラーのスケール値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N14">MV1SetMeshOpacityRate</a></b></td><td>　メッシュの不透明度を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N15">MV1GetMeshOpacityRate</a></b></td><td>　メッシュの不透明度を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N16">MV1SetMeshDrawBlendMode</a></b></td><td>　メッシュの描画ブレンドモードを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N17">MV1GetMeshDrawBlendMode</a></b></td><td>　メッシュの描画ブレンドモードを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N18">MV1SetMeshDrawBlendParam</a></b></td><td>　メッシュの描画ブレンドパラメータを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N19">MV1GetMeshDrawBlendParam</a></b></td><td>　メッシュの描画ブレンドパラメータを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N20">MV1SetMeshBackCulling</a></b></td><td>　メッシュのバックカリングを行うかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N21">MV1GetMeshBackCulling</a></b></td><td>　メッシュのバックカリングを行うかどうかを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N22">MV1GetMeshMaxPosition</a></b></td><td>　メッシュに含まれる頂点のローカル座標での最大値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N23">MV1GetMeshMinPosition</a></b></td><td>　メッシュに含まれる頂点のローカル座標での最小値を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N31">MV1GetMeshTListNum</a></b></td><td>　メッシュに含まれるトライアングルリストの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N32">MV1GetMeshTList</a></b></td><td>　メッシュに含まれるトライアングルリストを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N26">MV1GetMeshSemiTransState</a></b></td><td>　メッシュに半透明要素があるかどうかを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N27">MV1SetMeshUseVertDifColor</a></b></td><td>　メッシュの頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N28">MV1GetMeshUseVertDifColor</a></b></td><td>　メッシュの頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかの設定を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R7N29">MV1SetMeshUseVertSpcColor</a></b></td><td>　メッシュの頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R7N30">MV1GetMeshUseVertSpcColor</a></b></td><td>　メッシュの頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかの設定を取得する<br><br><br></td></tr>


        <tr><td colspan="2">
            <a name="G15"><font size="3" color="#752400"><b>　　シェイプ関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R21N1">MV1GetShapeNum</a></b></td><td>　モデルに含まれるシェイプの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R21N2">MV1SearchShape</a></b></td><td>　指定名のシェイプをモデル中から検索する</td></tr>
        <tr><td valign="top"><b><a href="#R21N3">MV1SetShapeRate</a></b></td><td>　シェイプの適用率を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R21N4">MV1GetShapeRate</a></b></td><td>　シェイプの適用率を取得する<br><br><br></td></tr>


        <tr><td colspan="2">
            <a name="G20"><font size="3" color="#752400"><b>　　トライアングルリスト関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R18N1">MV1GetTriangleListNum</a></b></td><td>　モデルに含まれるトライアングルリストの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R18N2">MV1GetTriangleListVertexType</a></b></td><td>　トライアングルリストの頂点データタイプを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R18N3">MV1GetTriangleListPolygonNum</a></b></td><td>　トライアングルリストに含まれるポリゴンの数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R18N4">MV1GetTriangleListVertexNum</a></b></td><td>　トライアングルリストに含まれる頂点の数を取得する<br><br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G16"><font size="3" color="#752400"><b>　　コリジョン( 衝突判定 )関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R9N1">MV1SetupCollInfo</a></b></td><td>　コリジョン情報を構築する</td></tr>
        <tr><td valign="top"><b><a href="#R9N2">MV1TerminateCollInfo</a></b></td><td>　コリジョン情報の後始末をする</td></tr>
        <tr><td valign="top"><b><a href="#R9N3">MV1RefreshCollInfo</a></b></td><td>　コリジョン情報を更新する</td></tr>
        <tr><td valign="top"><b><a href="#R9N4">MV1CollCheck_Line</a></b></td><td>　線分とモデルの当たり判定</td></tr>
        <tr><td valign="top"><b><a href="#R9N5">MV1CollCheck_Sphere</a></b></td><td>　球とモデルの当たり判定</td></tr>
        <tr><td valign="top"><b><a href="#R9N8">MV1CollCheck_Capsule</a></b></td><td>　カプセルとモデルの当たり判定</td></tr>
        <tr><td valign="top"><b><a href="#R9N7">MV1CollCheck_GetResultPoly</a></b></td><td>　当たり判定結果ポリゴン配列から指定番のポリゴン情報を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R9N6">MV1CollResultPolyDimTerminate</a></b></td><td>　当たり判定結果ポリゴン配列の後始末をする<br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G17"><font size="3" color="#752400"><b>　　参照用メッシュ関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R10N1">MV1SetupReferenceMesh</a></b></td><td>　参照用メッシュのセットアップ</td></tr>
        <tr><td valign="top"><b><a href="#R10N2">MV1TerminateReferenceMesh</a></b></td><td>　参照用メッシュの後始末をする</td></tr>
        <tr><td valign="top"><b><a href="#R10N3">MV1RefreshReferenceMesh</a></b></td><td>　参照用メッシュを更新する</td></tr>
        <tr><td valign="top"><b><a href="#R10N4">MV1GetReferenceMesh</a></b></td><td>　参照用メッシュを取得する<br><br><br><br></td></tr>

        <tr><td colspan="2">
            <a name="G19"><font size="3" color="#005500"><b>プログラマブルシェーダー関係関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R17N1">GetValidShaderVersion</a></b></td><td>　使用できるシェーダーのバージョンを取得する</td></tr>
        <tr><td valign="top"><b><a href="#R17N36">GetMultiDrawScreenNum</a></b></td><td>　同時に描画を行うことができる画面の数を取得する</td></tr>
        <tr><td valign="top"><b><a href="#R17N2">LoadVertexShader</a></b></td><td>　頂点シェーダーバイナリを読み込みシェーダーハンドルを作成する</td></tr>
        <tr><td valign="top"><b><a href="#R17N3">LoadPixelShader</a></b></td><td>　ピクセルシェーダーバイナリを読み込みシェーダーハンドルを作成する</td></tr>
        <tr><td valign="top"><b><a href="#R17N4">DeleteShader</a></b></td><td>　シェーダーハンドルを削除する</td></tr>
        <tr><td valign="top"><b><a href="#R17N5">InitShader</a></b></td><td>　シェーダーハンドルを全て削除する<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R17N6">SetVSConstF</a></b></td><td>　頂点シェーダーの FLOAT4 型定数を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N7">SetVSConstFMtx</a></b></td><td>　頂点シェーダーの FLOAT4 型定数に行列を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N10">SetVSConstFArray</a></b></td><td>　頂点シェーダーの FLOAT4 型定数を配列を使って設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N14">ResetVSConstF</a></b></td><td>　頂点シェーダーの FLOAT4 型定数の設定を無効にする</td></tr>
        <tr><td valign="top"><b><a href="#R17N17">SetPSConstF</a></b></td><td>　ピクセルシェーダーの FLOAT4 型定数を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N18">SetPSConstFMtx</a></b></td><td>　ピクセルシェーダーの FLOAT4 型定数に行列を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N21">SetPSConstFArray</a></b></td><td>　ピクセルシェーダーの FLOAT4 型定数を配列を使って設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N25">ResetPSConstF</a></b></td><td>　ピクセルシェーダーの FLOAT4 型定数の設定を無効にする<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R17N28">SetRenderTargetToShader</a></b></td><td>　描画先を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N29">SetUseTextureToShader</a></b></td><td>　シェーダー描画で使用するテクスチャを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N30">SetUseVertexShader</a></b></td><td>　シェーダー描画に使用する頂点シェーダーを設定する</td></tr>
        <tr><td valign="top"><b><a href="#R17N31">SetUsePixelShader</a></b></td><td>　シェーダー描画に使用するピクセルシェーダーを設定する<br><br></td></tr>

        <tr><td valign="top"><b><a href="#R17N32">DrawPolygon2DToShader</a></b></td><td>　シェーダーを使って２Ｄポリゴンを描画する</td></tr>
        <tr><td valign="top"><b><a href="#R17N33">DrawPolygon3DToShader</a></b></td><td>　シェーダーを使って３Ｄポリゴンを描画する</td></tr>
        <tr><td valign="top"><b><a href="#R17N34">DrawPolygonIndexed2DToShader</a></b></td><td>　シェーダーを使って２Ｄポリゴンを描画する(インデックスを使用)</td></tr>
        <tr><td valign="top"><b><a href="#R17N35">DrawPolygonIndexed3DToShader</a></b></td><td>　シェーダーを使って３Ｄポリゴンを描画する(インデックスを使用)<br><br><br></td></tr>



        <tr><td colspan="2">
            <a name="G20"><font size="3" color="#005500"><b>シャドウマップ関係関数</b></font></a><br><br>
        </td></tr>

        <tr><td valign="top"><b><a href="#R20N1">MakeShadowMap</a></b></td><td>　シャドウマップを作成する</td></tr>
        <tr><td valign="top"><b><a href="#R20N2">DeleteShadowMap</a></b></td><td>　シャドウマップを削除する</td></tr>
        <tr><td valign="top"><b><a href="#R20N3">SetShadowMapLightDirection</a></b></td><td>　シャドウマップへの描画で想定するライトの方向を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R20N4">ShadowMap_DrawSetup</a></b></td><td>　シャドウマップへの描画の準備を行う</td></tr>
        <tr><td valign="top"><b><a href="#R20N5">ShadowMap_DrawEnd</a></b></td><td>　シャドウマップへの描画を終了する</td></tr>
        <tr><td valign="top"><b><a href="#R20N6">SetUseShadowMap</a></b></td><td>　描画で使用するシャドウマップを変更する</td></tr>
        <tr><td valign="top"><b><a href="#R20N7">SetShadowMapDrawArea</a></b></td><td>　シャドウマップに描画する範囲を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R20N8">SetShadowMapAdjustDepth</a></b></td><td>　シャドウマップを使用した３Ｄモデル描画時の深度判定の補正値を設定する</td></tr>
        <tr><td valign="top"><b><a href="#R20N9">TestDrawShadowMap</a></b></td><td>　シャドウマップを画面にテスト描画する<br><br><br></td></tr>



    </table>
    <table align="center" width="600" cellspacing="0" cellpadding="0" >

        <tr><td><hr></td></tr>

        <tr><td><font size="3" color="#005500"><b>３Ｄ図形描画関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N1">宣言</a></b></td><td><font color="#000088"><b>int DrawLine3D( VECTOR Pos1, VECTOR Pos2, int Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に線分を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Pos1 ： 線分の始点の座標<br>
            VECTOR Pos2 ： 線分の終点の座標<br>
            int Color ： 線分の色</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に Pos1 と Pos2 の座標を結ぶ線分を Color で指定した色で描画します。<br><br>
                    　引数 Pos1 と引数 Pos2 は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br>
<pre>
// 例：座標 ( 0.0f, 100.0f, 0.0f ) , ( 200.0f, 100.0f, 0.0f ) を結ぶ白色の線分を描画する
DrawLine3D( VGet( 0.0f, 100.0f, 0.0f ), VGet( 200.0f, 100.0f, 0.0f ), <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
</pre>
                    　Colorの値は画面の色の表現できる色の数によってかわってきます。
                    この色の値はライブラリの関数<b><a href="dxfunc_graph3.html#R4N5">『GetColor』</a></b>を使って取得します。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に線分を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄ空間上に線分を描画する
    DrawLine3D( <b><a href="#R11N1">VGet</a></b>( 100.0f, 100.0f, 0.0f ), VGet( 300.0f, 200.0f, 0.0f ), GetColor( 255,255,255 ) ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N2">宣言</a></b></td><td><font color="#000088"><b>int DrawTriangle3D( VECTOR Pos1, VECTOR Pos2, VECTOR Pos3, int Color, int FillFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に三角形を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Pos1 ： 三角形を形成する頂点１の座標<br>
            VECTOR Pos2 ： 三角形を形成する頂点２の座標<br>
            VECTOR Pos3 ： 三角形を形成する頂点３の座標<br>
            int Color ： 三角形の色<br>
            int FillFlag ： 三角形の中身を塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に Pos1 と Pos2 と Pos3 を三頂点とする三角形を Color で指定した色で描画します。<br><br>
                    　引数 Pos1、Pos2、Pos3 は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことが出来ます。<br>
<pre>
// 例：
// 座標 ( 100.0f, 100.0f,   0.0f ),
//      ( 200.0f, 200.0f,   0.0f ),
//      ( 200.0f, 250.0f, 100.0f ) を結ぶ三角形を描画する
<b><a href="#R14N2">DrawTriangle3D</a></b>(
    VGet( 100.0f, 100.0f,   0.0f ),
    VGet( 200.0f, 200.0f,   0.0f ),
    VGet( 200.0f, 250.0f, 100.0f ), <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), FALSE ) ;
</pre>
                    　Colorの値は画面の色の表現できる色の数によってかわってきます。
                    この色の値はライブラリの関数<b><a href="dxfunc_graph3.html#R4N5">『GetColor』</a></b>を使って取得します。<br>
                <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に三角形を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄ空間上に三角形を描画する
    <b><a href="#R14N2">DrawTriangle3D</a></b>(
        <b><a href="#R11N1">VGet</a></b>(100.0f,100.0f,  0.0f),
        VGet(500.0f,400.0f,  0.0f),
        VGet(600.0f,100.0f,100.0f), <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), FALSE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N4">宣言</a></b></td><td><font color="#000088"><b>int DrawSphere3D( VECTOR CenterPos, float r, int DivNum, int DifColor, int SpcColor, int FillFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に球を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR CenterPos ： 球の中心座標<br>
            float r ： 球の半径<br>
            int DivNum ： 球を形成するポリゴンの細かさ<br>
            int DifColor ： 球の頂点ディフューズカラー<BR>
            int SpcColor ： 球の頂点スペキュラカラー<BR>
            int FillFlag ： 球を塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に CenterPos を中心座標とした半径 r の球を描画します。<br><br>
                    　DivNum は球を形成するポリゴンの細かさです。<br><br>

                    　引数 CenterPos は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことが出来ます。<br>
<pre>
// 例：座標 ( 320.0f, 100.0f, 0.0f ) を中心に半径 80.0f の球を描画する
DrawSphere3D( VGet( 320.0f, 100.0f, 0.0f ), 80.0f, 16, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), GetColor( 0,0,0 ), FALSE ) ;
</pre>
                    　引数 DifColor と SpcColor はそれぞれ球の頂点ディフューズカラーと頂点スペキュラカラーです、
                    この関数で描かれる球はライティング計算が行われるので、
                    ただの「描画カラー」ではなくライティング計算で使用される「頂点ディフューズカラー( 拡散光色 )」と「頂点スペキュラカラー( 反射光色 )」を指定します。<br>
                    　この二つの色の値はライブラリの関数<b><a href="dxfunc_graph3.html#R4N5">『GetColor』</a></b>を使って取得します。<br>
                    　尚、この引数で指定する値は球を描画する際に用意される頂点データに含まれるディフューズカラーとスペキュラカラーですので、
                    <b><a href="#R14N22">SetMaterialUseVertDifColor</a></b> や <b><a href="#R14N10">SetMaterialUseVertSpcColor</a></b> で頂点カラーを使用しない設定にした場合はこの引数の値は使用されず、
                    <b><a href="#R14N11">SetMaterialParam</a></b> の引数で指定されたマテリアルのディフューズカラーとスペキュラカラーがそれぞれ使用されます。<br><br>

                    　因みに球の中身を塗りつぶす場合、
                    ＺバッファとＺバッファへの書き込みをそれぞれ <b><a href="#R14N12">SetUseZBuffer3D</a></b> 関数と <b><a href="#R14N13">SetWriteZBuffer3D</a></b> 関数で有効にしておかないと手前の面を描画した後に後ろの面が描画されたりして正常な見た目になりませんので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に球を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // ３Ｄ空間上に球を描画する
    DrawSphere3D( <b><a href="#R11N1">VGet</a></b>( 320.0f, 200.0f, 0.0f ), 80.0f, 32, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), GetColor( 255, 255, 255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N5">宣言</a></b></td><td><font color="#000088"><b>int DrawCapsule3D( VECTOR Pos1, VECTOR Pos2, float r, int DivNum, int DifColor, int SpcColor, int FillFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間にカプセルを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Pos1 ： カプセルを形成する二点中の一点の座標<br>
            VECTOR Pos2 ： カプセルを形成する二点中の一点の座標<br>
            float r ： カプセルの幅<br>
            int DivNum ： カプセルを形成するポリゴンの細かさ<br>
            int DifColor ： カプセルの頂点ディフューズカラー<BR>
            int SpcColor ： カプセルの頂点スペキュラカラー<BR>
            int FillFlag ： カプセルを塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間にカプセルを描画します。<br><br>

                    　この関数は大きさ r の Pos1 と Pos2 を中心座標とするカプセルの外側を結んだような形のカプセルを描画します。<br>
                    　DivNum はカプセルを形成するポリゴンの細かさです。<br><br>

                    　引数 Pos1 と Pos2 は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことが出来ます。<br>
<pre>
// 例：
// 座標 ( 320.0f, 100.0f, 0.0f ) と ( 320.0f, 300.0f, 0.0f ) を２点とする
// 半径 40.0f のカプセルを描画する
DrawCapsule3D( VGet(320.0f,100.0f,0.0f), VGet(320.0f,300.0f,0.0f), 40.0f,8,<b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>(255,255,0), FALSE);
</pre>
                    　引数 DifColor と SpcColor はそれぞれカプセルの頂点ディフューズカラーと頂点スペキュラカラーです、
                    この関数で描かれるカプセルはライティング計算が行われるので、
                    ただの「描画カラー」ではなくライティング計算で使用される「頂点ディフューズカラー( 拡散光色 )」と「頂点スペキュラカラー( 反射光色 )」を指定します。<br>
                    　この二つの色の値はライブラリの関数<b><a href="dxfunc_graph3.html#R4N5">『GetColor』</a></b>を使って取得します。<br>
                    　尚、この引数で指定する値はカプセルを描画する際に用意される頂点データに含まれるディフューズカラーとスペキュラカラーですので、
                    <b><a href="#R14N22">SetMaterialUseVertDifColor</a></b> や <b><a href="#R14N10">SetMaterialUseVertSpcColor</a></b> で頂点カラーを使用しない設定にした場合はこの引数の値は使用されず、
                    <b><a href="#R14N11">SetMaterialParam</a></b> の引数で指定されたマテリアルのディフューズカラーとスペキュラカラーがそれぞれ使用されます。<br><br>

                    　因みにカプセルの中身を塗りつぶす場合、
                    ＺバッファとＺバッファへの書き込みをそれぞれ <b><a href="#R14N12">SetUseZBuffer3D</a></b> 関数と <b><a href="#R14N13">SetWriteZBuffer3D</a></b> 関数で有効にしておかないと手前の面を描画した後に後ろの面が描画されたりして正常な見た目になりませんので注意してください。<br><br>
                <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上にカプセルを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // ３Ｄ空間上にカプセルを描画する
    DrawCapsule3D( <b><a href="#R11N1">VGet</a></b>( 320.0f, 100.0f, 0.0f ), VGet( 320.0f, 300.0f, 0.0f ), 40.0f, 8, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,255,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N6">宣言</a></b></td><td><font color="#000088"><b>int DrawCone3D( VECTOR TopPos, VECTOR BottomPos, float r, int DivNum, int DifColor, int SpcColor, int FillFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に円錐を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR TopPos ： 円錐の頂点の座標<br>
            VECTOR BottomPos ： 円錐の底辺の中心座標<br>
            float r ： 円錐の底辺の半径<br>
            int DivNum ： 円錐を形成するポリゴンの細かさ<br>
            int DifColor ： 円錐の頂点ディフューズカラー<BR>
            int SpcColor ： 円錐の頂点スペキュラカラー<BR>
            int FillFlag ： 円錐を塗りつぶすかどうか( TRUE：塗りつぶす　FALSE：塗りつぶさない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に TopPos を頂点、BottomPos を底辺の中心とした半径 r の円錐を描画します。<br>
                    　DivNum はカプセルを形成するポリゴンの細かさです。<br><br>

                    　引数 TopPos と BottomPos は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことが出来ます。<br>
<pre>
// 例：
// 座標 ( 320.0f, 400.0f, 0.0f ) を頂点
//      ( 320.0f, 100.0f, 0.0f ) を底辺の中心とした円錐を描画する
DrawCone3D( VGet(320.0f,400.0f,0.0f), VGet(320.0f,100.0f,0.0f),80.0f,8,<b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>(255,255,0), FALSE);
</pre>
                    　引数 DifColor と SpcColor はそれぞれ円錐の頂点ディフューズカラーと頂点スペキュラカラーです、
                    この関数で描かれる円錐はライティング計算が行われるので、
                    ただの「描画カラー」ではなくライティング計算で使用される「頂点ディフューズカラー( 拡散光色 )」と「頂点スペキュラカラー( 反射光色 )」を指定します。<br>
                    　この二つの色の値はライブラリの関数<b><a href="dxfunc_graph3.html#R4N5">『GetColor』</a></b>を使って取得します。<br>
                    　尚、この引数で指定する値は円錐を描画する際に用意される頂点データに含まれるディフューズカラーとスペキュラカラーですので、
                    <b><a href="#R14N22">SetMaterialUseVertDifColor</a></b> や <b><a href="#R14N10">SetMaterialUseVertSpcColor</a></b> で頂点カラーを使用しない設定にした場合はこの引数の値は使用されず、
                    <b><a href="#R14N11">SetMaterialParam</a></b> の引数で指定されたマテリアルのディフューズカラーとスペキュラカラーがそれぞれ使用されます。<br><br>

                    　因みに円錐の中身を塗りつぶす場合、
                    ＺバッファとＺバッファへの書き込みをそれぞれ <b><a href="#R14N12">SetUseZBuffer3D</a></b> 関数と <b><a href="#R14N13">SetWriteZBuffer3D</a></b> 関数で有効にしておかないと手前の面を描画した後に後ろの面が描画されたりして正常な見た目になりませんので注意してください。<br><br>
                <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に円錐を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // ３Ｄ空間上に円錐を描画する
    DrawCone3D( <b><a href="#R11N1">VGet</a></b>( 320.0f, 400.0f, 0.0f ), VGet( 320.0f, 100.0f, 0.0f ), 80.0f, 16, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,0,255 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N9">宣言</a></b></td><td><font color="#000088"><b>int DrawBillboard3D( VECTOR Pos, float cx, float cy, float Size, float Angle, int GrHandle, int TransFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に画像を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Pos ： 画像を描画する座標<br>
            float cx, cy ： 描画する画像の中心座標( 0.0f 〜 1.0f )<br>
            float Size ： 描画する画像のサイズ<br>
            float Angle ： 描画する画像の回転角度( ラジアン単位 )<br>
            int GrHandle ： 描画する画像のハンドル<br>
            int TransFlag ： 透過色が有効か、フラグ（ TRUEで有効 FALSE で無効 ）</td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に引数 Pos が示す座標に Size の大きさで画像を描画します。<br>
                    　引数 Pos は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことが出来ます。<br><br>

                    　cx, cy は画像の中心座標を指定する引数で、画像の中心を Pos の位置にしたい場合は cx, cy 共に 0.5f にします。<br>
                    　Size は画像の横方向の大きさで、
                    もし縦と横の大きさが違う場合は縦方向の大きさは画像の縦横比から算出されます。<br>
                    　Angle は画像を回転させたい場合に使用します。回転させない場合は 0.0f を指定します。回転の中心は cx, cy で指定した座標になります。<br>
                    　GrHandle は描画する画像のハンドルで、<b><a href="dxfunc_graph1.html#R3N2">LoadGraph</a></b> 関数などで読み込んだ画像を使用します。<br>
                    　TransFlag は透過色を使用するかどうかで、透過しない場合は FALSE、透過させる場合は TRUE を渡します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に画像を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int GrHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 画像の読み込み
    GrHandle = <b><a href="dxfunc_graph1.html#R3N2">LoadGraph</a></b>( "Test1.bmp" ) ;

    // ３Ｄ空間上に画像を描画
    DrawBillboard3D( <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 100.0f ), 0.5f, 0.5f, 120.0f, 0.0f, GrHandle, TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N20">宣言</a></b></td><td><font color="#000088"><b>int DrawModiBillboard3D( VECTOR Pos, float x1, float y1, float x2, float y2, float x3, float y3, float x4, float y4, int GrHandle, int TransFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に２次元的な変形を加えた画像を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Pos ： 画像を描画する座標<br>
            float x1, y1, x2, y2<br>
            　　　x3, y3, x4, y4 ： x1から順に描画する画像の左上、右上、<br>
　　　　　　　　　　　　　　　　　　右下、左下の頂点の座標<br>
            int GrHandle ： 描画する画像のハンドル<br>
            int TransFlag ： 透過色が有効か、フラグ（ TRUEで有効 FALSE で無効 ）</td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に引数 Pos が示す座標に <b><a href="dxfunc_graph1.html#R3N11">DrawModiGraph</a></b> 関数で描画するような変形画像を描画します。<br>
                    
                    　x1, y1 〜 x4, y4 の基準となる座標を Pos で指定する、Y軸のプラスマイナスが逆、
                    ということ以外は DrawModiGraph 関数と同じですので、
                    解説については DrawModiGraph 関数の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に変形画像を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int GrHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 画像の読み込み
    GrHandle = <b><a href="dxfunc_graph1.html#R3N2">LoadGraph</a></b>( "Test1.bmp" ) ;

    // ３Ｄ空間上に画像を描画
    DrawModiBillboard3D( <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 100.0f ),
        -100.0f,  200.0f,
         100.0f,  200.0f,
         100.0f, -200.0f,
        -100.0f, -200.0f, GrHandle, TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
    


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N7">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygon3D( VERTEX3D *Vertex, int PolygonNum, int GrHandle, int TransFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に三角形ポリゴンの集合を描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX3D *Vertex ： 三角形ポリゴンを形成する頂点配列のアドレス<br>
            int PolygonNum ： 描画する三角形ポリゴンの数<br>
            int GrHandle ： 描画するポリゴンに貼り付ける画像のハンドル( 画像を張らない場合は DX_NONE_GRAPH ) <br>
            int TransFlag ： 透過色が有効か、フラグ（TRUEで有効FALSEで無効）</td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に引数 Vertex が示す頂点配列を元に PolygonNum 個の三角形ポリゴンの集合を描画します。<br>
                    　ポリゴン一つ辺りに３つの頂点が必要なので、Vertex が示す配列には PolygonNum × ３ 個の頂点データが必要になります。<br>
                    　また、GrHandle で指定する画像は８以上の２のｎ乗のピクセルサイズ( 8, 16, 32, 64, 128, 256, 512, 1024 ... )である必要があり( 使える画像サイズの限界はハードウエアが扱えるサイズの限界ですので、2048 以上のピクセルサイズは避けた方が良いです )、
                    更に <b><a href="dxfunc_graph1.html#R3N21">DerivationGraph</a></b> で抜き出した画像や、<b><a href="dxfunc_graph1.html#R3N3">LoadDivGraph</a></b> 等の分割読込した画像を使用すると正常に動作しないという、使用できる画像に関して少し制限事項の多い関数です。
                    <br><br>

                    　頂点データ VERTEX3D は構造体で、内容は以下のようになっています。
<pre>
// ３Ｄ描画に使用する頂点データ型
struct VERTEX3D
{
    // 座標
    VECTOR pos ;

    // 法線
    VECTOR norm ;

    // ディフューズカラー
    COLOR_U8 dif ;

    // スペキュラカラー
    COLOR_U8 spc ;

    // テクスチャ座標
    float u, v ;

    // サブテクスチャ座標
    float su, sv ;
} ;
</pre>
                    VECTOR pos<br>
                    　頂点の座標です。<br>
                    　VECTOR は中に float x, y, z を持つ構造体です。<br>
                    　float x, y, z を引数として取り、それをそのまま VECTOR 構造体に代入して戻り値として返してくる関数 <b><a href="#R11N1">VGet</a></b> を使用すると代入処理を簡素に書くことができます。 <br><br>

                    VECTOR norm<br>
                    　頂点の法線です。ライティング計算に使用されます。<br><br>

                    COLOR_U8 dif<br>
                    　頂点のディフューズカラー( 拡散光色 )です。基本的なポリゴンの色はこれになります。<br>
                    　<b><a href="#R14N22">SetMaterialUseVertDifColor</a></b> で頂点データのディフューズカラーを使用しない設定にしている場合はこの情報は無視され、代わりにマテリアルのディフューズカラーが使用されます。( 初期設定では頂点データのディフューズカラーが使用されます )<br>
                    　COLOR_U8 は 中に unsigned char b, g, r, a を持つ構造体で、輝度をそれぞれ 0 〜 255 で表現します。<br>
                    　int b, g, r, a を引数として取り、それをそのまま COLOR_U8 構造体に代入して戻り値として返してくる関数 <b><a href="#R14N15">GetColorU8</a></b> を使用すると代入処理を簡素に書くことが出来ます。<br><br>

                    COLOR_U8 spc<br>
                    　頂点のスペキュラカラー( 反射光色 )です。<br>
                    　<b><a href="#R14N10">SetMaterialUseVertSpcColor</a></b> で頂点データのスペキュラカラーを使用しない設定にしている場合はこの情報は無視され、代わりにマテリアルのスペキュラカラーが使用されます。( 初期設定では頂点データのディフューズカラーが使用されます )<br><br>

                    float u, v<br>
                    　頂点のテクスチャ座標です。画像の左上端を u = 0.0f　v = 0.0f 右下端を u = 1.0f　v = 1.0f とした座標で指定します。<br><br>

                    float su, sv<br>
                    　頂点のサブテクスチャ座標です。今のバージョンでは使用しません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上にポリゴンを２つ描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3D Vertex[ 6 ] ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセット
    Vertex[ 0 ].pos  = <b><a href="#R11N1">VGet</a></b>( 100.0f, 100.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = <b><a href="#R14N15">GetColorU8</a></b>( 255,255,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 250.0f, 100.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 0.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 100.0f, 300.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8(   0,255,255,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 0.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( 400.0f, 200.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8(   0,255,255,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 0.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet( 600.0f, 400.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 0.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet( 500.0f,  50.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 0.0f ;
    Vertex[ 5 ].v    = 0.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // ２ポリゴンの描画
    DrawPolygon3D( Vertex, 2, DX_NONE_GRAPH, FALSE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N8">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygonIndexed3D( VERTEX3D *Vertex, int VertexNum, unsigned short *Indices, int PolygonNum, int GrHandle, int TransFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ空間に三角形ポリゴンの集合を描画する(インデックス)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX3D *Vertex ： 三角形ポリゴンを形成する頂点配列のアドレス<br>
            int VertexNum ： 使用する頂点の数<br>
            unsigned short *Indices ： 頂点インデックス配列へのアドレス<br>
            int PolygonNum ： 描画する三角形ポリゴンの数<br>
            int GrHandle ： 描画するポリゴンに貼り付ける画像のハンドル( 画像を張らない場合は DX_NONE_GRAPH ) <br>
            int TransFlag ： 透過色が有効か、フラグ（TRUEで有効FALSEで無効）</td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に引数 Vertex が示す頂点配列と引数 Indices が示す頂点インデックスを元に PolygonNum 個の三角形ポリゴンの集合を描画します。<br>
                    　<b><a href="#R14N7">DrawPolygon3D</a></b> では一つのポリゴンに付き３つの頂点データを用意していましたが、
                    多くの場合複数のポリゴンで同じ頂点を使用しますのでポリゴン毎に独立した３頂点を用意すると無駄が生じます、
                    それを回避するためにこの関数では頂点データと共に「どの三頂点を使用してポリゴンを形成するか」という頂点インデックスデータを用いてポリゴンを描画します。
                    ( 例えば Vertex 配列の０番目と２番目と５番目の頂点データを用いてポリゴンを形成したい場合は、インデックス情報は 0, 2, 5 となります )<br>
                    　ポリゴン一つ辺りに３つの頂点インデックスが必要なので、Indices が示す配列には PolygonNum × ３ 個の頂点インデックスデータが必要になります。<br>
                    　尚、頂点インデックスは型が unsigned short なので、使用できる頂点データの数は最大で 65536個となります。<br><br>

                    　また、GrHandle で指定する画像は８以上の２のｎ乗のピクセルサイズ( 8, 16, 32, 64, 128, 256, 512, 1024 ... )である必要があり( 使える画像サイズの限界はハードウエアが扱えるサイズの限界ですので、2048 以上のピクセルサイズは避けた方が良いです )、
                    更に <b><a href="dxfunc_graph1.html#R3N21">DerivationGraph</a></b> で抜き出した画像や、<b><a href="dxfunc_graph1.html#R3N3">LoadDivGraph</a></b> 等の分割読込した画像を使用すると正常に動作しないという、使用できる画像に関して少し制限事項の多い関数です。

                    　頂点データ VERTEX3D の内容については DrawPolygon3D 関数の解説をご参照ください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に４つの頂点データを使用してポリゴンを２つ描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3D Vertex[ 4 ] ;
    WORD Index[ 6 ] ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ４頂点分のデータをセット
    Vertex[ 0 ].pos  = <b><a href="#R11N1">VGet</a></b>( 100.0f, 100.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = <b><a href="#R14N15">GetColorU8</a></b>( 255,255,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 250.0f, 100.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 0.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 100.0f, 300.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8(   0,255,255,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 0.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;

    Vertex[ 3 ].pos  = VGet( 400.0f, 200.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8(   0,255,255,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 0.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    // ２ポリゴン分のインデックスデータをセット
    Index[ 0 ] = 0 ;
    Index[ 1 ] = 1 ;
    Index[ 2 ] = 2 ;
    Index[ 3 ] = 3 ;
    Index[ 4 ] = 2 ;
    Index[ 5 ] = 1 ;

    // ２ポリゴンの描画
    DrawPolygonIndexed3D( Vertex, 4, Index, 2, DX_NONE_GRAPH, FALSE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N22">宣言</a></b></td><td><font color="#000088"><b>int SetMaterialUseVertDifColor( int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ図形描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int UseFlag ： 頂点データのディフューズカラーを使用するかどうか<br>
            　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R14N4">DrawSphere3D</a></b>, <b><a href="#R14N5">DrawCapsule3D</a></b>, <b><a href="#R14N6">DrawCone3D</a></b>, <b><a href="#R14N7">DrawPolygon3D</a></b>, <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> の３Ｄ図形描画関数で描画処理をする際のライティング計算に頂点データのディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定します。( 初期設定では使用します )<br><br>

                    　「使用する」場合は <b><a href="#R14N11">SetMaterialParam</a></b> 関数の引数で指定するディフューズカラー( MATERIALPARAM 構造体のメンバ変数 Diffuse )は無視され、
                    代わりに頂点データのディフューズカラー( VERTEX3D 構造体のメンバ変数 dif )がライティング計算に使用されます。<br><br>

                    　「使用しない」場合は <b><a href="#R14N11">SetMaterialParam</a></b> 関数の引数で指定するディフューズカラーがライティング計算に使用され、
                    頂点データのディフューズカラーは無視されます。<br><br>

                    　尚、<b><a href="#R13N44">SetUseLighting</a></b> 関数でライティング計算をしない設定にした場合は、
                    この関数の設定に関係なく頂点データのディフューズカラーが使用されます。<br><br> 
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に標準の設定( 頂点データのディフューズカラーを使用する )で球を描画した後、<br>
            　頂点データのディフューズカラーを使用しない設定にして、マテリアルのディフューズカラーを<br>
            　黄色にした上で再度球を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATERIALPARAM Material ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // デフォルトの設定で３Ｄ空間上に球を描画する
    <b><a href="#R14N4">DrawSphere3D</a></b>( <b><a href="#R11N1">VGet</a></b>( 160.0f, 200.0f, 0.0f ), 80.0f, 32, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // 頂点データのディフューズカラーを使用しないようにする
    SetMaterialUseVertDifColor( FALSE ) ;

    // マテリアルのディフューズカラーを黄色にする
    Material.Diffuse  = <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 1.0f, 0.0f, 1.0f ) ;
    Material.Specular = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Ambient  = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Emissive = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Power    = 20.0f ;
    <b><a href="#R14N11">SetMaterialParam</a></b>( Material ) ;

    // 再度３Ｄ空間上に球を描画する( 引数 DifColor の値は無視されます )
    DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 255,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N10">宣言</a></b></td><td><font color="#000088"><b>int SetMaterialUseVertSpcColor( int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ図形描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int UseFlag ： 頂点データのスペキュラカラーを使用するかどうか<br>
            　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R14N4">DrawSphere3D</a></b>, <b><a href="#R14N5">DrawCapsule3D</a></b>, <b><a href="#R14N6">DrawCone3D</a></b>, <b><a href="#R14N7">DrawPolygon3D</a></b>, <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> の３Ｄ図形描画関数で描画処理をする際のライティング計算に頂点データのスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定します。( 初期設定では使用します )<br><br>

                    　「使用する」場合は <b><a href="#R14N11">SetMaterialParam</a></b> 関数の引数で指定するスペキュラカラー( MATERIALPARAM 構造体のメンバ変数 Specular )は無視され、
                    代わりに頂点データのスペキュラカラー( VERTEX3D 構造体のメンバ変数 spc )がライティング計算に使用されます。<br><br>

                    　「使用しない」場合は <b><a href="#R14N11">SetMaterialParam</a></b> 関数の引数で指定するスペキュラカラーがライティング計算に使用され、
                    頂点データのスペキュラカラーは無視されます。<br><br>

                    　尚、<b><a href="#R13N44">SetUseLighting</a></b> 関数でライティング計算をしない設定にした場合は、
                    この関数の設定に関係なく頂点データのスペキュラカラーが使用されます。<br><br> 
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３Ｄ空間上に標準の設定( 頂点データのスペキュラカラーを使用する )で球を描画した後、<br>
            　頂点データのスペキュラカラーを使用しない設定にして、マテリアルのスペキュラカラーを<br>
            　黄色にした上で再度球を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATERIALPARAM Material ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // デフォルトの設定で３Ｄ空間上に球を描画する
    <b><a href="#R14N4">DrawSphere3D</a></b>( <b><a href="#R11N1">VGet</a></b>( 160.0f, 200.0f, 0.0f ), 80.0f, 32, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // 頂点データのスペキュラカラーを使用しないようにする
    SetMaterialUseVertSpcColor( FALSE ) ;

    // マテリアルのスペキュラカラーを黄色にする
    Material.Diffuse  = <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 0.0f, 1.0f ) ;
    Material.Specular = GetColorF( 1.0f, 1.0f, 0.0f, 0.0f ) ;
    Material.Ambient  = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Emissive = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Power    = 20.0f ;
    <b><a href="#R14N11">SetMaterialParam</a></b>( Material ) ;

    // 再度３Ｄ空間上に球を描画する( 引数 SpcColor の値は無視されます )
    DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N11">宣言</a></b></td><td><font color="#000088"><b>int SetMaterialParam( MATERIALPARAM Material ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>３Ｄ図形描画のライティング計算に使用するマテリアルパラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATERIALPARAM Material ： マテリアルパラメータ
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R14N4">DrawSphere3D</a></b>, <b><a href="#R14N5">DrawCapsule3D</a></b>, <b><a href="#R14N6">DrawCone3D</a></b>, <b><a href="#R14N7">DrawPolygon3D</a></b>, <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> の３Ｄ図形描画関数で描画処理をする際のライティング計算に使用するマテリアルパラメータを設定します。<br><br>

                    　設定に使用する MATERIALPARAM 構造体は以下のメンバ変数を持っています。<br><br>

                    ディフューズカラー<BR>
                    COLOR_F Diffuse ;<br>
                    　　拡散光色です。ライトのディフューズカラーと掛け合わされてライティング計算に使用されます。<br>
                    　　この値は <b><a href="#R14N22">SetMaterialUseVertDifColor</a></b> 関数で頂点データのディフューズカラーを使用しない設定にしていた場合のみ使用されます。( 初期状態では頂点データのディフューズカラーが使用され、この値は無視されます )<br><br>

                    アンビエントカラー<BR>
                    COLOR_F Ambient ;<br>
                    　　環境光色です。ライトのアンビエントカラーと掛け合わされてライティング計算に使用されます。<br><br>

                    スペキュラカラー<BR>
                    COLOR_F Specular ;<br>
                    　　反射光色です。ライトのスペキュラカラーと掛け合わされてライティング計算に使用されます。<br>
                    　　この値は <b><a href="#R14N10">SetMaterialUseVertSpcColor</a></b> 関数で頂点データのスペキュラカラーを使用しない設定にしていた場合のみ使用されます。( 初期状態では頂点データのスペキュラカラーが使用され、この値は無視されます )<br><br>

                    エミッシブカラー<BR>
                    COLOR_F Emissive ;<br>
                    　　自己発光色です。ライトが無くても、この値が０以外になっていると自己発光します。<br><br>

                    スペキュラの強さ<br>
                    float Power ;<br>
                    　　スペキュラハイライトの角度範囲を決定する値です。<br>
                    　　値が小さいほど範囲が広くなります。10.0f 〜 20.0f 辺りが丁度いい範囲です。<br><br>

                    　尚、<b><a href="#R13N44">SetUseLighting</a></b> 関数でライティング計算をしない設定にした場合は、
                    この関数の設定は一切無視されます。<br><br> 
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　マテリアルの設定で自己発光色を暗い青色にした上で球を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATERIALPARAM Material ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // マテリアルの自己発光色を暗い青色にする
    Material.Diffuse  = <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 0.0f, 1.0f ) ;
    Material.Specular = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Ambient  = GetColorF( 0.0f, 0.0f, 0.0f, 0.0f ) ;
    Material.Emissive = GetColorF( 0.0f, 0.0f, 0.5f, 0.0f ) ;
    Material.Power    = 20.0f ;
    SetMaterialParam( Material ) ;

    // デフォルトの設定で３Ｄ空間上に球を描画する
    <b><a href="#R14N4">DrawSphere3D</a></b>( <b><a href="#R11N1">VGet</a></b>( 320.0f, 200.0f, 0.0f ), 80.0f, 32, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N12">宣言</a></b></td><td><font color="#000088"><b>int SetUseZBuffer3D( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｚバッファを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Flag ： Ｚバッファを使用するかどうかのフラグ<br>
            　　　　　　( TRUE：使用する  FALSE：使用しない( 初期設定 ) )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R14N4">DrawSphere3D</a></b>, <b><a href="#R14N5">DrawCapsule3D</a></b>, <b><a href="#R14N6">DrawCone3D</a></b>, <b><a href="#R14N7">DrawPolygon3D</a></b>, <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> の３Ｄ図形描画関数で描画処理をする際にＺバッファを使用するかどうかを設定します。<br><br>

                    　Ｚバッファは主に３Ｄ空間に存在する物を前後関係を意識せずに都合の良い順番で描画するために使用するもので、
                    これを使用することで立体物を描画する際に画面( フレームバッファ )に色情報の他に描画したピクセルが「カメラ( 画面 )からどれだけ離れているか」という奥行き情報も一緒に書き込み、
                    その後画面上の同じ場所( ピクセル )に別のものが書かれようとしたときは以前書いたものよりカメラ( 画面 )との距離が短いかどうかを判定して、
                    以前書いたものより遠くにある場合は後から書こうとしたものを書き込まず、
                    以前書いたものをそのまま残す、
                    つまりどんな順序で立体物を描画しても必ずカメラに近い物が最終描画結果として画面の前面に表示されるようになります。
                    ( 逆にＺバッファを使用しない場合は描画物同士の前後関係は無視され、
                    通常の描画どおり「後から書いたものが今まで書いてあったものを上書きする」ので、
                    立体物を前後関係を無視して都合の良い順番で描画すると後ろにあるはずのものが手前のものより前面に表示されるというおかしな描画結果になります )<br><br>

                    　この関数はそのＺバッファを使うかどうかを設定する関数で、
                    使用する場合は TRUE を、使用しない場合は FALSE を渡します。<br><br>

                    　因みにこの関数は書き込みの際にＺバッファに「既に書き込まれているカメラ( 画面
                    )からの距離」と「これから書き込むピクセルのカメラからの距離」を比較して、
                    「既に書き込まれているカメラとの距離」より「これから書くもの( ピクセル )のカメラからの距離」の方が長かった場合は書き込まない、
                    という処理をするかどうかを設定するだけで、
                    書き込むという判断が決定した後Ｚバッファに「これから書くもの( ピクセル )のカメラからの距離」を書き込むかどうかの設定は <b><a href="#R14N13">SetWriteZBuffer3D</a></b> 関数で行います。
                    ( 初期設定では「書き込まない」になっています )<br><br>

                    　尚、この関数の設定はモデルの描画には影響を与えません。
                    モデルの描画時にＺバッファを使用するかどうかは <b><a href="#R3N26">MV1SetUseZBuffer</a></b> 関数で設定します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Ｚバッファを有効にしない状態で球を描画した後、Ｚバッファを有効にして<br>
            　更にＺバッファへの書き込みも行う設定にして再度球を描画します。<br>
            　　Ｚバッファを有効にしない状態では球の奥の面が手前の面より後に描画される関係で<br>
            　正しい描画結果が得られません。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // デフォルトの設定で３Ｄ空間上に球を描画する
    <b><a href="#R14N4">DrawSphere3D</a></b>( <b><a href="#R11N1">VGet</a></b>( 160.0f, 200.0f, 0.0f ), 80.0f, 32, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファを有効にした状態で再度３Ｄ空間上に球を描画する
    DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N13">宣言</a></b></td><td><font color="#000088"><b>int SetWriteZBuffer3D( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｚバッファに書き込みを行うかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Flag ： Ｚバッファに書き込みを行うかどうかのフラグ<br>
            　　　　　　( TRUE：書き込む  FALSE：書き込まない( 初期設定 ) )
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　Ｚバッファを使用する設定になっている状態で描画処理が行われた際に、
                    Ｚバッファへの書き込みを行うかどうかの設定を変更する関数です。
                    ( Ｚバッファの説明については <b><a href="#R14N12">SetUseZBuffer3D</a></b> 関数の解説を参照してください )<br><br>

                    　この関数に TRUE を渡した場合はＺバッファの判定後「書き込む」ことになった場合に画面(
                    フレームバッファ )に対して色情報と共にカメラと描画物との距離も記録されます。<br>
                    　FALSE を渡した場合はＺバッファの判定後「書き込む」ことになった場合に画面(
                    フレームバッファ )に対して色情報のみ記録されます。
                    ( 初期状態は FALSE( 書き込まない ) です )<br><br>

                    　尚、この関数の設定はモデルの描画には影響を与えません。
                    モデルの描画時にＺバッファを使用するかどうかは <b><a href="#R3N26">MV1SetUseZBuffer</a></b> 関数で設定します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Ｚバッファを有効にしない状態で球を描画した後、Ｚバッファを有効にして<br>
            　再度球を描画します。<br>
            　　Ｚバッファを有効にしない状態では球の奥の面が手前の面より後に描画される関係で<br>
            　正しい描画結果が得られません。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // デフォルトの設定で３Ｄ空間上に球を描画する
    <b><a href="#R14N4">DrawSphere3D</a></b>( <b><a href="#R11N1">VGet</a></b>( 160.0f, 200.0f, 0.0f ), 80.0f, 32, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // Ｚバッファを有効にする
    <b><a href="#R14N12">SetUseZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファへの書き込みを有効にする
    <b><a href="#R14N13">SetWriteZBuffer3D</a></b>( TRUE ) ;

    // Ｚバッファを有効にした状態で再度３Ｄ空間上に球を描画する
    DrawSphere3D( VGet( 480.0f, 200.0f, 0.0f ), 80.0f, 32, GetColor( 128,0,0 ), GetColor( 255,255,255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N19">宣言</a></b></td><td><font color="#000088"><b>int SetUseBackCulling( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ポリゴンのバックカリングを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Flag ： バックカリングを行うかどうかのフラグ<br>
            　　　　　　( TRUE：行う  FALSE：行わない( 初期設定 ) )
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R14N2">DrawTriangle3D</a></b>, <b><a href="#R14N4">DrawSphere3D</a></b>, <b><a href="#R14N5">DrawCapsule3D</a></b>, <b><a href="#R14N6">DrawCone3D</a></b>, <b><a href="#R14N7">DrawPolygon3D</a></b>, <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> でポリゴンを描画する際にバックカリングを行うかどうかを設定します。<br><br>
                    
                    　バックカリングとは裏面になっているポリゴンを書かない処理のことです。<br>
                    　例えば <b><a href="#R14N4">DrawSphere3D</a></b> 関数で球を描画する場合、
                    球の画面の方を向いていない面は常に画面の方を向いている面に隠れて画面には表示されないことになりますが、
                    バックカリングを行わない場合は必ず隠れることが分かっている面も画面への描画処理が行われるのでその分描画負荷が高くなります。<br>
                    　このような場合にバックカリングを行うようにすると画面に対して後ろを向いている面を描画しない( カリング )ようになるので、
                    裏面の描画負荷のぶん処理が高速になります。<br><br>

                    　因みに裏面かどうかは、ポリゴンを画面に映した際のポリゴンを形成する３頂点を頂点の指定順にスクリーン座標をなぞった場合に、
                    右回りになっているか左回りになっているかで判断します。( 左回りの場合に裏面だと判断され、カリングが有効な場合はカリングされます )<br>
                    　<b><a href="#R14N7">DrawPolygon3D</a></b> や <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> で直接頂点を扱ってポリゴンを描画する場合にバックカリングを使用する場合には形成するポリゴンの向きを意識する必要がありますので注意してください。<br><br>
                    
                    　尚、この関数の設定はモデルの描画には影響を与えません。
                    ( モデルはデフォルトではバックカリングＯＮになっていて、
                    ツール上でメッシュ単位でカリングを行うかどうかを設定することができます )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　画面右側にバックカリングを無効の状態で、画面左側にバックカリングを有効にした状態でそれぞれ球を描画します。<br>
            　　Ｚバッファを使用しない状態なのでバックカリングを有効にしていない画面右側の球は裏面のポリゴンが表面のポリゴンの<br>
            　後に描画されるという現象が発生するので見た目が破綻しますが、バックカリングを有効にした状態で描画している画面左側の<br>
            　球は裏面のポリゴンが描画されないのでＺバッファを有効にしていない状態でも正常な見た目で描画されます。<br>
            　( 因みにバックカリングを行うことで見た目的に正常な描画結果が得られるのは描画するポリゴン集合にへこんだ部分がない場合のみです )
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // バックカリングなしで３Ｄ空間上に球を描画する
    <b><a href="#R14N4">DrawSphere3D</a></b>( <b><a href="#R11N1">VGet</a></b>( 500.0f, 200.0f, 0.0f ), 80.0f, 8, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), GetColor( 255, 255, 255 ), TRUE ) ;

    // バックカリングを有効にする
    SetUseBackCulling( TRUE ) ;

    // バックカリングありで３Ｄ空間上に球を描画する
    DrawSphere3D( VGet( 140.0f, 200.0f, 0.0f ), 80.0f, 8, GetColor( 255,0,0 ), GetColor( 255, 255, 255 ), TRUE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N21">宣言</a></b></td><td><font color="#000088"><b>int SetTextureAddressModeUV( int ModeU, int ModeV ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャアドレスモードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ModeU ： Ｕ値のテクスチャアドレスモード<br>
            int ModeV ： Ｖ値のテクスチャアドレスモード
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R14N7">DrawPolygon3D</a></b>, <b><a href="#R14N8">DrawPolygonIndexed3D</a></b> でポリゴンを描画する際に使用されるテクスチャアドレスモードを設定します。<br><br>

                    　アドレスモードとは画像サイズ以上のテクスチャ座標が指定された場合にどう表示するかというもので、以下の３種類があります。<br><br><br>

                    DX_TEXADDRESS_WRAP<br><br>

                    　画像サイズ以上のテクスチャ座標の部分は素直に繰り返します。<br><br><br>


                    DX_TEXADDRESS_MIRROR<br><br>

                    　画像サイズ以上のテクスチャ座標の部分は鏡に映されたように反転する表示と、もとの反転していない表示とを繰り返します。<br>
                    　例えば４倍のテクスチャ座標が指定された場合　通常の見た目・反転した見た目・通常の見た目・反転した見た目　という風になります。<br><br><br>

                    DX_TEXADDRESS_CLAMP<br><br>

                    　他のモードと違って画像が繰り返されず、画像サイズ以上のテクスチャ座標の部分は画像の端のピクセルが引き伸ばされたような見た目になります。<br><br><br>

                    　アドレスモードはＵ方向とＶ方向で別々に指定することができます。<br>
                    　初期状態ではＵ，Ｖ共に DX_TEXADDRESS_CLAMP です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　テクスチャのアドレスモードをＵ方向を DX_TEXADDRESS_WRAP に、Ｖ方向を DX_TEXADDRESS_MIRROR にした上で<br>
            　テクスチャサイズの３倍のテクスチャ座標を使ってポリゴンを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3D Vertex[ 6 ] ;
    int GrHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ポリゴンに貼り付ける画像の読みこみ
    GrHandle = <b><a href="dxfunc_graph1.html#R3N2">LoadGraph</a></b>( "Kao.bmp" ) ;

    // テクスチャのアドレスモードをＵ方向を DX_TEXADDRESS_WRAP に
    // Ｖ方向を DX_TEXADDRESS_MIRROR に設定
    SetTextureAddressModeUV( DX_TEXADDRESS_WRAP, DX_TEXADDRESS_MIRROR ) ;

    // ２ポリゴン分の頂点のデータをセット
    Vertex[ 0 ].pos  = <b><a href="#R11N1">VGet</a></b>( 100.0f, 400.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = <b><a href="#R14N15">GetColorU8</a></b>( 255,255,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 500.0f, 400.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8( 255,255,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 3.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 100.0f, 100.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,255,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 3.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;

    Vertex[ 3 ].pos  = VGet( 500.0f, 100.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,255,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 3.0f ;
    Vertex[ 3 ].v    = 3.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet( 100.0f, 100.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8( 255,255,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 0.0f ;
    Vertex[ 4 ].v    = 3.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet( 500.0f, 400.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,255,255,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 3.0f ;
    Vertex[ 5 ].v    = 0.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // ２ポリゴンの描画
    <b><a href="#R14N7">DrawPolygon3D</a></b>( Vertex, 2, GrHandle, FALSE ) ;

    // キー入力待ちをする
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N16">宣言</a></b></td><td><font color="#000088"><b>int SetFogEnable( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フォグを有効にするかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Flag ： フォグを使用するかどうかのフラグ<br>
            　　　　　　( TRUE：使用する　FALSE：使用しない( 初期設定 ) )
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　フォグ機能を使用するかどうかを設定します。<br>
                    　フォグ機能とは言葉通り立体空間で霧を表現する手段の一つです。<br>
                    　具体的には、カメラ( 画面 )から一定距離離れた物体に霧が掛かったように任意の色を合成することができます。<br><br>

                    　これを使用することで空気が淀んでいる日に遠くのものを見ようとすると白く霧が掛かったようになってよく見えない、
                    というような空気遠近法も再現することができます。<br>
                    　因みにこの機能はカメラ( 画面 )から一定距離以上離れたものを描画しなくても済むようにする目的で使用することもできます。
                    ( フォグ終了距離以降の部分はフォグ色のみとなるため )<br><br>

                    　デフォルトではフォグの機能はＯＦＦになっていますので、
                    フォグの機能を使用する場合はこの関数でフォグを有効にする必要があります、
                    また、フォグの色やフォグの開始距離・終了距離の設定はそれぞれ <b><a href="#R14N17">SetFogColor</a></b> 関数、<b><a href="#R14N18">SetFogStartEnd</a></b> 関数を使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　フォグ機能を有効にした状態でモデルを画面から徐々に離しながら４体描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, i ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // フォグを有効にする
    SetFogEnable( TRUE ) ;

    // フォグの色を黄色にする
    <b><a href="#R14N17">SetFogColor</a></b>( 255, 255, 0 ) ;

    // フォグの開始距離を０、終了距離を１５００にする
    <b><a href="#R14N18">SetFogStartEnd</a></b>( 0.0f, 1500.0f ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面を黄色で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255, 255, 0 ), TRUE ) ;

    // ３Ｄモデルを徐々に画面から離しながら４体描画する
    for( i = 0 ; i &lt; 4 ; i ++ )
    {
        // モデルの座標をセット
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 700.0f, -300.0f, 200.0f + i * 400.0f ) ) ;
        
        // モデルを描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;
    }

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N17">宣言</a></b></td><td><font color="#000088"><b>int SetFogColor( int Red, int Green, int Blue ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フォグの色を変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Red ： 設定したいフォグの色の赤成分の輝度( ０ 〜 ２５５ )<br> 
            int Green ： 設定したいフォグの色の緑成分の輝度( ０ 〜 ２５５ )<br>
            int Blue ： 設定したいフォグの色の青成分の輝度( ０ 〜 ２５５ )<br>
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　フォグの色を設定します。<br>
                    　暗い色も指定できますので、一定距離以降が暗闇、といった表現も可能です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　フォグ機能を有効にした状態でモデルを画面から徐々に離しながら４体描画します。<br>
            　　フォグの色を黒にしているので徐々に暗闇に消えていくように見えます
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, i ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // フォグを有効にする
    <b><a href="#R14N16">SetFogEnable</a></b>( TRUE ) ;

    // フォグの色を黒色にする
    SetFogColor( 0, 0, 0 ) ;

    // フォグの開始距離を０、終了距離を１５００にする
    <b><a href="#R14N18">SetFogStartEnd</a></b>( 0.0f, 1500.0f ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ３Ｄモデルを徐々に画面から離しながら４体描画する
    for( i = 0 ; i &lt; 4 ; i ++ )
    {
        // モデルの座標をセット
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 700.0f, -300.0f, 200.0f + i * 400.0f ) ) ;
        
        // モデルを描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;
    }

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N18">宣言</a></b></td><td><font color="#000088"><b>int SetFogStartEnd( float start, float end ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フォグが始まる距離と終了する距離を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float start ： フォグの効果が開始する画面からの距離<br>
            float end ： フォグの効果が終了する( フォグ色の濃さが１００％になる )画面からの距離
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　フォグの効果が始まる画面からの距離と、
                    描画物がフォグの色のみになる画面からの距離を設定します。<br><br>

                    　開始距離と終了距離の間に存在する描画物はフォグの色と描画物の色とがブレンドされる形になります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　フォグ機能を有効にした状態でフォグの開始距離を１０００、終了距離を３５００に変更した上で<br>
            　モデルを画面から徐々に離しながら８体描画します。<br>
            　　<b><a href="#R14N16">SetFogEnable</a></b> のサンプルプログラムと違い、フォグの色が掛かり始めるのが３体目からになっています。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, i ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // フォグを有効にする
    <b><a href="#R14N16">SetFogEnable</a></b>( TRUE ) ;

    // フォグの色を黄色にする
    <b><a href="#R14N17">SetFogColor</a></b>( 255, 255, 0 ) ;

    // フォグの開始距離を１０００、終了距離を３５００にする
    <b><a href="#R14N18">SetFogStartEnd</a></b>( 1000.0f, 3500.0f ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面を黄色で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255, 255, 0 ), TRUE ) ;

    // ３Ｄモデルを画面から徐々に離しながら８体描画する
    for( i = 0 ; i &lt; 8 ; i ++ )
    {
        // モデルの座標をセット
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 700.0f, -300.0f, 200.0f + i * 400.0f ) ) ;
        
        // モデルを描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;
    }

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N14">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetColorF( float Red, float Green, float Blue, float Alpha ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>浮動小数点型のカラー値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Red ： 取得したいカラー値の赤成分の輝度( 0.0f 〜 1.0f )<br>
            float Green ： 取得したいカラー値の緑成分の輝度( 0.0f 〜 1.0f )<br>
            float Blue ： 取得したいカラー値の青成分の輝度( 0.0f 〜 1.0f )<br>
            float Alpha ： 取得したいカラー値のアルファ成分( 0.0f 〜 1.0f )<br>
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　COLOR_F 構造体の値を簡単に作成するための関数です。<br><br>
                
                    　例えば <b><a href="#R3N15">MV1SetDifColorScale</a></b> 関数の第二引数は COLOR_F 構造体ですが、
                    この引数をこの関数を使用せずに渡そうとした場合は以下のようにローカル変数として COLOR_F
                    構造体を使用する必要があります。
<pre>
    // GetColorF 関数を使用しない場合
    COLOR_F Color ;

    Color.r = 1.0f ;
    Color.g = 1.0f ;
    Color.b = 0.0f ;
    Color.a = 1.0f ;
    MV1SetDifColorScale( ModelHandle, Color ) ;
</pre>
                    　関数に引数を渡そうとする度にローカル変数を使用するのはプログラムも煩雑になりますし面倒でもあります。<br>
                    　そんなときにこの COLOR_F 構造体を戻り値に返す関数を使用すれば以下のように記述することができます。
<pre>
    // GetColorF 関数を使用する場合
    MV1SetDifColorScale( ModelHandle, GetColorF( 1.0f, 1.0f, 0.0f, 1.0f ) ) ;
</pre>
                    <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　GetColorF 関数を使用している関数 <a href="#R7N27">SetLightDifColor</a> 等のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R14N15">宣言</a></b></td><td><font color="#000088"><b>COLOR_U8 GetColorU8( int Red, int Green, int Blue, int Alpha ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>符号なし整数８ビットのカラー値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Red ： 取得したいカラー値の赤成分の輝度( 0 〜 255 )<br>
            int Green ： 取得したいカラー値の緑成分の輝度( 0 〜 255 )<br>
            int Blue ： 取得したいカラー値の青成分の輝度( 0 〜 255 )<br>
            int Alpha ： 取得したいカラー値のアルファ成分( 0 〜 255 )<br>
            </td>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　COLOR_U8 構造体の値を簡単に作成するための関数です。<br><br>
                
                    　今のところ VERTEX3D 構造体のメンバ変数で COLOR_U8 構造体である dif や spc に値を代入する際にのみ使用します。<br>
                    　例えば VERTEX3D 構造体のメンバ変数 dif にこの関数を使用せずに値を代入しようとした場合以下のような記述になります。
<pre>
    // GetColorU8 関数を使用しない場合
    VERTEX3D Vertex ;

    Vertex.dif.r = 255 ;
    Vertex.dif.g = 255 ;
    Vertex.dif.b = 0 ;
    Vertex.dif.a = 255 ;
</pre>
                    　あまり大きな差ではありませんが、
                    COLOR_U8 構造体を戻り値として返す GetColorU8 関数を使用すると以下のように記述することができます。
<pre>
    // GetColorU8 関数を使用する場合
    VERTEX3D Vertex ;
    
    Vertex.dif = GetColorU8( 255, 255, 0, 255 ) ;
</pre>
                    <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　GetColorU8 関数を使用している関数 <a href="#R14N7">DrawPolygon3D</a> 等のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><font size="3" color="#005500"><b>カメラ関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N1">宣言</a></b></td><td><font color="#000088"><b>int SetCameraNearFar( float Near, float Far ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラの 手前クリップ距離と 奥クリップ距離を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Near ： 手前( Near )クリップ距離( 0.0f より大きく Farより小さな値 )<br>
            float Far ： 奥( Far )クリップ距離( Nearより大きな値 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ空間に何かを描画する際に、カメラからどれだけ離れたところ( Near )から、
                    どこまで( Far )のものを描画するかを設定します。<br><br>

                    　この関数の設定値はかなり重要で、Ｚバッファの精度にも関わってきますので使用する３Ｄ空間の範囲に合わせて適切な値を設定する必要があります。<br>
                    　例えば人間モデル１つの大きさが 200.0f くらいで大体画面奥方向に 10000.0f くらいまで移動して、
                    背景は画面奥方向に 15000.0f くらいまで存在して、かつカメラから 100.0f より近くに来たら見えないようにしたい場合は<br>
<pre>
SetCameraNearFar( 100.0f, 15000.0f ) ;
</pre>
                    　とします。<br><br>

                    　人間モデル一つの大きさがもっと小さく、1.0f くらいで、背景モデルも画面奥方向に 150.0f くらいまで描画できればよい場合は<br> 
<pre>
SetCameraNearFar( 1.0f, 150.0f ) ;
</pre>
                    　とします。<br><br>

                    　因みに、Ｚバッファの仕様の関係で Far の設定値も重要ですが Near の設定値はより重要で、
                    例えば「なるべくカメラに近くても描画したい」という考えから
<pre>
SetCameraNearFar( 0.00001f, 15000.0f ) ;
</pre>
                    　としてしまったりすると大変です、環境によってはカメラから 100.0f 以上離れると描画されなくなったりします。<br>
                    　なので、Near の値は不都合が無い範囲でなるべく大きな値を、Far の値は描画したい最奥のモノのより少し大きな値を設定するようにしてください。<br><br>

                    ＜注意＞なお、この関数の設定は<b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>、<b><a href="dxfunc_graph3.html#R4N1">SetGraphMode</a></b>、<b><a href="dxfunc_other.html#R11N1">ChangeWindowMode</a></b> のいずれかを使用したときにリセットされます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                
            　　モデルファイル SimpleModel.mqo を画面奥方向に座標をずらして８つ描画して、<br>
            　方向キーの上下で Far の値を、左右で Near の値を変更できるサンプルプログラムです。<br>
            　　クリップ値を変更することで描画される範囲が変わるのが分かります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, i ;
    float Near, Far ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // Near Far 値の初期化
    Near = 100.0f ;
    Far = 2000.0f ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 上下のキー入力で Far を操作
        if( CheckHitKey( KEY_INPUT_UP ) == 1 )
        {
            Far += 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
        {
            Far -= 20.0f ;
        }

        // 左右のキーで Near を操作
        if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
        {
            Near -= 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
        {
            Near += 20.0f ;
        }

        // Near の値が 0.0f 以下になっていたら補正
        if( Near <= 0.0f ) Near = 10.0f ;

        // Far の値が Near より小さくなっていたら補正
        if( Far <= Near ) Far = Near + 10.0f ;

        // Near, Far クリップの距離を設定
        SetCameraNearFar( Near, Far ) ; 

        // モデルを距離を変えて８個描画
        for( i = 0 ; i &lt; 8 ; i ++ )
        {
            // モデルの座標を設定
            <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 180.0f, 100.0f + i * 400.0f ) ) ;

            // モデルの描画
            <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;
        }

        // 画面左上に Near の値と Far の値を描画
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Near %f  Far %f", Near, Far ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N2">宣言</a></b></td><td><font color="#000088"><b>int SetCameraPositionAndTarget_UpVecY( VECTOR Position, VECTOR Target ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラの視点、注視点を設定する( 上方向はＹ軸から算出 )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： カメラの位置<br>
            VECTOR Target ： カメラの注視点( 見ている座標 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄソフトと言えば視点がグリグリ変わります、
                    この関数はその視点の位置と見ているものを指定する関数です。<br><br>
                    
                    　カメラの姿勢は、視点、注視点と、あとカメラの上方向があれば決まりますが、
                    この関数はカメラの上方向をＹ軸のプラス方向を基本的なカメラの上方向として姿勢を算出します。<br><br>

                    　因みに、ＤＸライブラリでは初期状態では視点の位置が x = 320.0f, y = 240.0f, z = ( 画面のサイズによって変化 )、
                    注視点の位置は x = 320.0f, y = 240.0f, z = 1.0f、カメラの上方向は x = 0.0f, y = 1.0f, z = 0.0f、
                    つまり画面のＸＹ平面上の中心に居てＺ軸のプラス方向を見るようなカメラになっています。<br><br>

                    　引数 Position と引数 Target は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                
            　　モデルファイル SimpleModel.mqo を原点に描画した状態で、カメラの位置を方向キーで<br>
            　操作できるようにしたサンプルプログラムです。<br>
                 カメラは常に原点を注視点としていますのでモデルは常に画面中心に表示されますが、<br>
            　キー入力によって見える角度が変わります。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    VECTOR CameraPos ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // カメラの座標を初期化
    CameraPos.x = 0.0f ;
    CameraPos.y = 0.0f ;
    CameraPos.z = -800.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 方向キーでカメラの座標を移動
        if( CheckHitKey( KEY_INPUT_UP ) == 1 )
        {
            CameraPos.y += 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
        {
            CameraPos.y -= 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
        {
            CameraPos.x -= 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
        {
            CameraPos.x += 20.0f ;
        }

        // カメラの位置と注視点をセット、注視点は原点
        <b><a href="#R12N2">SetCameraPositionAndTarget_UpVecY</a></b>( CameraPos, <b><a href="#R11N1">VGet</a></b>( 0.0f, 0.0f, 0.0f ) ) ;

        // モデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N3">宣言</a></b></td><td><font color="#000088"><b>int SetCameraPositionAndTargetAndUpVec( VECTOR Position, VECTOR Target, VECTOR Up ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラの視点、注視点、上方向を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： カメラの位置<br>
            VECTOR Target ： カメラの注視点( 見ている座標 )<br>
            VECTOR Up ： カメラの上方向
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄソフトと言えば視点がグリグリ変わります、
                    この関数はその視点の位置と注視点とカメラの上方向を指定する関数です。
                    ( カメラの姿勢は、視点、注視点と、カメラの上方向があれば決まります )<br><br>

                    　因みに、ＤＸライブラリでは初期状態では視点の位置が x = 320.0f, y = 240.0f, z = ( 画面のサイズによって変化 )、注視点の位置は x = 320.0f, y = 240.0f, z = 1.0f、カメラの上方向は x = 0.0f, y = 1.0f, z = 0.0f、
                    つまり画面のＸＹ平面上の中心に居てＺ軸のプラス方向を見るようなカメラになっています。<br><br>

                    　引数 Position と引数 Target は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                
            　　モデルファイル SimpleModel.mqo を原点に配置して、左右キーでそのモデルを見ている<br>
            　カメラの上の方向を回転できるようにしたサンプルプログラムです。<br>
            <hr>
<pre>
#include "DxLib.h"
#include &lt;math.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float Roll ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // カメラの視線の回転値を初期化
    Roll = 0.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 左右キーでカメラの回転値を変更
        if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
        {
            Roll -= DX_PI_F / 60.0f ;
        }
        if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
        {
            Roll += DX_PI_F / 60.0f ;
        }

        // カメラの位置と注視点をセット
        // 視点はＺ軸のマイナス800の位置
        // 注視点は原点
        // 上方向は Roll の値から算出
        SetCameraPositionAndTargetAndUpVec( 
            <b><a href="#R11N1">VGet</a></b>( 0.0f, 0.0f, -800.0f ),
            VGet( 0.0f, 0.0f, 0.0f ),
            VGet( sin( Roll ), cos( Roll ), 0.0f ) ) ;

        // モデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N4">宣言</a></b></td><td><font color="#000088"><b>int SetCameraPositionAndAngle( VECTOR Position, float VRotate, float HRotate, float TRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラの視点、垂直回転角度、水平回転角度、捻り回転角度を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： カメラの位置<br>
            float VRotate ： 垂直回転角度( 単位：ラジアン )<br>
            float HRotate ： 水平回転角度( 単位：ラジアン )<br>
            float TRotate ： 捻り回転角度( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄソフトと言えば視点がグリグリ変わります、
                    この関数は視点の位置と垂直回転角度、水平回転角度、捻り回転角度でカメラの位置を向きを設定する関数です。<br><br>
                        
                    　例えばカメラが見ている方向を上下( 垂直 )方向に変えたい場合は VRotate の値を変化させて、
                    左右( 水平 )方向に変えたい場合は HRotate の値を変化させて、
                    見ている方向に捻りを加えたい場合は TRotate の値を変化させて、といった感じです。<br><br>

                    　引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に座標値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                カメラの向きを上下左右キーで変えられるようにしたサンプルです。<br>
            　　回転していることを確認できるようにモデルファイル SimpleModel.mqo をカメラを囲むように<br>
            　４個描画しています。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float VRotate, HRotate, TRotate ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // カメラの回転値を初期化
    VRotate = 0.0f ;
    HRotate = 0.0f ;
    TRotate = 0.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 左シフトキーを押しているかどうかで処理を分岐
        if( CheckHitKey( KEY_INPUT_LSHIFT ) == 1 )
        {
            // 左右キーでカメラの捻り方向回転値を変更
            if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
            {
                TRotate -= DX_PI_F / 60.0f ;
            }
            if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
            {
                TRotate += DX_PI_F / 60.0f ;
            }
        }
        else
        {
            // 左右キーでカメラの水平方向回転値を変更
            if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
            {
                HRotate -= DX_PI_F / 60.0f ;
            }
            if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
            {
                HRotate += DX_PI_F / 60.0f ;
            }
        }

        // 上下キーでカメラの垂直方向回転値を変更
        if( CheckHitKey( KEY_INPUT_UP ) == 1 )
        {
            VRotate += DX_PI_F / 60.0f ;
        }
        if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
        {
            VRotate -= DX_PI_F / 60.0f ;
        }

        // カメラの位置と回転値をセット、カメラの位置は原点
        SetCameraPositionAndAngle( <b><a href="#R11N1">VGet</a></b>( 0.0f, 0.0f, 0.0f ), VRotate, HRotate, TRotate ) ;

        // モデルをカメラを囲むように４個描画
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 0.0f, 0.0f, 800.0f ) ) ;
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, -800.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet( 800.0f, 0.0f, 0.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet( -800.0f, 0.0f, 0.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N5">宣言</a></b></td><td><font color="#000088"><b>int SetCameraViewMatrix( MATRIX ViewMatrix ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ビュー行列を直接設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX ViewMatrix ： ビュー行列
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R12N2">SetCameraPositionAndTarget_UpVecY</a></b> などの関数を使用せずに直接ビュー行列を設定したいときに使用する関数です。<br><br>
                    
                    　SetCameraPositionAndTarget_UpVecY などの関数を使用する場合は使用しません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                カメラの向きを左右キーで変えられるようにしたサンプルです。<br>
            　　回転していることを確認できるようにモデルファイル SimpleModel.mqo をカメラを囲むように<br>
            　４個描画しています。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float Rotate ;
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // カメラの回転値を初期化
    Rotate = 0.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 左右キーでカメラの回転値を変更
        if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
        {
            Rotate -= DX_PI_F / 60.0f ;
        }
        if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
        {
            Rotate += DX_PI_F / 60.0f ;
        }

        // 回転値を使用してＹ軸の回転行列を作成
        Matrix = <b><a href="#R11N18">MGetRotY</a></b>( Rotate ) ;

        // 回転行列をビュー行列としてセット
        SetCameraViewMatrix( Matrix ) ;

        // モデルをカメラを囲むように４個描画
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 0.0f, 0.0f, 800.0f ) ) ;
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet( 0.0f, 0.0f, -800.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet( 800.0f, 0.0f, 0.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet( -800.0f, 0.0f, 0.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N6">宣言</a></b></td><td><font color="#000088"><b>int SetupCamera_Perspective( float Fov ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>遠近法カメラをセットアップする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Fov ： 視野角( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　カメラを遠近法を使用したものにします。<br>
                    　遠近法を使用したカメラはカメラから遠い物ほど小さく見えるので、
                    現実での立体空間の見え方に一番近い表示法です。( ＤＸライブラリの初期設定は遠近法です )<br><br>
                        
                    　引数の Fov は視野角で値が大きければ大きいほど視野が広くなります、初期設定では 60度( ラジアンでは約 1.0472 )です。<br><br>

                    　尚、この関数と <b><a href="#R12N7">SetupCamera_Ortho</a></b> や <b><a href="#R12N8">SetupCamera_ProjectionMatrix</a></b> はそれぞれ排他関係にありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                カメラの視野角を左右キーで変えられるようにしたサンプルです。<br>
            　　視野角が変化していることを確認できるようにモデルファイル SimpleModel.mqo をカメラの前方に<br>
            　３個描画しています。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float Fov ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 視野角を初期化
    Fov = 60.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 左右キーで視野角の値を変更
        if( CheckHitKey( KEY_INPUT_LEFT ) == 1 )
        {
            Fov -= 2.0f ;
        }
        if( CheckHitKey( KEY_INPUT_RIGHT ) == 1 )
        {
            Fov += 2.0f ;
        }

        // 視野角が 8.0f 以下になったら補正
        if( Fov < 8.0f ) Fov = 8.0f ;

        // 視野角が 170.0f 以上になったら補正
        if( Fov > 170.0f ) Fov = 170.0f ;

        // 遠近法のセットアップ( ラジアン値に変換しています )
        <b><a href="#R12N6">SetupCamera_Perspective</a></b>( Fov * DX_PI_F / 180.0f ) ;

        // カメラの前方にモデルを３個描画
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( -1400.0f + 320.0f, 240.0f, 0.0f ) ) ;
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet(     0.0f + 320.0f, 240.0f, 0.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        MV1SetPosition( ModelHandle, VGet(  1400.0f + 320.0f, 240.0f, 0.0f ) ) ;
        MV1DrawModel( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N7">宣言</a></b></td><td><font color="#000088"><b>int SetupCamera_Ortho( float Size ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>正射影カメラをセットアップする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Size ： 画面垂直方向の表示範囲
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　カメラを正射影法を使用したものにします。<br>
                    　正射影を使用したカメラはカメラから遠い物ものでも近いものでも同じ大きさに見えます、
                    現実での立体空間の見え方は遠くの物ほど小さく見えるので、
                    少し不思議な見え方になります。<br><br>
                        
                    　引数の Size は画面の下端から上端の間に表示される空間の範囲です、
                    値が大きければ大きいほど沢山の範囲が画面内に映ります。<br><br>

                    　尚、この関数と <b><a href="#R12N6">SetupCamera_Perspective</a></b> や <b><a href="#R12N8">SetupCamera_ProjectionMatrix</a></b> はそれぞれ排他関係にありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                表示方式を正射影に変えてからカメラの前方に奥行き値の違うモデルを３つ描画します。<br>
            　　正射影なので奥行き的に何処に位置していても同じ大きさで描画されます。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // カメラを正射影に変更
    <b><a href="#R12N7">SetupCamera_Ortho</a></b>( 2000.0f ) ;

    // カメラの前方に奥行き座標の違うモデルを３個描画
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( -700.0f + 320.0f, 240.0f, 0.0f ) ) ;
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    MV1SetPosition( ModelHandle, VGet(    0.0f + 320.0f, 240.0f, 500.0f ) ) ;
    MV1DrawModel( ModelHandle ) ;

    MV1SetPosition( ModelHandle, VGet(  700.0f + 320.0f, 240.0f, 1000.0f ) ) ;
    MV1DrawModel( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N8">宣言</a></b></td><td><font color="#000088"><b>int SetupCamera_ProjectionMatrix( MATRIX ProjectionMatrix ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>射影行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX ProjectionMatrix ： 射影行列
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　射影行列を直接設定する場合に使用します。<br>
                    　<b><a href="#R12N6">SetupCamera_Perspective</a></b> や <b><a href="#R12N7">SetupCamera_Ortho</a></b> を使用する場合は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N9">宣言</a></b></td><td><font color="#000088"><b>int SetCameraDotAspect( float DotAspect ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラのドットアスペクトを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float DotAspect ： ドットアスペクト比( 横 / 縦 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ描画を使用した際に画面に描画される映像の縦横比を設定します。<br>
                    　値は 横 / 縦 で指定して、値が 1.0f 以上なら見え方が横長に、
                    0.0f 以上 1.0f 以下なら縦長になります。<br><br>

                    　特殊な演出をしたい場合以外は恐らく使用しない関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                ドットアスペクト比の設定を縦２倍にしてからモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ドット比を縦に２倍に変更
    SetCameraDotAspect( 0.5f ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 0.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N10">宣言</a></b></td><td><font color="#000088"><b>VECTOR ConvWorldPosToScreenPos( VECTOR WorldPos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ワールド座標をスクリーン座標に変換する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR WorldPos ： ワールド( ３Ｄ )座標
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スクリーン座標<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　引数 WorldPos で渡すワールド( ３Ｄ )座標をスクリーン座標に変換します。<br>
                　３Ｄ空間上に存在する物が画面上のどの座標に位置するのかを取得したい場合に使用します。<br><br>

                　尚、指定のワールド座標とカメラの視線方向との距離が SetCameraNearFar で設定した範囲から外れていた場合は戻り値のＺが 0.0f以下又は1.0f以上になり、その際のＸ、Ｙはスクリーン座標とは無関係の値となります。( なので戻り値のＺが 0.0f 以下若しくは 1.0f 以上の場合はＸ，Ｙの値は無効だと判断してください )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                DxChara.x の０番目のモーションを再生しながら、フレーム番号２６の座標に２Ｄの四角形を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex ;
    float TotalTime, PlayTime ;
    VECTOR ScreenPos ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アタッチしたアニメーションの総再生時間を取得する
    TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

    // 再生時間の初期化
    PlayTime = 0.0f ;

    // 何かキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 再生時間を進める
        PlayTime += 100.0f ;

        // 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
        if( PlayTime >= TotalTime )
        {
            PlayTime = 0.0f ;
        }

        // 再生時間をセットする
        <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // ナンバー２６のフレームの画面上での座標を取得する
        ScreenPos = ConvWorldPosToScreenPos( <b><a href="#R6N8">MV1GetFramePosition</a></b>( ModelHandle, 26 ) ) ;

        // 取得したスクリーン座標に四角形を描画
        <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( ScreenPos.x - 2, ScreenPos.y - 2, ScreenPos.x + 2, ScreenPos.y + 2, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), TRUE ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N11">宣言</a></b></td><td><font color="#000088"><b>VECTOR ConvScreenPosToWorldPos( VECTOR ScreenPos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>スクリーン座標をワールド座標に変換する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR ScreenPos ： スクリーン座標
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ワールド座標<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　引数 ScreenPos で渡すスクリーン座標をワールド座標に変換します。<br>
                　マウスでクリックした座標に存在する３Ｄ空間上のオブジェクトを検出したりする処理に使用します。<br><br>

                　尚、スクリーン座標には奥行きの情報がありませんので、画面上からどれだけ奥まった３Ｄ空間上の座標を取得するのかのを ScreenPos のメンバ変数 z で指定します。
                ただ、この z はワールド空間上での距離ではなく、指定できる値の範囲は 0.0f から 1.0f です。<br>
                　z が 0.0f の場合は <b><a href="#R12N1">SetCameraNearFar</a></b> 関数で設定した Near と同じだけカメラ座標から離れた位置、1.0f の場合は Far と同じだけカメラ座標から離れた位置のワールド座標が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　画面上に表示されているモデルファイル SimpleModel.mqo のポリゴンとマウスポインタの位置から<br>
            　画面奥へ伸びる線分とで当たり判定を行い、線分に接触したポリゴンを黄色で描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    VECTOR StartPos, EndPos ;
    MV1_COLL_RESULT_POLY HitPoly ;
    int Mx, My ;

    // ウインドウモードで起動する
    <b><a href="dxfunc_other.html#R11N1">ChangeWindowMode</a></b>( TRUE ) ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ３Ｄモデルを見える位置に移動する
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // モデル全体のコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, -1, 8, 8, 8 ) ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // マウスの座標を取得
        <b><a href="dxfunc_input.html#R5N6">GetMousePoint</a></b>( &amp;Mx, &amp;My ) ;

        // マウスポインタがある画面上の座標に該当する３Ｄ空間上の Near 面の座標を取得
        StartPos = ConvScreenPosToWorldPos( <b><a href="#R11N1">VGet</a></b>( Mx, My, 0.0f ) ) ;

        // マウスポインタがある画面上の座標に該当する３Ｄ空間上の Far 面の座標を取得
        EndPos = ConvScreenPosToWorldPos( VGet( Mx, My, 1.0f ) ) ;

        // モデルと線分との当たり判定
        HitPoly = <b><a href="#R9N4">MV1CollCheck_Line</a></b>( ModelHandle, -1, StartPos, EndPos ) ;

        // 当たったかどうかで処理を分岐
        if( HitPoly.HitFlag == 1 )
        {
            // 当たった場合は衝突の情報を描画する

            // 当たったポリゴンを黄色で描画する
            <b><a href="#R14N2">DrawTriangle3D</a></b>( HitPoly.Position[ 0 ], HitPoly.Position[ 1 ], HitPoly.Position[ 2 ], GetColor( 255,255,0 ), TRUE ) ;

            // 交差した座標を描画
            <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ),  "Hit Pos   %f  %f  %f",
                HitPoly.HitPosition.x, HitPoly.HitPosition.y, HitPoly.HitPosition.z ) ;

            // 当たったポリゴンが含まれるフレームの番号を描画
            DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Frame     %d", HitPoly.FrameIndex ) ;

            // 当たったポリゴンが使用しているマテリアルの番号を描画
            DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Material  %d", HitPoly.MaterialIndex ) ;

            // 当たったポリゴンを形成する三頂点の座標を描画
            DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Position  %f  %f  %f",
                HitPoly.Position[ 0 ].x, HitPoly.Position[ 0 ].y, HitPoly.Position[ 0 ].z ) ;
            DrawFormatString( 0, 64, GetColor( 255,255,255 ), "          %f  %f  %f",
                HitPoly.Position[ 1 ].x, HitPoly.Position[ 1 ].y, HitPoly.Position[ 1 ].z ) ;
            DrawFormatString( 0, 80, GetColor( 255,255,255 ), "          %f  %f  %f",
                HitPoly.Position[ 2 ].x, HitPoly.Position[ 2 ].y, HitPoly.Position[ 2 ].z ) ;

            // 当たったポリゴンの法線を描画
            DrawFormatString( 0, 96, GetColor( 255,255,255 ), "Normal    %f  %f  %f",
                HitPoly.Normal.x, HitPoly.Normal.y, HitPoly.Normal.z ) ;
        }
        else
        {
            // 当たらなかった場合は衝突しなかった旨だけ描画する
            <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "NO HIT", GetColor( 255,255,255 ) ) ;
        }

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N12">宣言</a></b></td><td><font color="#000088"><b>int SetCameraScreenCenter( float x, float y ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>画面上でのカメラが見ている映像の中心座標を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float x ： ３Ｄ空間の消失点となるスクリーンＸ座標<br>
            float y ： ３Ｄ空間の消失点となるスクリーンＹ座標<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　画面上でのカメラが見ている映像の中心座標( 消失点 )を引数で渡されるスクリーン座標にする関数です。<br>
                　主な用途は１プレイヤー用と２プレイヤー用で画面を上下に分けたいときや、画面の一部を３Ｄ表現したい場合などです。
                ( 消失点は初期状態では常に画面の中心なので、消失点を変更しないまま画面を上下や左右に分けようとすると大変です )<br><br>

                　尚、この関数の設定は <b><a href="dxfunc_graph3.html#R4N3">SetDrawArea</a></b>、<b><a href="dxfunc_other.html#R11N1">ChangeWindowMode</a></b>、<b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b> の何れかを使用するとリセットされますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                カメラの消失点を画面右側に変更してから立方体を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

#define X1    100.0f
#define X2    540.0f
#define Y1    100.0f
#define Y2    380.0f
#define Z1    0.0f
#define Z2    1000.0f

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int Color ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // カメラの注視点の画面上の位置を右寄りにする
    SetCameraScreenCenter( 480.0f, 240.0f ) ;

    // 直方体を描画する
    Color = <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ;
    <b><a href="#R14N1">DrawLine3D</a></b>( <b><a href="#R11N1">VGet</a></b>( X1, Y1, Z1 ), VGet( X2, Y1, Z1 ), Color ) ;
    DrawLine3D( VGet( X2, Y1, Z1 ), VGet( X2, Y2, Z1 ), Color ) ;
    DrawLine3D( VGet( X2, Y2, Z1 ), VGet( X1, Y2, Z1 ), Color ) ;
    DrawLine3D( VGet( X1, Y2, Z1 ), VGet( X1, Y1, Z1 ), Color ) ;
    DrawLine3D( VGet( X1, Y1, Z2 ), VGet( X2, Y1, Z2 ), Color ) ;
    DrawLine3D( VGet( X2, Y1, Z2 ), VGet( X2, Y2, Z2 ), Color ) ;
    DrawLine3D( VGet( X2, Y2, Z2 ), VGet( X1, Y2, Z2 ), Color ) ;
    DrawLine3D( VGet( X1, Y2, Z2 ), VGet( X1, Y1, Z2 ), Color ) ;
    DrawLine3D( VGet( X1, Y1, Z1 ), VGet( X1, Y1, Z2 ), Color ) ;
    DrawLine3D( VGet( X2, Y1, Z1 ), VGet( X2, Y1, Z2 ), Color ) ;
    DrawLine3D( VGet( X2, Y2, Z1 ), VGet( X2, Y2, Z2 ), Color ) ;
    DrawLine3D( VGet( X1, Y2, Z1 ), VGet( X1, Y2, Z2 ), Color ) ;

    // 裏画面の内容を表画面に反映
    <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N13">宣言</a></b></td><td><font color="#000088"><b>int CheckCameraViewClip( VECTOR CheckPos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定の座標がカメラの視界に入っていないかどうかを判定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR CheckPos ： 視界に入っていないかどうかをチェックするワールド座標
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　TRUE：視界に入っていない</td></tr>
            <tr><td width="100">　</td><td>FALSE：視界に入っている<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　指定のワールド座標が視界に入っていないかどうかをチェックする関数です。<br>
                　３Ｄの描画処理は処理負荷が高いので、この関数で視界に入っていない( 画面内に映っていない )場合は描画処理を行わない、などの処理をする際に使用します。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                ３Ｄ空間内を左右に飛び回る点がカメラに入っているかどうかを画面左上に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Position ;
    float XAdd ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 飛び回る点の座標を初期化
    Position = VGet( 320, 240, 0.0f ) ;

    // 飛び回る点のＸ軸の移動速度をセット
    XAdd = 8.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 点の座標を更新
        Position.x += XAdd ;

        // もし画面内から大きく外れたら方向を反転する
        if( Position.x &lt; -100.0f || Position.x &gt; 740.0f )
        {
            XAdd = -XAdd ;
        }

        // 画面内に座標が入っていないかどうかを描画する
        if( CheckCameraViewClip( Position ) == TRUE )
        {
            DrawString( 0, 0, "Screen Out:Yes", GetColor( 255,255,255 ) ) ;
        }
        else
        {
            DrawString( 0, 0, "Screen Out:No", GetColor( 255,255,255 ) ) ;
        }

        // 点を描画する
        DrawPixel3D( Position, GetColor( 255,255,255 ) ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N14">宣言</a></b></td><td><font color="#000088"><b>int CheckCameraViewClip_Box( VECTOR BoxPos1, VECTOR BoxPos2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの座標で表されるボックスがカメラの視界に入っていないかどうかを判定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR BoxPos1 ： ボックスを表すワールド座標１<br>
            VECTOR BoxPos2 ： ボックスを表すワールド座標２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　TRUE：視界に入っていない</td></tr>
            <tr><td width="100">　</td><td>FALSE：視界に入っている<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　二つの座標で表されるボックスが視界に入っていないかどうかをチェックする関数です。<br>
                　３Ｄの描画処理は処理負荷が高いので、この関数で視界に入っていない( 画面内に映っていない )場合は描画処理を行わない、などの処理をする際に使用します。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                ３Ｄ空間内を左右に飛び回るボックスがカメラに入っているかどうかを画面左上に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Position ;
    VECTOR BoxPos1, BoxPos2 ;
    float XAdd ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // Ｚバッファを使用する
    SetUseZBuffer3D( TRUE ) ;

    // Ｚバッファへの書き込みを行う
    SetWriteZBuffer3D( TRUE ) ; 

    // 飛び回るボックスの座標を初期化
    Position = VGet( 320, 240, 0.0f ) ;

    // 飛び回るボックスのＸ軸の移動速度をセット
    XAdd = 8.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // ボックスの座標を更新
        Position.x += XAdd ;

        // もし画面内から大きく外れたら方向を反転する
        if( Position.x &lt; -200.0f || Position.x &gt; 840.0f )
        {
            XAdd = -XAdd ;
        }

        // ボックスを現す２点の座標を準備
        BoxPos1 = VSub( Position, VGet( 10.0f, 10.0f, 10.0f ) ) ;
        BoxPos2 = VAdd( Position, VGet( 10.0f, 10.0f, 10.0f ) ) ;

        // 画面内にボックスが入っていないかどうかを描画する
        if( CheckCameraViewClip_Box( BoxPos1, BoxPos2 ) == TRUE )
        {
            DrawString( 0, 0, "Screen Out:Yes", GetColor( 255,255,255 ) ) ;
        }
        else
        {
            DrawString( 0, 0, "Screen Out:No", GetColor( 255,255,255 ) ) ;
        }

        // ボックスを描画する
        DrawCube3D( BoxPos1, BoxPos2, GetColor( 255,255,255 ), GetColor( 0,0,0 ), TRUE ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N15">宣言</a></b></td><td><font color="#000088"><b>MATRIX GetCameraViewMatrix( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラのビュー行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　ビュー行列</td></tr>
            <tr><td width="100">　</td><td>　<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　カメラの設定で作られるビュー行列を取得します。<br><br>

                　３Ｄ描画の計算では座標はまず３Ｄ世界のどこに居るのかを示す「ワールド座標」からカメラからの相対位置である「ビュー座標」に変換して、
                そこから座標のスケールが一定で画面の奥行き表現も考慮した「射影座標」に変換され、
                さらに具体的にスクリーン上の左から何ピクセル、上から何ピクセルかを示した「スクリーン座標」に変換されてからやっと描画されます。<br><br>
                
                　この各座標間の変換には主に行列が使用されます。<br>
                　この関数はカメラが担当する「ワールド座標」から「ビュー座標」に変換するための行列「ビュー行列」を取得するための関数です。<br>
                　頂点シェーダーを使用して自前で「ワールド座標」から「射影座標」まで変換する際に必要になるので、そのときに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R12N16">宣言</a></b></td><td><font color="#000088"><b>MATRIX GetCameraProjectionMatrix( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カメラの射影行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　射影行列</td></tr>
            <tr><td width="100">　</td><td>　<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　カメラの設定で作られる射影行列を取得します。<br><br>

                　３Ｄ描画の計算では座標はまず３Ｄ世界のどこに居るのかを示す「ワールド座標」からカメラからの相対位置である「ビュー座標」に変換して、
                そこから座標のスケールが一定で画面の奥行き表現も考慮した「射影座標」に変換され、
                さらに具体的にスクリーン上の左から何ピクセル、上から何ピクセルかを示した「スクリーン座標」に変換されてからやっと描画されます。<br><br>
                
                　この各座標間の変換には主に行列が使用されます。<br>
                　この関数はカメラが担当する「ワールド座標」から「ビュー座標」に変換した次の変換で得られる「射影座標」にするための行列「射影行列」を取得するための関数です。<br>
                　頂点シェーダーを使用して自前で「ワールド座標」から「射影座標」まで変換する際に必要になるので、その際に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                ありません<br><br>
            <br><br><br><br><br><br>
        </td></tr>



        <tr><td><font size="3" color="#005500"><b>ライト関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N44">宣言</a></b></td><td><font color="#000088"><b>int SetUseLighting( int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライティング計算処理を使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Flag ： ライティング計算処理を使用するかどうか( TRUE：使用する　FALSE：使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄ描画をする際にライティング計算を行うかどうかを設定します。( 初期状態では計算します )<br>
                    　計算処理をしない設定にした場合はモデルは頂点カラーとテクスチャカラーを掛け合わせるだけの色計算を行うようになり、
                    あらゆるライトの設定もマテリアルの設定も無視されます。<br><br>

                    　計算負荷は軽くなりますので、
                    背景等事前にライトの計算を行って頂点カラーに落とし込んだモデルなどを描画する際などにライティング計算をＯＦＦにします。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                DxChara.x をライティング計算をＯＦＦにして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ライティングの計算をしないように設定を変更
    SetUseLighting( FALSE ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N45">宣言</a></b></td><td><font color="#000088"><b>int SetGlobalAmbientLight( COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>グローバルアンビエントライトカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            COLOR_F Color ： グローバルアンビエントライトカラー( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　すべてのモデルに適用されるアンビエントカラー( 環境光色 )を設定します。<br>
                    　各ライトの設定にもアンビエントカラーはありますが、
                    この値はその値に加算されます。( 初期値は真っ黒( Color のメンバ変数 r g b がすべて 0.0f )です )<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>

                    　値を大きくすればするほど、マテリアルに設定されたアンビエントカラーの影響が大きくなります。<br>
                    　逆に、この値を何にしてもマテリアルのアンビエントカラーが真っ黒だとなにも見た目は変わりません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
                グローバルアンビエントカラーを赤にしてモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // グローバルアンビエントカラーを赤色に変更
    SetGlobalAmbientLight( <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 0.0f ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 0.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><font size="3" color="#005500"><b>標準ライト関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N1">宣言</a></b></td><td><font color="#000088"><b>int ChangeLightTypeDir( VECTOR Direction ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのタイプをディレクショナルライトにする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Direction ： ライトの方向
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのタイプを引数 Direction で示される方向の光を放つディレクショナルライトにします。( Direction は正規化されている必要はありません )<br><br>

                    　ディレクショナルライトとは位置を持たず方向だけを設定するライトで、
                    太陽の光などの光源が遠すぎて何処に居ても同じ方向から照らされるライト効果などに使用します。<br>
                    　因みにＤＸライブラリの初期設定では標準ライトはディレクショナルライトとなっています。<br><br>

                    　計算負荷も最も軽いので、一番よく使うライトタイプです。<br><br>

                    　尚、引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の向き指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            
            　　標準ライトの方向をＸ軸のマイナス方向にしてモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // Ｘ軸のマイナス方向のディレクショナルライトに変更
    <b><a href="#R13N1">ChangeLightTypeDir</a></b>( <b><a href="#R11N1">VGet</a></b>( -1.0f, 0.0f, 0.0f  ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 0.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N2">宣言</a></b></td><td><font color="#000088"><b>int ChangeLightTypePoint( VECTOR Position, float Range, float Atten0, float Atten1, float Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのタイプをポイントライトにする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： ライトの位置<br>
            float Range ： ライトの有効距離<br>
            float Atten0 ： 距離減衰パラメータ０<br>
            float Atten1 ： 距離減衰パラメータ１<br>
            float Atten2 ： 距離減衰パラメータ２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのタイプを位置と距離減衰パラメータを持つポイントライトにします。<br>
                    　ディレクショナルライトの次に使用頻度の高い、
                    指定した位置から全方向に光を放つライトです。<br><br>

                    　引数の説明をします。<br><br>

                    VECTER Position<br>
                    　ポイントライトの位置です。<br><br>

                    float Range<br>
                    　ポイントライトの影響最大距離です。<br>
                    　この引数で指定する距離以上の座標にある頂点は、
                    例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。<br><br>

                    float Atten0<br>
                    float Atten1<br>
                    float Atten2<br>
                    　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。<br>
                    　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。<br>
                    　その計算式は以下のようなものです。<br>
<pre>
d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )
</pre>
                    　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、
                    Atten1 はライトの距離に比例して減衰する率、
                    Atten2 はライトの距離の二乗に比例して減衰する率となります。<br>
                    　率を除算する値ですので、
                    非常に小さな値でも物凄くライトの影響範囲が狭まります。
                    なので引数に渡す値はこの式を理解してから決定してください。<br><br>

                    　尚、引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトをポイントライトにして、Ｄ〜Ｈ、Ｃ〜Ｎまでのキーを使用して<br>
            　各パラメータを変更できるようにしたサンプルです。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float Range, Atten0, Atten1, Atten2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 各パラメータを初期化
    Range = 2000.0f ;
    Atten0 = 0.0f ;
    Atten1 = 0.0006f ;
    Atten2 = 0.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ＤＣキーでライトの影響範囲を変更
        if( CheckHitKey( KEY_INPUT_D ) == 1 )
        {
            Range += 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_C ) == 1 )
        {
            Range -= 20.0f ;
        }

        // ＦＶキーでライトの距離減衰パラメータ０の値を変更
        if( CheckHitKey( KEY_INPUT_F ) == 1 )
        {
            Atten0 += 0.001f ;
        }
        if( CheckHitKey( KEY_INPUT_V ) == 1 )
        {
            Atten0 -= 0.001f ;
        }

        // ＧＢキーでライトの距離減衰パラメータ１の値を変更
        if( CheckHitKey( KEY_INPUT_G ) == 1 )
        {
            Atten1 += 0.00001f ;
        }
        if( CheckHitKey( KEY_INPUT_B ) == 1 )
        {
            Atten1 -= 0.00001f ;
        }

        // ＨＮキーでライトの距離減衰パラメータ２の値を変更
        if( CheckHitKey( KEY_INPUT_H ) == 1 )
        {
            Atten2 += 0.0000001f ;
        }
        if( CheckHitKey( KEY_INPUT_N ) == 1 )
        {
            Atten2 -= 0.0000001f ;
        }

        // 影響距離の値を補正
        if( Range < 0.0f ) Range = 0.0f ;

        // 距離減衰パラメータの値を補正
        if( Atten0 < 0.0f ) Atten0 = 0.0f ;
        if( Atten1 < 0.0f ) Atten1 = 0.0f ;
        if( Atten2 < 0.0f ) Atten2 = 0.0f ;

        // モデルの上空にポイントライトを設定
        <b><a href="#R13N2">ChangeLightTypePoint</a></b>(
            <b><a href="#R11N1">VGet</a></b>( 320.0f, 1000.0f, 200.0f ),
            Range,
            Atten0,
            Atten1,
            Atten2 ) ;

        // モデルをカメラの映る位置に移動
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 200.0f ) ) ;

        // モデルを描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // パラメータの内容を画面に表示
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),  "Key:D.C  Range  %f", Range ) ;
        DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Key:F.V  Atten0 %f", Atten0 ) ;
        DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Key:G.B  Atten1 %f", Atten1 ) ;
        DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Key:H.N  Atten2 %f / 100.0f", Atten2 * 100.0f ) ;

        // 裏画面の内容を表画面に反映する
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N3">宣言</a></b></td><td><font color="#000088"><b>int ChangeLightTypeSpot( VECTOR Position, VECTOR Direction, float OutAngle, float InAngle, float Range, float Atten0, float Atten1, float Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのタイプをスポットライトにする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： ライトの位置<br>
            VECTOR Direction ： ライトの向き<br>
            float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )<br>
            float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )<br>
            float Range ： ライトの有効距離<br>
            float Atten0 ： 距離減衰パラメータ０<br>
            float Atten1 ： 距離減衰パラメータ１<br>
            float Atten2 ： 距離減衰パラメータ２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのタイプを位置、方向、角度範囲、距離減衰パラメータを持つスポットライトにします。<br>
                    　一番計算負荷が高く、
                    また頂点単位のライティングではポリゴンを細かく分割しておかないと思ったような結果が出ないなど扱いが難しいタイプのライトです。<br><br>

                    　引数の説明をします。<br><br>

                    VECTER Position<br>
                    　スポットライトの位置です。<br><br>

                    VECTOR Direction<br>
                    　スポットライトの向きです<br><br>

                    float OutAngle<br>
                    　スポットライトの影響角度です。<br>
                    　スポットライトの向きに対してこの引数で指定する角度以上の頂点にはライトの影響はありません。<br>
                    　有効な値は 0.0f 〜 DX_PI_F までです。<br><br>

                    float InAngle<br>
                    　スポットライトの影響が減衰を始める角度です。<br>
                    　スポットライトが OutAngle の角度まで１００％の影響を与えて、
                    そこから急に影響が無い状態になりますと不自然に見えるかもしれません。<br>
                    　そんなときはこの引数でスポットライトの影響が弱まり始める角度を指定します。<br>
                    　スポットライトの向きに対してこの引数で指定する角度以上で且つ OutAngle 以下の場合はライトの影響が１００％ではなくなります。<br>
                    　有効な値は 0.0f 〜 OutAngle までです。<br><br>

                    float Range<br>
                    　スポットライトの影響最大距離です。<br>
                    　この引数で指定する距離以上の座標にある頂点は、
                    例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。<br><br>

                    float Atten0<br>
                    float Atten1<br>
                    float Atten2<br>
                    　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。<br>
                    　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。<br>
                    　その計算式は以下のようなものです。<br>
<pre>
d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )
</pre>
                    　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、
                    Atten1 はライトの距離に比例して減衰する率、
                    Atten2 はライトの距離の二乗に比例して減衰する率となります。<br>
                    　率を除算する値ですので、
                    非常に小さな値でも物凄くライトの影響範囲が狭まります。
                    なので引数に渡す値はこの式を理解してから決定してください。<br><br>

                    　尚、引数 Position と Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の座標や向きを指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトをスポットライトにして、Ａ〜Ｈ、Ｚ〜Ｎまでのキーを使用して<br>
            　各パラメータを変更できるようにしたサンプルです。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float OutAngle, InAngle, Range, Atten0, Atten1, Atten2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面にする
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 各パラメータを初期化
    OutAngle = 90.0f ;
    InAngle = 45.0f ;
    Range = 2000.0f ;
    Atten0 = 0.0f ;
    Atten1 = 0.0006f ;
    Atten2 = 0.0f ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ＡＺキーで OutAngle の値を変更
        if( CheckHitKey( KEY_INPUT_A ) == 1 )
        {
            OutAngle += 1.0f ;
        }
        if( CheckHitKey( KEY_INPUT_Z ) == 1 )
        {
            OutAngle -= 1.0f ;
        }

        // ＳＸキーで InAngle の値を変更
        if( CheckHitKey( KEY_INPUT_S ) == 1 )
        {
            InAngle += 1.0f ;
        }
        if( CheckHitKey( KEY_INPUT_X ) == 1 )
        {
            InAngle -= 1.0f ;
        }

        // ＤＣキーでライトの影響範囲を変更
        if( CheckHitKey( KEY_INPUT_D ) == 1 )
        {
            Range += 20.0f ;
        }
        if( CheckHitKey( KEY_INPUT_C ) == 1 )
        {
            Range -= 20.0f ;
        }

        // ＦＶキーでライトの距離減衰パラメータ０の値を変更
        if( CheckHitKey( KEY_INPUT_F ) == 1 )
        {
            Atten0 += 0.001f ;
        }
        if( CheckHitKey( KEY_INPUT_V ) == 1 )
        {
            Atten0 -= 0.001f ;
        }

        // ＧＢキーでライトの距離減衰パラメータ１の値を変更
        if( CheckHitKey( KEY_INPUT_G ) == 1 )
        {
            Atten1 += 0.00001f ;
        }
        if( CheckHitKey( KEY_INPUT_B ) == 1 )
        {
            Atten1 -= 0.00001f ;
        }

        // ＨＮキーでライトの距離減衰パラメータ２の値を変更
        if( CheckHitKey( KEY_INPUT_H ) == 1 )
        {
            Atten2 += 0.0000001f ;
        }
        if( CheckHitKey( KEY_INPUT_N ) == 1 )
        {
            Atten2 -= 0.0000001f ;
        }

        // 角度の値を補正
        if( OutAngle < 0.0f ) OutAngle = 0.0f ;
        if( OutAngle > 180.0f ) OutAngle = 180.0f ;
        if( InAngle < 0.0f ) InAngle = 0.0f ;
        if( InAngle > OutAngle ) InAngle = OutAngle ;

        // 影響距離の値を補正
        if( Range < 0.0f ) Range = 0.0f ;

        // 距離減衰パラメータの値を補正
        if( Atten0 < 0.0f ) Atten0 = 0.0f ;
        if( Atten1 < 0.0f ) Atten1 = 0.0f ;
        if( Atten2 < 0.0f ) Atten2 = 0.0f ;

        // Ｙ軸のマイナス方向のスポットライトを設定
        <b><a href="#R13N3">ChangeLightTypeSpot</a></b>(
            <b><a href="#R11N1">VGet</a></b>( 320.0f, 1000.0f, 200.0f ),
            VGet( 0.0f, -1.0f, 0.0f  ),
            OutAngle * DX_PI_F / 180.0f,
            InAngle * DX_PI_F / 180.0f,
            Range,
            Atten0,
            Atten1,
            Atten2 ) ;

        // モデルをカメラの映る位置に移動
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 200.0f ) ) ;

        // モデルを描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // パラメータの内容を画面に表示
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0,  <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Key:A.Z  OutAngle( 度 ) %f", OutAngle ) ;
        DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Key:S.X  InAngle( 度 )  %f", InAngle ) ;
        DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Key:D.C  Range          %f", Range ) ;
        DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Key:F.V  Atten0         %f", Atten0 ) ;
        DrawFormatString( 0, 64, GetColor( 255,255,255 ), "Key:G.B  Atten1         %f", Atten1 ) ;
        DrawFormatString( 0, 80, GetColor( 255,255,255 ), "Key:H.N  Atten2         %f / 100.0f", Atten2 * 100.0f ) ;

        // 裏画面の内容を表画面に反映する
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N4">宣言</a></b></td><td><font color="#000088"><b>int SetLightEnable( int EnableFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの有効、無効をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int EnableFlag ： 標準ライトを有効にするかどうか( TRUE：有効にする　FALSE：無効にする )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトを有効にするかどうかを設定します。<br>
                    　<b><a href="#R13N44">SetUseLighting</a></b> と似ていますが、無効にした場合もライティング計算をしなくなるわけではなく、
                    ただ単に標準ライトだけが無効になるのでグローバルアンビエントライトやハンドルタイプのライトによるライティング計算が行われます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　SimpleModel.mqo を普通に描画した後、標準ライトを無効にした状態で画面右側に描画します。<br>
            　標準ライトのディレクショナルライトは当たらず、自己発光色の灰色のみになっているのが確認できます。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 0.0f, 240.0f, 600.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // 標準ライトを無効にする
    SetLightEnable( FALSE ) ;

    // モデルの位置を変更
    MV1SetPosition( ModelHandle, VGet( 700.0f, 240.0f, 600.0f ) ) ;

    // モデルを描画
    MV1DrawModel( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N5">宣言</a></b></td><td><font color="#000088"><b>int SetLightDifColor( COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのディフューズカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            COLOR_F Color ： 標準ライトディフューズカラー
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのディフューズカラーを設定します。<br>
                    　この関数で設定した値は描画対象のマテリアルのディフューズカラーと掛け合わされます。<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトのディフューズカラーを青色にした状態で SimpleModel.mqo を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 標準ライトのディフューズカラーを青色にする
    SetLightDifColor( <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 1.0f, 0.0f ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 300.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N6">宣言</a></b></td><td><font color="#000088"><b>int SetLightSpcColor( COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのスペキュラカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            COLOR_F Color ： 標準ライトスペキュラカラー<BR>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのスペキュラカラーを設定します。<br>
                    　この関数で設定した値は描画対象のマテリアルのスペキュラカラーと掛け合わされます。<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトのスペキュラカラーを黄色にした状態で SimpleModel.mqo を描画します。<br>
            　( スペキュラカラーの変化が変わりやすいようにディフューズカラーの色を黒にしています )
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // スペキュラカラーの変化がわかりやすいように標準ライトのディフューズカラーを真っ黒にする
    <b><a href="#R13N5">SetLightDifColor</a></b>( <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 0.0f, 0.0f ) ) ;

    // 標準ライトのスペキュラカラーを黄色にする
    SetLightSpcColor( GetColorF( 1.0f, 1.0f, 0.0f, 0.0f ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 300.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N7">宣言</a></b></td><td><font color="#000088"><b>int SetLightAmbColor( COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのアンビエントカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            COLOR_F Color ： 標準ライトアンビエントカラー
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのアンビエントカラーを設定します。<br>
                    　この関数で設定した値は描画対象のマテリアルのアンビエントカラーと掛け合わされます。<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトのアンビエントカラーを暗い緑色にした状態で SimpleModel.mqo を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 標準ライトのアンビエントカラーを暗い緑色にする
    SetLightAmbColor( <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.2f, 0.0f, 0.0f ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 300.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N8">宣言</a></b></td><td><font color="#000088"><b>int SetLightDirection( VECTOR Direction ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの方向を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Direction ： 標準ライトの方向
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの向きを設定します。<br>
                    　<b><a href="#R13N1">ChangeLightTypeDir</a></b> や <b><a href="#R13N3">ChangeLightTypeSpot</a></b> の引数 Direction の値だけを変更する関数です。<br>
                    　ポイントライトにはライトの向きはないので、
                    ポイントライトに対してこの関数を使用しても何もおきません。<br><br>

                    　尚、引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の向きを指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトの向きをＸ軸のプラス方向にした状態で SimpleModel.mqo を描画します。<br>
            　( 標準ライトの初期タイプはディレクショナルライトです )
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 標準ライトの方向をＸ軸のプラス方向にする
    SetLightDirection( <b><a href="#R11N1">VGet</a></b>( 1.0f, 0.0f, 0.0f ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 300.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N9">宣言</a></b></td><td><font color="#000088"><b>int SetLightPosition( VECTOR Position ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの位置を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： 標準ライトの位置
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの位置を設定します。<br>
                    　<b><a href="#R13N2">ChangeLightTypePoint</a></b> や <b><a href="#R13N3">ChangeLightTypeSpot</a></b> の引数 Position の値だけを変更する関数です。<br>
                    　ディレクショナルライトにはライトの位置はないので、
                    ディレクショナルライトに対してこの関数を使用しても何もおきません。<br><br>

                    　尚、引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の位置を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　標準ライトをポイントライトに変更した後、ライトの位置をモデルの上側に移動した状態で<br>
            　モデルを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 300.0f ) ) ;

    // 標準ライトをポイントライトにする
    <b><a href="#R13N2">ChangeLightTypePoint</a></b>( VGet( 0.0f, 0.0f, 0.0f ), 2000.0f, 0.0f, 0.002f, 0.0f ) ;

    // 標準ライトの位置をモデルの上に移動する
    SetLightPosition( VGet( 320.0f, 1000.0f, 0.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N10">宣言</a></b></td><td><font color="#000088"><b>int SetLightRangeAtten( float Range, float Atten0, float Atten1, float Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの有効距離と距離減衰パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Range ： ライトの有効距離<br>
            float Atten0 ： 距離減衰パラメータ０<br>
            float Atten1 ： 距離減衰パラメータ１<br>
            float Atten2 ： 距離減衰パラメータ２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの距離減衰パラメータを設定します。<br>
                    　<b><a href="#R13N2">ChangeLightTypePoint</a></b> や <b><a href="#R13N3">ChangeLightTypeSpot</a></b> の同名の引数の値を変更するだけの関数です。<br>
                    　各パラメータの解説については ChangeLightTypePoint と ChangeLightTypeSpot 関数の解説を参照してください。<br>
                    　ディレクショナルライトには距離減衰はないので、
                    ディレクショナルライトに対してこの関数を使用しても何もおきません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N11">宣言</a></b></td><td><font color="#000088"><b>int SetLightAngle( float OutAngle, float InAngle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの照射角度パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )<br>
            float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの照射角度パラメータを設定します。<br>
                    　<b><a href="#R13N3">ChangeLightTypeSpot</a></b> の同名の引数の値を変更するだけの関数です。<br>
                    　各パラメータの解説については ChangeLightTypeSpot 関数の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N12">宣言</a></b></td><td><font color="#000088"><b>int GetLightType( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのタイプを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：標準ライトのタイプ</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのタイプを取得します。<br>
                    　戻り値は以下のいずれかです。<br><br>
                         
                    DX_LIGHTTYPE_POINT<br>
                    　　ポイントライト<br><br>
                          
                    DX_LIGHTTYPE_SPOT<br>
                    　　スポットライト<br><br>
                          
                    DX_LIGHTTYPE_DIRECTIONAL<br>
                    　　ディレクショナルライト<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　標準ライトの情報を画面に描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char *TypeName ;
    COLOR_F Color ;
    VECTOR Vector ;
    float Range, Atten0, Atten1, Atten2 ;
    float InAngle, OutAngle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 画面に標準ライトのタイプを描画
    switch( GetLightType() )
    {
    case DX_LIGHTTYPE_DIRECTIONAL : TypeName = "Directional" ; break ;
    case DX_LIGHTTYPE_POINT :       TypeName = "Point" ;       break ;
    case DX_LIGHTTYPE_SPOT :        TypeName = "Spot" ;        break ;
    }
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),   "LightType       %s", TypeName ) ;

    // ライトが有効かどうかを描画
    DrawFormatString( 0, 16, GetColor( 255,255,255 ),  "Enable          %d", <b><a href="#R13N13">GetLightEnable</a></b>() ) ;

    // ディフューズカラーを描画
    Color = <b><a href="#R13N14">GetLightDifColor</a></b>() ;
    DrawFormatString( 0, 32, GetColor( 255,255,255 ),  "Diffuse Color   %f %f %f", Color.r, Color.g, Color.b ) ;

    // スペキュラカラーを描画
    Color = <b><a href="#R13N15">GetLightSpcColor</a></b>() ;
    DrawFormatString( 0, 48, GetColor( 255,255,255 ),  "Specular Color  %f %f %f", Color.r, Color.g, Color.b ) ;

    // アンビエントカラーを描画
    Color = <b><a href="#R13N16">GetLightAmbColor</a></b>() ;
    DrawFormatString( 0, 64, GetColor( 255,255,255 ),  "Ambient Color   %f %f %f", Color.r, Color.g, Color.b ) ;

    // 向きを描画
    Vector = <b><a href="#R13N17">GetLightDirection</a></b>() ;
    DrawFormatString( 0, 80, GetColor( 255,255,255 ),  "Direction       %f %f %f", Vector.x, Vector.y, Vector.z ) ;

    // 位置を描画
    Vector = <b><a href="#R13N18">GetLightPosition</a></b>() ;
    DrawFormatString( 0, 96, GetColor( 255,255,255 ),  "Position        %f %f %f", Vector.x, Vector.y, Vector.z ) ;

    // 有効距離と距離減衰パラメータを描画する
    <b><a href="#R13N19">GetLightRangeAtten</a></b>( &amp;Range, &amp;Atten0, &amp;Atten1, &amp;Atten2 ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Range           %f", Range ) ;
    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "Attenuation0    %f", Atten0 ) ;
    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "Attenuation1    %f", Atten1 ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "Attenuation2    %f", Atten2 ) ;

    // 照射角度パラメータを描画する
    <b><a href="#R13N20">GetLightAngle</a></b>( &amp;OutAngle, &amp;InAngle ) ;
    DrawFormatString( 0, 176, GetColor( 255,255,255 ), "In  Angle       %f", InAngle ) ;
    DrawFormatString( 0, 192, GetColor( 255,255,255 ), "Out Angle       %f", OutAngle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N13">宣言</a></b></td><td><font color="#000088"><b>int GetLightEnable( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの有効、無効を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：標準ライトは有効</td></tr>
            <tr><td width="100">　</td><td>FALSE：標準ライトは無効<br><br></td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトが有効かどうかを取得します。<br>
                　　　戻り値が TRUE の場合は有効で、FALSE の場合は無効です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N14">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetLightDifColor( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのディフューズカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ディフューズカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのディフューズカラーを取得します。<br>
                　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。<br>
                    　ライトのカラーでは a の値は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N15">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetLightSpcColor( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのスペキュラカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのスペキュラカラーを取得します。<br>
                　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。<br>
                    　ライトのカラーでは a の値は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N16">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetLightAmbColor( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトのアンビエントカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アンビエントカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのアンビエントカラーを取得します。<br>
                　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。<br>
                    　ライトのカラーでは a の値は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N17">宣言</a></b></td><td><font color="#000088"><b>VECTOR GetLightDirection( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの向きを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>標準ライトの向き</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの向きを取得します。<br>
                　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N18">宣言</a></b></td><td><font color="#000088"><b>VECTOR GetLightPosition( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの位置を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>標準ライトの位置</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの位置を取得します。<br>
                　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N19">宣言</a></b></td><td><font color="#000088"><b>int GetLightRangeAtten( float *Range, float *Atten0, float *Atten1, float *Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの有効距離と距離減衰パラメータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float *Range ： 有効距離を代入する変数のアドレス<br>
            float *Atten0 ： 距離減衰パラメータ０を代入する変数のアドレス<br>
            float *Atten1 ： 距離減衰パラメータ１を代入する変数のアドレス<br>
            float *Atten2 ： 距離減衰パラメータ２を代入する変数のアドレス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトの有効距離と距離減衰パラメータを取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N20">宣言</a></b></td><td><font color="#000088"><b>int GetLightAngle( float *OutAngle, float *InAngle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>標準ライトの照射角度パラメータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float *OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )を代入する変数のアドレス<br>
            float *InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )を代入する変数のアドレス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　標準ライトのスポットライトコーンの角度を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N12">GetLightType関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><font size="3" color="#005500"><b>ライトハンドル関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N21">宣言</a></b></td><td><font color="#000088"><b>int CreateDirLightHandle( VECTOR Direction ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ディレクショナルタイプのライトハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Direction ： ライトの方向
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：ライトハンドル</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ディレクショナルタイプのライトハンドルを作成します。
                    ( ディレクショナルライトとは位置を持たず方向だけを設定するライトで、
                    太陽の光などの光源が遠すぎて何処に居ても同じ方向から照らされるライト効果などに使用します )<br><br>

                    　この関数は戻り値にライトハンドル( int 型の数値 )を返してきます。<br>
                    　ライトハンドルの設定を変更したり、
                    不要になったライトハンドルを削除したりする際に必要になりますので戻り値は必ず何かしらの変数に保存しておくようにしてください。<br><br>

                    　引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の向き指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>

                    　尚、ライトハンドル系の関数は一つしかない標準ライト以外にライトを使用したい場合に使用します。
                    ( とはいえ同時に有効にできるのは標準ライトを含めて３つまでですが・・・ )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Ｘ軸にマイナス方向のディレクショナルライトハンドルを作成して、<br>
            　効果がわかり易いように標準ライトを無効にした上でモデルを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, LightHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // Ｘ軸にマイナス方向のディレクショナルタイプのライトの作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( -1.0f, 0.0f, 0.0f ) ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N22">宣言</a></b></td><td><font color="#000088"><b>int CreatePointLightHandle( VECTOR Position, float Range, float Atten0, float Atten1, float Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ポイントタイプのライトハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： ライトの位置<br>
            float Range ： ライトの有効距離<br>
            float Atten0 ： 距離減衰パラメータ０<br>
            float Atten1 ： 距離減衰パラメータ１<br>
            float Atten2 ： 距離減衰パラメータ２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：ライトハンドル</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ポイントタイプのライトハンドルを作成します。
                    ( ポイントライトは指定した位置から全方向に光を放つライトです )<br><br>

                    　この関数は戻り値にライトハンドル( int 型の数値 )を返してきます。<br>
                    　ライトハンドルの設定を変更したり、
                    不要になったライトハンドルを削除したりする際に必要になりますので戻り値は必ず何かしらの変数に保存しておくようにしてください。<br><br>

                    　引数の説明をします。<br><br>

                    VECTER Position<br>
                    　ポイントライトの位置です。<br><br>

                    float Range<br>
                    　ポイントライトの影響最大距離です。<br>
                    　この引数で指定する距離以上の座標にある頂点は、
                    例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。<br><br>

                    float Atten0<br>
                    float Atten1<br>
                    float Atten2<br>
                    　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。<br>
                    　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。<br>
                    　その計算式は以下のようなものです。<br>
<pre>
d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )
</pre>
                    　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、
                    Atten1 はライトの距離に比例して減衰する率、
                    Atten2 はライトの距離の二乗に比例して減衰する率となります。<br>
                    　率を除算する値ですので、
                    非常に小さな値でも物凄くライトの影響範囲が狭まります。
                    なので引数に渡す値はこの式を理解してから決定してください。<br><br>

                    　引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の向き指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>

                    　尚、ライトハンドル系の関数は一つしかない標準ライト以外にライトを使用したい場合に使用します。
                    ( とはいえ同時に有効にできるのは標準ライトを含めて３つまでですが・・・ )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　読み込んだモデルの上側にポイントライトを作成して、<br>
            　効果がわかり易いように標準ライトを無効にした上でモデルを描画します。<br><br>

            　　ポイントライトの各パラメータを変化させるとどのような変化があるのかは<br>
            　<a href="#R13N2">ChangeLightTypePoint関数</a> のサンプルで確認できます。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, LightHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 600.0f ) ) ;

    // モデルの上側にポイントタイプのライトを作成
    LightHandle = <b><a href="#R13N22">CreatePointLightHandle</a></b>(
                    VGet( 320.0f, 1000.0f, 600.0f ),
                    2000.0f,
                    0.0f,
                    0.002f,
                    0.0f ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N23">宣言</a></b></td><td><font color="#000088"><b>int CreateSpotLightHandle( VECTOR Position, VECTOR Direction, float OutAngle, float InAngle, float Range, float Atten0, float Atten1, float Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>スポットタイプのライトハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Position ： ライトの位置<br>
            VECTOR Direction ： ライトの向き<br>
            float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )<br>
            float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )<br>
            float Range ： ライトの有効距離<br>
            float Atten0 ： 距離減衰パラメータ０<br>
            float Atten1 ： 距離減衰パラメータ１<br>
            float Atten2 ： 距離減衰パラメータ２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：ライトハンドル</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　スポットタイプのライトハンドルを作成します。
                    ( スポットライトは指定した位置から指定の方向に全方向に光を放つライトです )<br><br>

                    　この関数は戻り値にライトハンドル( int 型の数値 )を返してきます。<br>
                    　ライトハンドルの設定を変更したり、
                    不要になったライトハンドルを削除したりする際に必要になりますので戻り値は必ず何かしらの変数に保存しておくようにしてください。<br><br>

                    　引数の説明をします。<br><br>

                    VECTER Position<br>
                    　スポットライトの位置です。<br><br>

                    VECTOR Direction<br>
                    　スポットライトの向きです<br><br>

                    float OutAngle<br>
                    　スポットライトの影響角度です。<br>
                    　スポットライトの向きに対してこの引数で指定する角度以上の頂点にはライトの影響はありません。<br>
                    　有効な値は 0.0f 〜 DX_PI_F までです。<br><br>

                    float InAngle<br>
                    　スポットライトの影響が減衰を始める角度です。<br>
                    　スポットライトが OutAngle の角度まで１００％の影響を与えて、
                    そこから急に影響が無い状態になりますと不自然に見えるかもしれません。<br>
                    　そんなときはこの引数でスポットライトの影響が弱まり始める角度を指定します。<br>
                    　スポットライトの向きに対してこの引数で指定する角度以上で且つ OutAngle 以下の場合はライトの影響が１００％ではなくなります。<br>
                    　有効な値は 0.0f 〜 OutAngle までです。<br><br>

                    float Range<br>
                    　スポットライトの影響最大距離です。<br>
                    　この引数で指定する距離以上の座標にある頂点は、
                    例え距離減衰計算の結果が０ではなくてもライトの影響は無くなります。<br><br>

                    float Atten0<br>
                    float Atten1<br>
                    float Atten2<br>
                    　ライトの影響力の距離減衰パラメータです( Atten は Attenuation の略です )。<br>
                    　ディレクショナルライト以外のライトはライトの位置から離れれば離れるほどライトの影響が弱くなるようになっています。<br>
                    　その計算式は以下のようなものです。<br>
<pre>
d = ライトから頂点への距離
ライトの影響力(％) = 100.0f / ( Atten0 + Atten1 * d + Atten2 * d * d )
</pre>
                    　つまり、Atten0 はライトと頂点の距離に関係なく減衰する率を指定する引数、
                    Atten1 はライトの距離に比例して減衰する率、
                    Atten2 はライトの距離の二乗に比例して減衰する率となります。<br>
                    　率を除算する値ですので、
                    非常に小さな値でも物凄くライトの影響範囲が狭まります。
                    なので引数に渡す値はこの式を理解してから決定してください。<br><br>

                    　引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の向き指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数にベクトル値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>

                    　尚、ライトハンドル系の関数は一つしかない標準ライト以外にライトを使用したい場合に使用します。
                    ( とはいえ同時に有効にできるのは標準ライトを含めて３つまでですが・・・ )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　読み込んだモデルの上側に下向きの光を放つスポットライトを作成して、<br>
            　効果がわかり易いように標準ライトを無効にした上でモデルを描画します。<br><br>

            　　スポットライトの各パラメータを変化させるとどのような変化があるのかは<br>
            　<a href="#R13N3">ChangeLightTypeSpot関数</a> のサンプルで確認できます。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, LightHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // モデルをカメラの映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 600.0f ) ) ;

    // モデルの上側に下向きのスポットタイプのライトを作成
    LightHandle = <b><a href="#R13N23">CreateSpotLightHandle</a></b>(
                    VGet( 320.0f, 1000.0f, 600.0f ),
                    VGet( 0.0f, -1.0f, 0.0f ),
                    DX_PI_F / 2.0f,
                    DX_PI_F / 4.0f,
                    2000.0f,
                    0.0f,
                    0.002f,
                    0.0f ) ;

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N24">宣言</a></b></td><td><font color="#000088"><b>int DeleteLightHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： 削除するライトハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R13N21">CreateDirLightHandle</a></b>, <b><a href="#R13N22">CreatePointLightHandle</a></b>, <b><a href="#R13N23">CreateSpotLightHandle</a></b> で作成したライトハンドルを削除します。<br><br>
                
                    　作成できるライトハンドルの数には限界がありますので、
                    不要になったライトハンドルは必ずこの関数で削除してください。<br><br>

                    　因みに <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b> を使用すると自動的にすべてのライトが削除されますので、
                    DxLib_End の前にすべてのライトハンドルを削除しておかなければならないということはありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ディレクショナルライトを作成してすぐ削除します。<br>
            　　削除関数を使うサンプルプログラムなので実行しても何も起きません。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ディレクショナルライトタイプのハンドルの作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, 0.0f, 0.0f ) ) ;

    // 直後に削除
    DeleteLightHandle( LightHandle ) ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N25">宣言</a></b></td><td><font color="#000088"><b>int DeleteLightHandleAll( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルを全て削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R13N21">CreateDirLightHandle</a></b>, <b><a href="#R13N22">CreatePointLightHandle</a></b>, <b><a href="#R13N23">CreateSpotLightHandle</a></b> で作成したライトハンドルを全て削除します。<br><br>
                
                    　作成できるライトハンドルの数には限界がありますので、
                    ライトハンドルが不要になった際は必ずこの関数で削除してください。<br><br>

                    　因みに <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b> を使用すると自動的にすべてのライトが削除されますので、
                    DxLib_End の前にこの関数を呼んでおかなければならないということはありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N26">宣言</a></b></td><td><font color="#000088"><b>int SetLightTypeHandle( int LHandle, int LightType ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのタイプを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            int LightType ： ライトタイプ
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトタイプを変更します。<br>
                    　ライトタイプに指定できる値は以下の３つです。<br><br>
                    
                    DX_LIGHTTYPE_DIRECTIONAL<br>
                    　　ディレクショナルライト<br><br>

                    DX_LIGHTTYPE_POINT<br>
                    　　ポイントライト<br><br>
                          
                    DX_LIGHTTYPE_SPOT<br>
                    　　スポットライト<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ディレクショナルタイプのライトを作成した後、それをポイントタイプのライトに変更して<br>
            　ポイントライトとしてのパラメータを設定した後モデルを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle, ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ディレクショナルタイプのライトハンドルの作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, 0.0f, 0.0f ) ) ;

    // ライトのタイプをポイントライトに変更
    SetLightTypeHandle( LightHandle, DX_LIGHTTYPE_POINT ) ;

    // 位置を設定
    <b><a href="#R13N32">SetLightPositionHandle</a></b>( LightHandle, VGet( 320.0f, 1000.0f, 600.0f ) ) ;

    // 有効距離と距離減衰パラメータを設定
    <b><a href="#R13N33">SetLightRangeAttenHandle</a></b>( LightHandle, 2000.0f, 0.0f, 0.002f, 0.0f ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N27">宣言</a></b></td><td><font color="#000088"><b>int SetLightEnableHandle( int LHandle, int EnableFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの有効、無効を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            int EnableFlag ： ライトを有効にするかどうか( TRUE：有効にする　FALSE：無効にする )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　指定のライトハンドルのライトを有効にするかどうかを設定します。<br>
                    　同時に有効にできる数は標準ライトを含めて３つまでです。<br><br>

                    　既に３つ有効なライトがある状態でライトを有効にすると、どのライトが有効になるかは不定となります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　３つのディレクショナルタイプのライトハンドルを作成した後、各ライトを５０％の確率で<br>
            　無効にして、そのあとモデルを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle[ 3 ], ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ディレクショナルタイプのライトハンドルを３つ作成
    LightHandle[ 0 ] = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, 0.0f, 0.0f ) ) ;
    LightHandle[ 1 ] = CreateDirLightHandle( VGet( 0.0f, 1.0f, 0.0f ) ) ;
    LightHandle[ 2 ] = CreateDirLightHandle( VGet( 0.0f, 0.0f, 1.0f ) ) ;

    // 各ライトを５０％の確率で無効にする
    if( GetRand( 99 ) >= 50 )
    {
        SetLightEnableHandle( LightHandle[ 0 ], FALSE ) ;
    }

    if( GetRand( 99 ) >= 50 )
    {
        SetLightEnableHandle( LightHandle[ 1 ], FALSE ) ;
    }

    if( GetRand( 99 ) >= 50 )
    {
        SetLightEnableHandle( LightHandle[ 2 ], FALSE ) ;
    }

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N28">宣言</a></b></td><td><font color="#000088"><b>int SetLightDifColorHandle( int LHandle, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのディフューズカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            COLOR_F Color ： ディフューズカラー
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのディフューズカラーを設定します。<br>
                    　この関数で設定した値は描画対象のマテリアルのディフューズカラーと掛け合わされます。<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ライトハンドルのディフューズカラーを青色にした状態で SimpleModel.mqo を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle, ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ディレクショナルタイプのライトハンドルを作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, -1.0f, 1.0f ) ) ;

    // ライトハンドルのディフューズカラーを青色にする
    SetLightDifColorHandle( LightHandle, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 1.0f, 0.0f ) ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N29">宣言</a></b></td><td><font color="#000088"><b>int SetLightSpcColorHandle( int LHandle, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのスペキュラカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            COLOR_F Color ： スペキュラカラー
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのスペキュラカラーを設定します。<br>
                    　この関数で設定した値は描画対象のマテリアルのスペキュラカラーと掛け合わされます。<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ライトハンドルのスペキュラカラーを赤色にした状態で SimpleModel.mqo を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle, ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ディレクショナルタイプのライトハンドルを作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, -1.0f, 1.0f ) ) ;

    // スペキュラカラーの変更がわかり易いようにディフューズカラーを黒にする
    <b><a href="#R13N28">SetLightDifColorHandle</a></b>( LightHandle, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 0.0f, 0.0f ) ) ;

    // ライトハンドルのスペキュラカラーを赤色にする
    SetLightSpcColorHandle( LightHandle, GetColorF( 1.0f, 0.0f, 0.0f, 0.0f ) ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N30">宣言</a></b></td><td><font color="#000088"><b>int SetLightAmbColorHandle( int LHandle, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのアンビエントカラーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            COLOR_F Color ： アンビエントカラー
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのアンビエントカラーを設定します。<br>
                    　この関数で設定した値は描画対象のマテリアルのアンビエントカラーと掛け合わされます。<br><br>

                    　引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。
                    ( 因みにライト関係の関数では a の値は使われません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ライトハンドルのアンビエントカラーを暗い緑色にした状態で SimpleModel.mqo を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle, ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ディレクショナルタイプのライトハンドルを作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, -1.0f, 1.0f ) ) ;

    // ライトハンドルのアンビエントカラーを暗い緑色にする
    SetLightAmbColorHandle( LightHandle, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.2f, 0.0f, 0.0f ) ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N31">宣言</a></b></td><td><font color="#000088"><b>int SetLightDirectionHandle( int LHandle, VECTOR Direction ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの方向を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            VECTOR Direction ： 標準ライトの方向
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの向きを設定します。<br>
                    　<b><a href="#R13N21">CreateDirLightHandle</a></b> や <b><a href="#R13N23">CreateSpotLightHandle</a></b> の引数 Direction の値だけを変更する関数です。<br>
                    　ポイントライトにはライトの向きはないので、
                    ポイントライトに対してこの関数を使用しても何もおきません。<br><br>

                    　尚、引数 Direction は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の向きを指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ライトハンドルのライトの向きをＸ軸のプラス方向にした状態で SimpleModel.mqo を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle, ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ディレクショナルタイプのライトハンドルを作成
    LightHandle = <b><a href="#R13N21">CreateDirLightHandle</a></b>( <b><a href="#R11N1">VGet</a></b>( 1.0f, -1.0f, 1.0f ) ) ;

    // ライトハンドルの方向をＸ軸のプラス方向にする
    SetLightDirectionHandle( LightHandle, VGet( 1.0f, 0.0f, 0.0f ) ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N32">宣言</a></b></td><td><font color="#000088"><b>int SetLightPositionHandle( int LHandle, VECTOR Position ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの位置を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル
            VECTOR Position ： 標準ライトの位置
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの位置を設定します。<br>
                    　<b><a href="#R13N22">CreatePointLightHandle</a></b> や <b><a href="#R13N23">CreateSpotLightHandle</a></b> の引数 Position の値だけを変更する関数です。<br>
                    　ディレクショナルライトにはライトの位置はないので、
                    ディレクショナルライトに対してこの関数を使用しても何もおきません。<br><br>

                    　尚、引数 Position は float x, y, z の三つのメンバ変数を持っている構造体 VECTOR で、
                    この３要素を使用して３次元の位置を指定します。<br>
                    　引数が構造体だと事前に引数に渡す構造体を宣言してメンバ変数に値を代入して・・・と準備が面倒ですが、
                    引数に x, y, z の値を渡すとそれを元にした VECTOR 構造体を戻り値で返してくれる関数 <b><a href="#R11N1">VGet</a></b> を使用することで簡素に引数を渡すことができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ポイントタイプのライトを作成した後、ライトの位置をモデルの上側に移動してから<br>
            　モデルを描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int LightHandle, ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ライトハンドルのライトの効果がわかり易いように標準ライトを無効化
    <b><a href="#R13N4">SetLightEnable</a></b>( FALSE ) ;

    // ポイントタイプのライトハンドルを作成
    LightHandle = <b><a href="#R13N22">CreatePointLightHandle</a></b>(
                    <b><a href="#R11N1">VGet</a></b>( 320.0f, 1000.0f, 600.0f ),
                    2000.0f,
                    0.0f,
                    0.002f,
                    0.0f ) ;

    // ライトハンドルの位置をモデルの上側に移動
    SetLightPositionHandle( LightHandle, VGet( 320.0f, 1000.0f, 600.0f ) ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 320.0f, 240.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N33">宣言</a></b></td><td><font color="#000088"><b>int SetLightRangeAttenHandle( int LHandle, float Range, float Atten0, float Atten1, float Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの有効距離と距離減衰パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            float Range ： ライトの有効距離<br>
            float Atten0 ： 距離減衰パラメータ０<br>
            float Atten1 ： 距離減衰パラメータ１<br>
            float Atten2 ： 距離減衰パラメータ２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの距離減衰パラメータを設定します。<br>
                    　<b><a href="#R13N22">CreatePointLightHandle</a></b> や <b><a href="#R13N23">CreateSpotLightHandle</a></b> の同名の引数の値を変更するだけの関数です。<br>
                    　各パラメータの解説については CreatePointLightHandle と CreateSpotLightHandle 関数の解説を参照してください。<br>
                    　ディレクショナルライトには距離減衰はないので、
                    ディレクショナルライトに対してこの関数を使用しても何もおきません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N34">宣言</a></b></td><td><font color="#000088"><b>int SetLightAngleHandle( int LHandle, float OutAngle, float InAngle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの照射角度パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            float OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )<br>
            float InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの照射角度パラメータを設定します。<br>
                    　<b><a href="#R13N23">CreateSpotLightHandle</a></b> の同名の引数の値を変更するだけの関数です。<br>
                    　各パラメータの解説については CreateSpotLightHandle 関数の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N35">宣言</a></b></td><td><font color="#000088"><b>int GetLightTypeHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのタイプを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：ライトのタイプ</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトのタイプを取得します。<br>
                    　戻り値は以下のいずれかです。<br><br>
                         
                    DX_LIGHTTYPE_POINT<br>
                    　　ポイントライト<br><br>
                          
                    DX_LIGHTTYPE_SPOT<br>
                    　　スポットライト<br><br>
                          
                    DX_LIGHTTYPE_DIRECTIONAL<br>
                    　　ディレクショナルライト<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　スポットライトを作成して、そのライトの情報を画面に描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    char *TypeName ;
    COLOR_F Color ;
    VECTOR Vector ;
    float Range, Atten0, Atten1, Atten2 ;
    float InAngle, OutAngle ;
    int LightHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // スポットタイプのライトの作成
    LightHandle = <b><a href="#R13N23">CreateSpotLightHandle</a></b>(
                    <b><a href="#R11N1">VGet</a></b>( 320.0f, 1000.0f, 600.0f ),
                    VGet( 0.0f, -1.0f, 0.0f ),
                    DX_PI_F / 2.0f,
                    DX_PI_F / 4.0f,
                    2000.0f,
                    0.0f,
                    0.002f,
                    0.0f ) ;

    // 画面に標準ライトのタイプを描画
    switch( GetLightTypeHandle( LightHandle ) )
    {
    case DX_LIGHTTYPE_DIRECTIONAL : TypeName = "Directional" ; break ;
    case DX_LIGHTTYPE_POINT :       TypeName = "Point" ;       break ;
    case DX_LIGHTTYPE_SPOT :        TypeName = "Spot" ;        break ;
    }
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),   "LightType       %s", TypeName ) ;

    // ライトが有効かどうかを描画
    DrawFormatString( 0, 16, GetColor( 255,255,255 ),  "Enable          %d", <b><a href="#R13N36">GetLightEnableHandle</a></b>( LightHandle ) ) ;

    // ディフューズカラーを描画
    Color = <b><a href="#R13N37">GetLightDifColorHandle</a></b>( LightHandle ) ;
    DrawFormatString( 0, 32, GetColor( 255,255,255 ),  "Diffuse Color   %f %f %f", Color.r, Color.g, Color.b ) ;

    // スペキュラカラーを描画
    Color = <b><a href="#R13N38">GetLightSpcColorHandle</a></b>( LightHandle ) ;
    DrawFormatString( 0, 48, GetColor( 255,255,255 ),  "Specular Color  %f %f %f", Color.r, Color.g, Color.b ) ;

    // アンビエントカラーを描画
    Color = <b><a href="#R13N39">GetLightAmbColorHandle</a></b>( LightHandle ) ;
    DrawFormatString( 0, 64, GetColor( 255,255,255 ),  "Ambient Color   %f %f %f", Color.r, Color.g, Color.b ) ;

    // 向きを描画
    Vector = <b><a href="#R13N40">GetLightDirectionHandle</a></b>( LightHandle ) ;
    DrawFormatString( 0, 80, GetColor( 255,255,255 ),  "Direction       %f %f %f", Vector.x, Vector.y, Vector.z ) ;

    // 位置を描画
    Vector = <b><a href="#R13N41">GetLightPositionHandle</a></b>( LightHandle ) ;
    DrawFormatString( 0, 96, GetColor( 255,255,255 ),  "Position        %f %f %f", Vector.x, Vector.y, Vector.z ) ;

    // 有効距離と距離減衰パラメータを描画する
    <b><a href="#R13N42">GetLightRangeAttenHandle</a></b>( LightHandle, &amp;Range, &amp;Atten0, &amp;Atten1, &amp;Atten2 ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Range           %f", Range ) ;
    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "Attenuation0    %f", Atten0 ) ;
    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "Attenuation1    %f", Atten1 ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "Attenuation2    %f", Atten2 ) ;

    // 照射角度パラメータを描画する
    <b><a href="#R13N43">GetLightAngleHandle</a></b>( LightHandle, &amp;OutAngle, &amp;InAngle ) ;
    DrawFormatString( 0, 176, GetColor( 255,255,255 ), "In  Angle       %f", InAngle ) ;
    DrawFormatString( 0, 192, GetColor( 255,255,255 ), "Out Angle       %f", OutAngle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N36">宣言</a></b></td><td><font color="#000088"><b>int GetLightEnableHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの有効、無効を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：ライトは有効</td></tr>
            <tr><td width="100">　</td><td>FALSE：ライトは無効<br><br></td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトが有効かどうかを取得します。<br>
                　　　戻り値が TRUE の場合は有効で、FALSE の場合は無効です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N37">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetLightDifColorHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのディフューズカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ディフューズカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトのディフューズカラーを取得します。<br>
                　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。<br>
                    　ライトのカラーでは a の値は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N38">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetLightSpcColorHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのスペキュラカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトのスペキュラカラーを取得します。<br>
                　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。<br>
                    　ライトのカラーでは a の値は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N39">宣言</a></b></td><td><font color="#000088"><b>COLOR_F GetLightAmbColorHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトのアンビエントカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アンビエントカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトのアンビエントカラーを取得します。<br>
                　　　戻り値の COLOR_F は構造体で、中身は float r, g, b, a となっています。<br>
                    　ライトのカラーでは a の値は使いません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N40">宣言</a></b></td><td><font color="#000088"><b>VECTOR GetLightDirectionHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの方向を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ライトの向き</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの向きを取得します。<br>
                　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N41">宣言</a></b></td><td><font color="#000088"><b>VECTOR GetLightPositionHandle( int LHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの位置を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ライトの位置</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの位置を取得します。<br>
                　　　戻り値の VECTOR は構造体で、中身は float x, y, z となっています。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N42">宣言</a></b></td><td><font color="#000088"><b>int GetLightRangeAttenHandle( int LHandle, float *Range, float *Atten0, float *Atten1, float *Atten2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの有効距離と距離減衰パラメータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            float *Range ： 有効距離を代入する変数のアドレス<br>
            float *Atten0 ： 距離減衰パラメータ０を代入する変数のアドレス<br>
            float *Atten1 ： 距離減衰パラメータ１を代入する変数のアドレス<br>
            float *Atten2 ： 距離減衰パラメータ２を代入する変数のアドレス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトの有効距離と距離減衰パラメータを取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N43">宣言</a></b></td><td><font color="#000088"><b>int GetLightAngleHandle( int LHandle, float *OutAngle, float *InAngle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ライトハンドルのライトの照射角度パラメータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int LHandle ： ライトハンドル<br>
            float *OutAngle ： スポットライトコーンの外側の角度( 単位：ラジアン )を代入する変数のアドレス<br>
            float *InAngle ： スポットライトコーンの内側の角度( 単位：ラジアン )を代入する変数のアドレス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ライトハンドルのライトのスポットライトコーンの角度を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R13N35">GetLightTypeHandle関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N46">宣言</a></b></td><td><font color="#000088"><b>int GetEnableLightHandleNum( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>有効になっているライトハンドルの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０以上：有効になっているライトハンドルの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R13N27">SetLightEnableHandle</a></b> で有効( TRUE )に設定されているライトハンドルの数を取得します。<br>
                    　標準ライトも内部でライトハンドルを使用しているのでライトハンドルを一つも作成していなくても SetLightEnable の設定が TRUE になっている場合の戻り値は１になります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R13N47">宣言</a></b></td><td><font color="#000088"><b>int GetEnableLightHandle( int Index ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>有効になっているライトハンドルを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int Index ： 有効になっているライトハンドルの番号<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０以上：有効になっているライトハンドル</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R13N27">SetLightEnableHandle</a></b> で有効( TRUE )に設定されているライトハンドルを取得します。<br>
                    　Index に指定できる値は０から <b><a href="#R13N46">GetEnableLightHandleNum</a></b> の戻り値から１引いた値までです。<br>
                    　また、有効になっているライトはディレクショナルライト・スポットライト・ポイントライトの順番になっています。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br><br><br><br><br>
        </td></tr>










        <tr><td><font size="3" color="#005500"><b>算術演算関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N1">宣言</a></b></td><td><font color="#000088"><b>VECTOR VGet( float x, float y, float z ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float x ： 取得するベクトルのＸ成分<br> 
            float y ： 取得するベクトルのＹ成分<br>
            float z ： 取得するベクトルのＺ成分
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>引数 x,y,z を代入したVECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 x, y, z を VECTOR 構造体のメンバ変数 x, y, z に代入して返すだけの関数です。<br>
<pre>
戻り値.x = x ;
戻り値.y = y ;
戻り値.z = z ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect に値を代入します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値( x=100.0f y=200.0f z=400.0f )を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 400.0f ) ;

    // Vect の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N2">宣言</a></b></td><td><font color="#000088"><b>VECTOR VAdd( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルを加算する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 加算されるベクトル<br> 
            VECTOR In2 ： 加算するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 と In2 の値を加算した VECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 の x, y, z 成分を加算した結果を戻り値として返す関数です。<br>
<pre>
戻り値.x = In1.x + In2.x ;
戻り値.y = In1.y + In2.y ;
戻り値.z = In1.z + In2.z ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 と Vect2 を加算して、結果を Vect1 に代入します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 と Vect2 を加算して結果を Vect1 に代入
    Vect1 = VAdd( Vect1, Vect2 ) ;

    // Vect1 の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N3">宣言</a></b></td><td><font color="#000088"><b>VECTOR VSub( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルを減算する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 減算されるベクトル<br> 
            VECTOR In2 ： 減算するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 から In2 の値を減算した VECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 から In2 の x, y, z 成分を減算した結果を戻り値として返す関数です。<br>
<pre>
戻り値.x = In1.x - In2.x ;
戻り値.y = In1.y - In2.y ;
戻り値.z = In1.z - In2.z ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 から Vect2 を減算して、結果を Vect1 に代入します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 から Vect2 を減算して結果を Vect1 に代入
    Vect1 = VSub( Vect1, Vect2 ) ;

    // Vect1 の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N4">宣言</a></b></td><td><font color="#000088"><b>float VDot( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルの内積を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 内積するベクトル１<br> 
            VECTOR In2 ： 内積するベクトル２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 と In2 の内積値</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 の内積を返す関数です。<br>
<pre>
戻り値 = In1.x * In2.x + In1.y * In2.y + In1.z * In2.z ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 と Vect2 の内積を画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 と Vect2 の内積を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Dot  %f", VDot( Vect1, Vect2 ) ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N5">宣言</a></b></td><td><font color="#000088"><b>VECTOR VCross( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つのベクトルの外積を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： 外積するベクトル１<br> 
            VECTOR In2 ： 外積するベクトル２
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>In1 と In2 の外積値</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 の外積を返す関数です。<br>
<pre>
戻り値.x = In1.y * In2.z - In1.z * In2.y ;
戻り値.y = In1.z * In2.x - In1.x * In2.z ;
戻り値.z = In1.x * In2.y - In1.y * In2.x ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect1 と Vect2 の外積を画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect1 と Vect2 に値を代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;
    Vect2 = VGet( 30.0f, 100.0f, 80.0f ) ;

    // Vect1 と Vect2 の外戚を Vect1 に代入
    Vect1 = VCross( Vect1, Vect2 ) ;

    // Vect1 の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect1  x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N6">宣言</a></b></td><td><font color="#000088"><b>VECTOR VScale( VECTOR In, float Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルのスケーリングをする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： スケーリングをするベクトル<br> 
            float Scale ： スケーリング値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スケーリングした結果の VECTOR 構造体</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In のベクトルを Scale 倍して返す関数です。<br>
<pre>
戻り値.x = In.y * Scale ;
戻り値.y = In.z * Scale ;
戻り値.z = In.x * Scale ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect の内容を 8.0f 倍して、その結果を画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect を 8.0f 倍して、その結果を Vect に代入
    Vect = VScale( Vect, 8.0f ) ;

    // Vect の内容を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;  

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N9">宣言</a></b></td><td><font color="#000088"><b>float VSize( VECTOR In ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルのサイズを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： サイズを取得したいベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ベクトルのサイズ</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In のベクトルのサイズを取得する関数です。<br>
<pre>
戻り値 = sqrt( In1.x * In1.x + In1.y * In1.y + In1.z * In1.z ) ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect のサイズを画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect のサイズを画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Size  %f", VSize( Vect ) ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N10">宣言</a></b></td><td><font color="#000088"><b>float VSquareSize( VECTOR In ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ベクトルのサイズの２乗を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： サイズの二乗を取得したいベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ベクトルのサイズの二乗</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In のベクトルのサイズの二乗を取得する関数です。<br><br>
                    　ベクトルのサイズを算出するには処理負荷の高い平方根計算を行わなければならないので、
                    二つのサイズの比較等、
                    サイズの二乗でも処理に支障が発生しない場合はこちらの関数を使用したほうが処理負荷が低くて済みます。<br>
<pre>
戻り値 = In1.x * In1.x + In1.y * In1.y + In1.z * In1.z ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect のサイズの二乗を画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect のサイズの二乗を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Size  %f", VSquareSize( Vect ) ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N11">宣言</a></b></td><td><font color="#000088"><b>VECTOR VNorm( VECTOR In ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>正規化ベクトルを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In ： 正規化したいベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>正規化したベクトル</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In を正規化したベクトルを取得する関数です。<br>
                    　正規化とはベクトルの方向は変えずにサイズを１にすることで、
                    ベクトルの方向成分だけを取得したい場合などに行います。<br>
<pre>
float size ;
size =  VSize( In ) ;
戻り値.x = In1.x / size ;
戻り値.y = In1.y / size ;
戻り値.z = In1.z / size ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect を正規化した値を画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // Vect の値を正規化して、その結果を Vect に代入する
    Vect = VNorm( Vect ) ;

    // Vect の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N12">宣言</a></b></td><td><font color="#000088"><b>VECTOR VTransform( VECTOR InV, MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>行列を使ったベクトルの変換<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR InV ： 変換処理を行いたいベクトル<br>
            MATRIX InM ： 変換処理に使用するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換後のベクトル</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InV のベクトルを引数 InM の行列を使用して変換処理を行います。<br>
                    　計算的には InV を１ｘ４行列として扱い( 4つめの要素は 1.0f とします ) InM の行列の左から乗算した結果を返します。<br>
<pre>
戻り値.x = InV.x * InM.m[0][0] + InV.y * InM.m[1][0] + InV.z * InM.m[2][0] + InM.m[3][0] ;
戻り値.y = InV.x * InM.m[0][1] + InV.y * InM.m[1][1] + InV.z * InM.m[2][1] + InM.m[3][1] ;
戻り値.z = InV.x * InM.m[0][2] + InV.y * InM.m[1][2] + InV.z * InM.m[2][2] + InM.m[3][2] ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect をスケーリング行列を使用して 0.5f 倍します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // 0.5倍スケーリングを行う行列を作成
    Matrix = <b><a href="#R11N15">MGetScale</a></b>( VGet( 0.5f, 0.5f, 0.5f ) ) ;

    // 0.5倍スケーリングを行う行列を使用してベクトルのサイズを0.5倍した結果を Vect に代入する
    Vect = <b><a href="#R11N12">VTransform</a></b>( Vect, Matrix ) ;

    // Vect の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N13">宣言</a></b></td><td><font color="#000088"><b>VECTOR VTransformSR( VECTOR InV, MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>行列を使ったベクトルの変換( スケーリング＋回転成分のみ )<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR InV ： 変換処理を行いたいベクトル<br>
            MATRIX InM ： 変換処理に使用するベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換後のベクトル</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InV のベクトルを引数 InM の行列を使用して変換処理を行います。<br>
                    　計算的には InV を１ｘ４行列として扱い( 4つめの要素は 0.0f とします ) InM の行列の左から乗算した結果を返します。<br>
                    　<b><a href="#R11N12">VTransform</a></b> と違い InV を行列として見立てた際の第４要素が 0.0f なので
                    <b><a href="#R11N16">MGetTranslate</a></b> 等の第４要素の 1.0f と乗算することで平行移動を実現している効果が反映されません。<br>
<pre>
戻り値.x = InV.x * InM.m[0][0] + InV.y * InM.m[1][0] + InV.z * InM.m[2][0] ;
戻り値.y = InV.x * InM.m[0][1] + InV.y * InM.m[1][1] + InV.z * InM.m[2][1] ;
戻り値.z = InV.x * InM.m[0][2] + InV.y * InM.m[1][2] + InV.z * InM.m[2][2] ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　VECTOR 構造体 Vect をスケーリング行列を使用して 0.5f 倍します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VECTOR Vect ;
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Vect に値を代入
    Vect = <b><a href="#R11N1">VGet</a></b>( 100.0f, 200.0f, 500.0f ) ;

    // 0.5倍スケーリングを行う行列を作成
    Matrix = <b><a href="#R11N15">MGetScale</a></b>( VGet( 0.5f, 0.5f, 0.5f ) ) ;

    // 0.5倍スケーリングを行う行列を使用してベクトルのサイズを0.5倍した結果を Vect に代入する
    Vect = VTransformSR( Vect, Matrix ) ;

    // Vect の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Vect  x=%f y=%f z=%f", Vect.x, Vect.y, Vect.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N14">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetIdent( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>単位行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>単位行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　単位行列を戻り値として返してくる関数です。<br>
<pre>
戻り値行列
m[0][0]=1.0f m[0][1]=0.0f m[0][2]=0.0f m[0][3]=0.0f
m[1][0]=0.0f m[1][1]=1.0f m[1][2]=0.0f m[1][3]=0.0f
m[2][0]=0.0f m[2][1]=0.0f m[2][2]=1.0f m[2][3]=0.0f
m[3][0]=0.0f m[3][1]=0.0f m[3][2]=0.0f m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　単位行列を取得して画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 単位行列を Matrix に代入
    Matrix = MGetIdent() ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0,  0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 16, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N15">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetScale( VECTOR Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>拡大行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Scale ： 拡大値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>拡大行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 Scale で指定された拡大値で拡大する行列を戻り値として返してくる関数です。<br>
                    　拡大行列は <b><a href="#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 Scale で指定した分だけ拡大します。<br>
<pre>
戻り値行列
m[0][0]=Scale.x m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=Scale.z m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=Scale.z m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　拡大行列を取得してベクトルの拡大変換を行います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // 拡大行列を Matrix に代入
    Matrix = MGetScale( VGet( 2.0f, 5.0f, 8.0f ) ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "拡大行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N16">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetTranslate( VECTOR Trans ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>平行移動行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Trans ： 平行移動値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>平行移動行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 Trans で指定された平行移動を行う行列を戻り値として返してくる関数です。<br>
                    　平行移動行列は <b><a href="#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 Trans で指定した分だけ移動し( 値が加算され )ます。<br>
<pre>
戻り値行列
m[0][0]=1.0f    m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=1.0f    m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=1.0f    m[2][3]=0.0f
m[3][0]=Trans.x m[3][1]=Trans.y m[3][2]=Trans.z m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　平行移動行列を使用してベクトルの平行移動変換を行います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // 平行移動行列を Matrix に代入
    Matrix = <b><a href="#R11N16">MGetTranslate</a></b>( VGet( 100.0f, 80.0f, 85.0f ) ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "平行移動行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N17">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotX( float XAxisRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｘ軸回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float XAxisRotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Ｘ軸回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 XAxisRotate で指定された回転値分だけＸ軸回転する回転行列を戻り値として返してくる関数です。<br>
                    　Ｘ軸回転行列は <b><a href="#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 XAxisRotate で指定した分だけＸ軸回転します。<br>
<pre>
戻り値行列
float Sin, Cos ;
Sin = sin( XAxisRotate ) ;
Cos = cos( XAxisRotate ) ;
m[0][0]=1.0f    m[0][1]=0.0f    m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]= Cos    m[1][2]=Sin     m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=-Sin    m[2][2]=Cos     m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｘ軸回転行列を使用してベクトルのＸ軸回転を行います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // Ｘ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = <b><a href="#R11N17">MGetRotX</a></b>( DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｘ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N18">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotY( float YAxisRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｙ軸回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float YAxisRotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Ｙ軸回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 YAxisRotate で指定された回転値分だけＹ軸回転する回転行列を戻り値として返してくる関数です。<br>
                    　Ｙ軸回転行列は <b><a href="#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 YAxisRotate で指定した分だけＹ軸回転します。<br>
<pre>
戻り値行列
float Sin, Cos ;
Sin = sin( YAxisRotate ) ;
Cos = cos( YAxisRotate ) ;
m[0][0]=Cos     m[0][1]=0.0f    m[0][2]=-Sin    m[0][3]=0.0f
m[1][0]=0.0f    m[1][1]=1.0f    m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=Sin     m[2][1]=0.0f    m[2][2]= Cos    m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｙ軸回転行列を使用してベクトルのＹ軸回転を行います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // Ｙ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = <b><a href="#R11N18">MGetRotY</a></b>( DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N19">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotZ( float ZAxisRotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>Ｚ軸回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float ZAxisRotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>Ｚ軸回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 ZAxisRotate で指定された回転値分だけＺ軸回転する回転行列を戻り値として返してくる関数です。<br>
                    　Ｚ軸回転行列は <b><a href="#R11N12">VTransform</a></b> 関数でベクトルに対して変換を行うと、
                    変換対象のベクトルがこの関数の引数 ZAxisRotate で指定した分だけＺ軸回転します。<br>
<pre>
戻り値行列
float Sin, Cos ;
Sin = sin( ZAxisRotate ) ;
Cos = cos( ZAxisRotate ) ;
m[0][0]= Cos    m[0][1]=Sin     m[0][2]=0.0f    m[0][3]=0.0f
m[1][0]=-Sin    m[1][1]=Cos     m[1][2]=0.0f    m[1][3]=0.0f
m[2][0]=0.0f    m[2][1]=0.0f    m[2][2]=1.0f    m[2][3]=0.0f
m[3][0]=0.0f    m[3][1]=0.0f    m[3][2]=0.0f    m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｚ軸回転行列を使用してベクトルのＺ軸回転を行います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // Ｚ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = <b><a href="#R11N19">MGetRotZ</a></b>( DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｚ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N20">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotAxis( VECTOR RotateAxis, float Rotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定軸で指定角度回転する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR RotateAxis ： 回転軸
            float Rotate ： 回転値( 単位：ラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 RotateAxis を回転軸として、引数 Rotate で指定された回転値分だけ回転する回転行列を戻り値として返してくる関数です。<br>
                    　<b><a href="#R11N18">MGetRotY</a></b> や <b><a href="#R11N17">MGetRotX</a></b> はそれぞれ回転軸を Ｙ軸、Ｘ軸としていますが、
                    時には基本軸以外を軸として回転したい場合があります、この関数はそんなときに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　MGetRotAxis 関数を使用して敢えてＹ軸回転行列を作成します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 100.0f, 8.0f, 56.0f ) ;

    // MGetRotAxis を使用して敢えてＹ軸回転行列を Matrix に代入( 45度回転する行列 )
    Matrix = MGetRotAxis( VGet( 0.0f, 1.0f, 0.0f ), DX_PI_F / 4.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N21">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetRotVec2( VECTOR In1, VECTOR In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ある向きからある向きへ変換する回転行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR In1 ： ある向きのベクトル
            VECTOR In2 ： ある向きを変換後のベクトル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>回転行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 の向きを引数 In2 の向きに変換するような回転行列を戻り値として返してくる関数です。<br>
                    　ただ、元の向きから９０度以上回転する場合は期待した回転行列が得られない可能性があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　Ｘ軸のプラスの方向をＹ軸のマイナスの方向に回転する行列を取得する。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｘ軸のプラスの方向をＹ軸のマイナスの方向に回転する行列を取得する
    Matrix = MGetRotVec2( <b><a href="#R11N1">VGet</a></b>( 1.0f, 0.0f, 0.0f ), VGet( 0.0f, -1.0f, 0.0f ) ) ;

    // Ｘ軸に対してプラスの値を Vect1 に代入
    Vect1 = VGet( 80.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N22">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetAxis1( VECTOR XAxis, VECTOR YAxis, VECTOR ZAxis, VECTOR Pos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定の３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR XAxis ： 任意のＸ軸の基本軸上での方向<br>
            VECTOR YAxis ： 任意のＹ軸の基本軸上での方向<br>
            VECTOR ZAxis ： 任意のＺ軸の基本軸上での方向<br>
            VECTOR Pos ： 任意の３軸の基本軸上での原点
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　任意の３軸上のＸＹＺ値を基本軸上のＸＹＺ値に変換する行列を作成します。<br>
<pre>
戻り値行列
m[0][0]=XAxis.x m[0][1]=XAxis.y m[0][2]=XAxis.z m[0][3]=0.0f
m[1][0]=YAxis.x m[1][1]=YAxis.y m[1][2]=YAxis.z m[1][3]=0.0f
m[2][0]=ZAxis.x m[2][1]=ZAxis.y m[2][2]=ZAxis.z m[2][3]=0.0f
m[3][0]=Pos.x   m[3][1]=Pos.y   m[3][2]=Pos.z   m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　基本軸上のＹのプラス値をＸ軸<br>
            　　基本軸上のＺのプラス値をＹ軸<br>
            　　基本軸上のＸのマイナス値をＺ軸とし、<br>
            　　且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする<br>
            　　３軸上のベクトルを基本軸上のベクトルに変換する行列を取得する
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 基本軸上のＹのプラス値をＸ軸
    // 基本軸上のＺのプラス値をＹ軸
    // 基本軸上のＸのマイナス値をＺ軸とし、
    // 且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする
    // ３軸上のベクトルを基本軸上のベクトルに変換する行列の取得
    Matrix = MGetAxis1( 
                <b><a href="#R11N1">VGet</a></b>(  0.0f, 1.0f, 0.0f ),
                VGet(  0.0f, 0.0f, 1.0f ),
                VGet( -1.0f, 0.0f, 0.0f ),
                VGet( 100.0f, 0.0f, 200.0f ) ) ;

    // 上記軸上のＸ軸とＹ軸に対してプラスのベクトル Vect1 に代入
    Vect1 = VGet( 80.0f, 50.0f, 0.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "変換行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N23">宣言</a></b></td><td><font color="#000088"><b>MATRIX MGetAxis2( VECTOR XAxis, VECTOR YAxis, VECTOR ZAxis, VECTOR Pos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>基本軸上のベクトルを指定の３軸上のベクトルに変換する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR XAxis ： 任意のＸ軸の基本軸上での方向<br>
            VECTOR YAxis ： 任意のＹ軸の基本軸上での方向<br>
            VECTOR ZAxis ： 任意のＺ軸の基本軸上での方向<br>
            VECTOR Pos ： 任意の３軸の基本軸上での原点
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>変換行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　基本軸上のＸＹＺ値を任意の３軸上のＸＹＺ値に変換する行列を作成します。<br>
<pre>
戻り値行列
m[0][0]=XAxis.x m[0][1]=YAxis.x m[0][2]=ZAxis.x m[0][3]=0.0f
m[1][0]=XAxis.y m[1][1]=YAxis.y m[1][2]=ZAxis.y m[1][3]=0.0f
m[2][0]=XAxis.z m[2][1]=YAxis.z m[2][2]=ZAxis.z m[2][3]=0.0f
m[3][0]=-( Pos.x * XAxis.x + Pos.y * XAxis.y + Pos.z * XAxis.z )
m[3][1]=-( Pos.x * YAxis.x + Pos.y * YAxis.y + Pos.z * YAxis.z )
m[3][2]=-( Pos.x * ZAxis.x + Pos.y * ZAxis.y + Pos.z * ZAxis.z )
m[3][3]=1.0f
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　基本軸上のベクトルを<br>
            　　基本軸上のＹのプラス値をＸ軸<br>
            　　基本軸上のＺのプラス値をＹ軸<br>
            　　基本軸上のＸのマイナス値をＺ軸とし、<br>
            　　且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする<br>
            　　３軸上のベクトルに変換する行列を取得する
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 基本軸上のベクトルを
    // 基本軸上のＹのプラス値をＸ軸
    // 基本軸上のＺのプラス値をＹ軸
    // 基本軸上のＸのマイナス値をＺ軸とし、
    // 且つ基本軸上の x=100.0f y=0.0f z=200.0f を原点とする
    // ３軸上のベクトルに変換する行列の取得
    Matrix = MGetAxis2( 
                <b><a href="#R11N1">VGet</a></b>(  0.0f, 1.0f, 0.0f ),
                VGet(  0.0f, 0.0f, 1.0f ),
                VGet( -1.0f, 0.0f, 0.0f ),
                VGet( 100.0f, 0.0f, 200.0f ) ) ;

    // 任意の３軸上の原点に位置する基本軸上のベクトルを Vect に代入
    Vect1 = VGet( 100.0f, 0.0f, 200.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "変換行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 96, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 144, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N24">宣言</a></b></td><td><font color="#000088"><b>MATRIX MAdd( MATRIX In1, MATRIX In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの行列の足し算を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX In1 ： 足し算を行う行列１<br>
            MATRIX In2 ： 足し算を行う行列２<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>足し算を行った結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 で渡した行列の足し算を行い、
                    結果の行列を戻り値として返す関数です。<br>
                    　行列の足し算は行列の要素を単純に足すだけのものです。<br>
<pre>
戻り値行列
m[0][0] = In1.m[0][0] + In2.m[0][0]
m[0][1] = In1.m[0][1] + In2.m[0][1]
m[0][2] = In1.m[0][2] + In2.m[0][2]
m[0][3] = In1.m[0][3] + In2.m[0][3]

m[1][0] = In1.m[1][0] + In2.m[1][0]
m[1][1] = In1.m[1][1] + In2.m[1][1]
m[1][2] = In1.m[1][2] + In2.m[1][2]
m[1][3] = In1.m[1][3] + In2.m[1][3]

m[2][0] = In1.m[2][0] + In2.m[2][0]
m[2][1] = In1.m[2][1] + In2.m[2][1]
m[2][2] = In1.m[2][2] + In2.m[2][2]
m[2][3] = In1.m[2][3] + In2.m[2][3]

m[3][0] = In1.m[3][0] + In2.m[3][0]
m[3][1] = In1.m[3][1] + In2.m[3][1]
m[3][2] = In1.m[3][2] + In2.m[3][2]
m[3][3] = In1.m[3][3] + In2.m[3][3]
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルを０．８倍する行列と０．２倍する行列を足して、その行列を使用して<br>
            　ベクトルを変換します、０．８倍と０．２倍を足すと１．０倍なので、ベクトルは<br>
            　変換前と同じ値になります。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix1, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ０．８倍に拡大する行列と０．２倍に拡大する行列を Matrix1 と Matrix2 に代入
    Matrix1 = <b><a href="#R11N15">MGetScale</a></b>( <b><a href="#R11N1">VGet</a></b>( 0.8f, 0.8f, 0.8f ) ) ;
    Matrix2 = MGetScale( VGet( 0.2f, 0.2f, 0.2f ) ) ;

    // 二つの行列を足したものを Matrix に代入
    Matrix = MAdd( Matrix1, Matrix2 ) ;

    // 適当な値を Vect1 に代入
    Vect1 = VGet( 100.0f, 0.0f, 200.0f ) ;

    // Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix1 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "０．８倍行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

    // Matrix2 の値を画面に表示
    DrawString( 0, 96, "０．２倍行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "加算後の行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N25">宣言</a></b></td><td><font color="#000088"><b>MATRIX MMult( MATRIX In1, MATRIX In2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの行列の乗算を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX In1 ： 乗算する左側の行列<br>
            MATRIX In2 ： 乗算する右側の行列<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>乗算した結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 In1 と In2 を乗算した行列を結果の行列を戻り値として返す関数です。<br>
                    　行列と行列の乗算は複数の行列の効果を合成することができます。
                    ( 合成された行列は In1 → In2 の順で効果が現れます( 例：拡大行列と平行移動行列と乗算した場合、
                    その行列を使用して変換( <b><a href="#R11N12">VTransform</a></b> )したベクトルは拡大行列→平行移動行列の順で変換( VTransform )した場合と同じ結果になります ) )<br>
<pre>
戻り値行列
m[0][0] = In1.m[0][0] * In2.m[0][0] + In1.m[0][1] * In2.m[1][0] +
          In1.m[0][2] * In2.m[2][0] + In1.m[0][3] * In2.m[3][0] ;
m[0][1] = In1.m[0][0] * In2.m[0][1] + In1.m[0][1] * In2.m[1][1] +
          In1.m[0][2] * In2.m[2][1] + In1.m[0][3] * In2.m[3][1] ;
m[0][2] = In1.m[0][0] * In2.m[0][2] + In1.m[0][1] * In2.m[1][2] +
          In1.m[0][2] * In2.m[2][2] + In1.m[0][3] * In2.m[3][2] ;
m[0][3] = In1.m[0][0] * In2.m[0][3] + In1.m[0][1] * In2.m[1][3] +
          In1.m[0][2] * In2.m[2][3] + In1.m[0][3] * In2.m[3][3] ;

m[1][0] = In1.m[1][0] * In2.m[0][0] + In1.m[1][1] * In2.m[1][0] +
          In1.m[1][2] * In2.m[2][0] + In1.m[1][3] * In2.m[3][0] ;
m[1][1] = In1.m[1][0] * In2.m[0][1] + In1.m[1][1] * In2.m[1][1] +
          In1.m[1][2] * In2.m[2][1] + In1.m[1][3] * In2.m[3][1] ;
m[1][2] = In1.m[1][0] * In2.m[0][2] + In1.m[1][1] * In2.m[1][2] +
          In1.m[1][2] * In2.m[2][2] + In1.m[1][3] * In2.m[3][2] ;
m[1][3] = In1.m[1][0] * In2.m[0][3] + In1.m[1][1] * In2.m[1][3] +
          In1.m[1][2] * In2.m[2][3] + In1.m[1][3] * In2.m[3][3] ;

m[2][0] = In1.m[2][0] * In2.m[0][0] + In1.m[2][1] * In2.m[1][0] +
          In1.m[2][2] * In2.m[2][0] + In1.m[2][3] * In2.m[3][0] ;
m[2][1] = In1.m[2][0] * In2.m[0][1] + In1.m[2][1] * In2.m[1][1] +
          In1.m[2][2] * In2.m[2][1] + In1.m[2][3] * In2.m[3][1] ;
m[2][2] = In1.m[2][0] * In2.m[0][2] + In1.m[2][1] * In2.m[1][2] +
          In1.m[2][2] * In2.m[2][2] + In1.m[2][3] * In2.m[3][2] ;
m[2][3] = In1.m[2][0] * In2.m[0][3] + In1.m[2][1] * In2.m[1][3] +
          In1.m[2][2] * In2.m[2][3] + In1.m[2][3] * In2.m[3][3] ;

m[3][0] = In1.m[3][0] * In2.m[0][0] + In1.m[3][1] * In2.m[1][0] +
          In1.m[3][2] * In2.m[2][0] + In1.m[3][3] * In2.m[3][0] ;
m[3][1] = In1.m[3][0] * In2.m[0][1] + In1.m[3][1] * In2.m[1][1] +
          In1.m[3][2] * In2.m[2][1] + In1.m[3][3] * In2.m[3][1] ;
m[3][2] = In1.m[3][0] * In2.m[0][2] + In1.m[3][1] * In2.m[1][2] +
          In1.m[3][2] * In2.m[2][2] + In1.m[3][3] * In2.m[3][2] ;
m[3][3] = In1.m[3][0] * In2.m[0][3] + In1.m[3][1] * In2.m[1][3] +
          In1.m[3][2] * In2.m[2][3] + In1.m[3][3] * In2.m[3][3] ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルをＹ軸回転９０度する行列とＹ軸回転−９０度する２倍に拡大する行列を乗算して<br>
            　ベクトルに対してＹ軸回転行列→２倍拡大行列の順で <b><a href="#R11N12">VTransform</a></b> を使用した場合と同じ効果がある行列を作成します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix1, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｙ軸回転９０度する行列とＹ軸回転−９０度する行列を作成
    Matrix1 = <b><a href="#R11N18">MGetRotY</a></b>(  DX_PI_F / 2.0f ) ;
    Matrix2 = MGetRotY( -DX_PI_F / 2.0f ) ;

    // 二つの行列を０．５倍して加算したものを Matrix に代入
    Matrix = <b><a href="#R11N24">MAdd</a></b>( MScale( Matrix1, 0.5f ), MScale( Matrix2, 0.5f ) ) ;

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix1 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸９０度回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

    // Matrix2 の値を画面に表示
    DrawString( 0, 96, "Ｙ軸−９０度回転行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "乗算後の行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N26">宣言</a></b></td><td><font color="#000088"><b>MATRIX MScale( MATRIX InM, float Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>行列のスケーリングを行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX InM ： スケーリングする行列<br>
            float Scale ： スケーリング値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スケーリングした結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InM で渡された行列の各要素に Scale を乗算した行列を戻り値として返す関数です。<br>
<pre>
戻り値行列
m[0][0] = InM.m[0][0] * Scale ;
m[0][1] = InM.m[0][1] * Scale ;
m[0][2] = InM.m[0][2] * Scale ;
m[0][3] = InM.m[0][3] * Scale ;

m[1][0] = InM.m[1][0] * Scale ;
m[1][1] = InM.m[1][1] * Scale ;
m[1][2] = InM.m[1][2] * Scale ;
m[1][3] = InM.m[1][3] * Scale ;

m[2][0] = InM.m[2][0] * Scale ;
m[2][1] = InM.m[2][1] * Scale ;
m[2][2] = InM.m[2][2] * Scale ;
m[2][3] = InM.m[2][3] * Scale ;

m[3][0] = InM.m[3][0] * Scale ;
m[3][1] = InM.m[3][1] * Scale ;
m[3][2] = InM.m[3][2] * Scale ;
m[3][3] = InM.m[3][3] * Scale ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルをＹ軸回転９０度する行列とＸ軸回転９０度する行列をそれぞれ０．５倍して<br>
            　加算したものを作ります。<br>
            　　この行列はＹ軸回転９０度する行列を使用して <b><a href="#R11N12">VTransform</a></b> したベクトルと<br>
            　Ｘ軸回転９０度する行列を使用して VTransform したベクトルをそれぞれ０．５倍して<br>
            　加算したものと同じ結果が出力される行列となります。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix1, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｙ軸回転９０度する行列とＸ軸回転９０度する行列を作成
    Matrix1 = <b><a href="#R11N18">MGetRotY</a></b>( DX_PI_F / 2.0f ) ;
    Matrix2 = <b><a href="#R11N17">MGetRotX</a></b>( DX_PI_F / 2.0f ) ;

    // 二つの行列を０．５倍して加算したものを Matrix に代入
    Matrix = <b><a href="#R11N24">MAdd</a></b>( MScale( Matrix1, 0.5f ), MScale( Matrix2, 0.5f ) ) ;

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix3 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix1 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸９０度回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix1.m[0][0], Matrix1.m[0][1], Matrix1.m[0][2], Matrix1.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix1.m[1][0], Matrix1.m[1][1], Matrix1.m[1][2], Matrix1.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix1.m[2][0], Matrix1.m[2][1], Matrix1.m[2][2], Matrix1.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix1.m[3][0], Matrix1.m[3][1], Matrix1.m[3][2], Matrix1.m[3][3] ) ;

    // Matrix2 の値を画面に表示
    DrawString( 0, 96, "Ｘ軸９０度回転行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 112, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 128, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 144, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 160, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "乗算後の行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N27">宣言</a></b></td><td><font color="#000088"><b>MATRIX MTranspose( MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>転置行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX InM ： 転置する行列<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>転置した結果の行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InM で渡された行列を転置したものを戻り値として返す関数です。<br>
                    　転置行列とは行列要素の行と列を逆転したものです。<br>
                    　転置する行列が回転行列の場合は逆回転する行列となります。<br>
<pre>
戻り値行列
m[0][0] = InM.m[0][0] ;
m[0][1] = InM.m[1][0] ;
m[0][2] = InM.m[2][0] ;
m[0][3] = InM.m[3][0] ;

m[1][0] = InM.m[0][1] ;
m[1][1] = InM.m[1][1] ;
m[1][2] = InM.m[2][1] ;
m[1][3] = InM.m[3][1] ;

m[2][0] = InM.m[0][2] ;
m[2][1] = InM.m[1][2] ;
m[2][2] = InM.m[2][2] ;
m[2][3] = InM.m[3][2] ;

m[3][0] = InM.m[0][3] ;
m[3][1] = InM.m[1][3] ;
m[3][2] = InM.m[2][3] ;
m[3][3] = InM.m[3][3] ;
</pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ベクトルをＹ軸回転９０度する行列を転置した行列を使用してベクトルを回転します。<br>
            　　回転行列を転置した行列は逆回転( Ｙ軸回転−９０度 )する行列となります。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix2 ;
    VECTOR Vect1, Vect2 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // Ｙ軸回転９０度する行列を Matrix2 に代入
    Matrix2 = <b><a href="#R11N18">MGetRotY</a></b>( DX_PI_F / 2.0f ) ;

    // Matrix2 を転置した行列を Matrix に代入
    Matrix = MTranspose( Matrix2 ) ;

    // 適当な値を Vect1 に代入
    Vect1 = <b><a href="#R11N1">VGet</a></b>( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix ) ;

    // Matrix2 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "Ｙ軸９０度回転行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "転置行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "変換後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R11N28">宣言</a></b></td><td><font color="#000088"><b>MATRIX MInverse( MATRIX InM ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>逆行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MATRIX InM ： 逆行列を求める行列<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>InM の逆行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数 InM で渡された行列の逆行列を戻り値として返す関数です。<br>
                    　行列は左から乗算する場合と右から乗算する場合で結果が変化するのですが、
                    逆行列は元の行列で左から乗算する場合と同じ結果が右から乗算した場合に出る行列です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　平行移動する行列とその逆行列を用意して、適当な値を持ったベクトルが<br>
            　平行移動行列→その逆行列　の順で <b><a href="#R11N12">VTransform</a></b> すれば元の値に戻るかを試します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    MATRIX Matrix, Matrix2 ;
    VECTOR Vect1, Vect2, Vect3 ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 平行移動する行列を Matrix2 に代入
    Matrix2 = <b><a href="#R11N16">MGetTranslate</a></b>( <b><a href="#R11N1">VGet</a></b>( 200.0f, 100.0f, 80.0f ) ) ;

    // Matrix2 の逆行列を Matrix に代入
    Matrix = MInverse( Matrix2 ) ;

    // 適当な値を Vect1 に代入
    Vect1 = VGet( 200.0f, 0.0f, 0.0f ) ;

    // Vect1 を Matrix2 を使用して変換した値を Vect2 に代入
    Vect2 = <b><a href="#R11N12">VTransform</a></b>( Vect1, Matrix2 ) ;

    // Vect2 を Matrix2 の逆行列である Matrix で変換したものを Vect3 に代入
    Vect3 = VTransform( Vect2, Matrix ) ;

    // Matrix2 の値を画面に表示
    <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "平行移動行列", <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ) ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 16, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix2.m[0][0], Matrix2.m[0][1], Matrix2.m[0][2], Matrix2.m[0][3] ) ;

    DrawFormatString( 0, 32, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix2.m[1][0], Matrix2.m[1][1], Matrix2.m[1][2], Matrix2.m[1][3] ) ;

    DrawFormatString( 0, 48, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix2.m[2][0], Matrix2.m[2][1], Matrix2.m[2][2], Matrix2.m[2][3] ) ;

    DrawFormatString( 0, 64, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix2.m[3][0], Matrix2.m[3][1], Matrix2.m[3][2], Matrix2.m[3][3] ) ;

    // Matrix の値を画面に表示
    DrawString( 0, 192, "逆行列", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 208, GetColor( 255,255,255 ), "m00 %f  m01 %f  m02 %f  m03 %f",
        Matrix.m[0][0], Matrix.m[0][1], Matrix.m[0][2], Matrix.m[0][3] ) ;

    DrawFormatString( 0, 224, GetColor( 255,255,255 ), "m10 %f  m11 %f  m12 %f  m13 %f",
        Matrix.m[1][0], Matrix.m[1][1], Matrix.m[1][2], Matrix.m[1][3] ) ;

    DrawFormatString( 0, 240, GetColor( 255,255,255 ), "m20 %f  m21 %f  m22 %f  m23 %f",
        Matrix.m[2][0], Matrix.m[2][1], Matrix.m[2][2], Matrix.m[2][3] ) ;

    DrawFormatString( 0, 256, GetColor( 255,255,255 ), "m30 %f  m31 %f  m32 %f  m33 %f",
        Matrix.m[3][0], Matrix.m[3][1], Matrix.m[3][2], Matrix.m[3][3] ) ;

    // 変換元のベクトル値 Vect1 を画面に表示
    DrawString( 0, 288, "変換前のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 304, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect1.x, Vect1.y, Vect1.z ) ;

    // 変換後のベクトル値 Vect2 を画面に表示
    DrawString( 0, 336, "平行移動後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 352, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect2.x, Vect2.y, Vect2.z ) ;

    // 変換後のベクトル値 Vect3 を画面に表示
    DrawString( 0, 384, "逆行列乗算後のベクトル", GetColor( 255,255,255 ) ) ;
    DrawFormatString( 0, 400, GetColor( 255,255,255 ), "x=%f y=%f z=%f", Vect3.x, Vect3.y, Vect3.z ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>




        <tr><td><font size="3" color="#005500"><b>衝突検出系関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N1">宣言</a></b></td><td><font color="#000088"><b>float Segment_Segment_MinLength( VECTOR SegmentAPos1, VECTOR SegmentAPos2, VECTOR SegmentBPos1, VECTOR SegmentBPos2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>二つの線分の最近点間の距離を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SegmentAPos1 ： 二線分の片方の始点<br>
            VECTOR SegmentAPos2 ： 二線分の片方の終点<br>
            VECTOR SegmentBPos1 ： 二線分のもう片方の始点<br>
            VECTOR SegmentBPos2 ： 二線分のもう片方の終点
            <br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>二線分の最近点間の距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された二つの線分が最も近づく点( 最近点 )同士の距離を得ます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分を二つ定義して、片方の線分の終点を左右動かし、二線分の最近点間の距離が 64 以下になった際に<br>
            　線分の色を赤色にします。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd, length ;
    VECTOR LineA1, LineA2, LineB1, LineB2 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 二線分の座標をセット
    LineA1 = VGet( 0.0f, 0.0f, 0.0f ) ;
    LineA2 = VGet( 0.0f, 200.0f, 0.0f ) ;
    LineB1 = VGet( 320.0f, 480.0f, 0.0f ) ;
    LineB2 = VGet( 320.0f, 240.0f, 0.0f ) ;

    // 座標と加算数の初期化
    xadd = 8.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線分の片方の終点を移動
        LineA2.x += xadd ;
        if( LineA2.x &lt; 0.0f || LineA2.x &gt; 640.0f )
            xadd = -xadd ;

        // 二線分の最近点どうしの距離を求める
        length = Segment_Segment_MinLength( LineA1, LineA2, LineB1, LineB2 ) ;

        // 片方の線分の描画
        DrawLine( LineB1.x, LineB1.y, LineB2.x, LineB2.y, GetColor( 255,255,255 ) ) ;

        // もう一つの線分を距離が 64 以下だったら色を変えて描画
        if( length < 64.0f )
        {
            DrawLine( LineA1.x, LineA1.y, LineA2.x, LineA2.y, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawLine( LineA1.x, LineA1.y, LineA2.x, LineA2.y, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N2">宣言</a></b></td><td><font color="#000088"><b>float Segment_Triangle_MinLength( VECTOR SegmentPos1, VECTOR SegmentPos2, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>線分と三角形の最近点間の距離を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SegmentPos1 ： 線分の始点<br>
            VECTOR SegmentPos2 ： 線分の終点<br>
            VECTOR TrianglePos1 ： 三角形を形成する頂点１<br>
            VECTOR TrianglePos2 ： 三角形を形成する頂点２<br>
            VECTOR TrianglePos3 ： 三角形を形成する頂点３
            <br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>線分と三角形の最近点間の距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された線分と三角形が最も近づく点( 最近点 )同士の距離を得ます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分と三角形の座標を定義して、線分の終点を左右動かし、線分と三角形の最近点間の距離が 64 以下になった際に<br>
            　三角形の色を赤色にします。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd, length ;
    VECTOR Line1, Line2, Tri1, Tri2, Tri3 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 線分の座標と三角形を形成する３頂点の座標をセット
    Line1 = VGet( 0.0f, 0.0f, 0.0f ) ;
    Line2 = VGet( 0.0f, 400.0f, 0.0f ) ;
    Tri1 = VGet( 320.0f, 200.0f, 0.0f ) ;
    Tri2 = VGet( 280.0f, 260.0f, 0.0f ) ;
    Tri3 = VGet( 360.0f, 260.0f, 0.0f ) ;

    // 座標と加算数の初期化
    xadd = 8.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線分の終点を移動
        Line2.x += xadd ;
        if( Line2.x &lt; 0.0f || Line2.x &gt; 640.0f )
            xadd = -xadd ;

        // 線分と三角形の最近点間の距離を求める
        length = Segment_Triangle_MinLength( Line1, Line2, Tri1, Tri2, Tri3 ) ;

        // 線分の描画
        DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 255,255,255 ) ) ;

        // 三角形との距離が 64 以下だったら色を変えて描画
        if( length < 64.0f )
        {
            DrawTriangle( Tri1.x, Tri1.y, Tri2.x, Tri2.y, Tri3.x, Tri3.y,  GetColor( 255,0,0 ), TRUE ) ;
        }
        else
        {
            DrawTriangle( Tri1.x, Tri1.y, Tri2.x, Tri2.y, Tri3.x, Tri3.y,  GetColor( 0,255,0 ), TRUE ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N3">宣言</a></b></td><td><font color="#000088"><b>float Segment_Point_MinLength( VECTOR SegmentPos1, VECTOR SegmentPos2, VECTOR PointPos ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>線分と点の一番近い距離を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SegmentPos1 ： 線分の始点<br>
            VECTOR SegmentPos2 ： 線分の終点<br>
            VECTOR PointPos ： 点の座標
            <br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>線分と点が最も近づく座標間の距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された線分と点が最も近づく座標間の距離を得ます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分と点の座標を定義して、点の座標を上下に動かし、線分と点の最近点間の距離が 64 以下になった際に<br>
            　線分の色を赤色にします。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float yadd, length ;
    VECTOR Line1, Line2, Point ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 線分の座標と点の座標をセット
    Line1 = VGet( 0.0f, 0.0f, 0.0f ) ;
    Line2 = VGet( 640.0f, 480.0f, 0.0f ) ;
    Point = VGet( 320.0f, 0.0f, 0.0f ) ;

    // 座標と加算数の初期化
    yadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 点の座標を移動
        Point.y += yadd ;
        if( Point.y &lt; 0.0f || Point.y &gt; 480.0f )
            yadd = -yadd ;

        // 線分と点が最も近づく座標間の距離を求める
        length = Segment_Point_MinLength( Line1, Line2, Point ) ;

        // 点の描画
        DrawPixel( Point.x, Point.y, GetColor( 255,255,255 ) ) ;

        // 点との距離が 64 以下だったら色を変えて描画
        if( length < 64.0f )
        {
            DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N4">宣言</a></b></td><td><font color="#000088"><b>HITRESULT_LINE HitCheck_Line_Triangle( VECTOR LinePos1, VECTOR LinePos2, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>三角形と線分の当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR LinePos1 ： 線分の始点<br>
            VECTOR LinePos2 ： 線分の終点<br>
            VECTOR TrianglePos1 ： 三角形を形成する頂点１<br>
            VECTOR TrianglePos2 ： 三角形を形成する頂点２<br>
            VECTOR TrianglePos3 ： 三角形を形成する頂点３
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>衝突情報構造体 HITRESULT_LINE</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された線分と三角形が接触しているかどうかを判定して、
                    その結果を衝突情報構造体 HITRESULT_LINE で返してきます。<br><br>

                    HITRESULT_LINE 構造体は非常に単純な構造体でメンバ変数は以下の二つだけです。<br>
                    <pre>
                    // 接触しているかどうか( 1:接触している  0:接触していない )
                    int        HitFlag ;

                    // 接触した座標( HitFlag が 1 の場合のみ有効 )
                    VECTOR    Position ;
                    </pre>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　線分と三角形の座標を定義して、線分の終点を上下に動かしながら線分と三角形の当たり判定を行い<br>
            　三角形と接触した場合は線分の始点と接触点とを結ぶ線を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float yadd ;
    HITRESULT_LINE Result ;
    VECTOR Line1, Line2, Tri1, Tri2, Tri3 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 線分の座標と三角形の座標をセット
    Line1 = VGet( 0.0f, 240.0f, 0.0f ) ;
    Line2 = VGet( 640.0f, 240.0f, 0.0f ) ;
    Tri1 = VGet( 320.0f, 128.0f, 0.0f ) ;
    Tri2 = VGet( 320.0f, 240.0f, 200.0f ) ;
    Tri3 = VGet( 320.0f, 240.0f, -200.0f ) ;

    // 座標と加算数の初期化
    yadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線の終点座標を移動
        Line2.y += yadd ;
        if( Line2.y &lt; 0.0f || Line2.y &gt; 480.0f )
            yadd = -yadd ;

        // 線分と点が最も近づく座標間の距離を求める
        Result = HitCheck_Line_Triangle( Line1, Line2, Tri1, Tri2, Tri3 ) ;

        // 三角形を真横から見たときにできる線を描画
        DrawLine( Tri1.x, Tri1.y, Tri2.x, Tri2.y, GetColor( 255,255,255 ) ) ;

        // 三角形と接触していたら始点と接触点を結ぶ線を
        // そうでない場合は始点と終点を結ぶ線を描画する
        if( Result.HitFlag == 1 )
        {
            DrawLine( Line1.x, Line1.y, Result.Position.x, Result.Position.y, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawLine( Line1.x, Line1.y, Line2.x, Line2.y, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

<!--

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N5">宣言</a></b></td><td><font color="#000088"><b>int HitCheck_Sphere_Sphere( VECTOR Sphere1CenterPos, float Sphere1R, VECTOR Sphere2CenterPos, float Sphere2R ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>球と球の当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR Sphere1CenterPos ： 判定をする片方の球の中心座標<br>
            float Sphere1R ： 判定をする片方の球の半径<br>
            VECTOR Sphere2CenterPos ： 判定をするもう片方の球の中心座標<br>
            float Sphere2R ： 判定をするもう片方の球の半径<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：接触している　FALSE：接触していない</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された二つの球が接触しているかどうかを取得します。<br>
                    　接触している場合は TRUE が、接触していない場合は FALSE が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　球を二つ定義して、片方の球を左右に動かしながら当たり判定を行い、接触していた場合は片方の球の色を変えて描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd ;
    VECTOR SphereA, SphereB ;
    float SphereRA, SphereRB ;

    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 円の座標と半径をセットする
    SphereA = VGet( 0.0f, 200.0f, 0.0f ) ;
    SphereRA = 64.0f ;
    SphereB = VGet( 320.0f, 250.0f, 0.0f ) ;
    SphereRB = 48.0f ;

    // 座標と加算数の初期化
    xadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線の終点座標を移動
        SphereA.x += xadd ;
        if( SphereA.x &lt; 0.0f || SphereA.x &gt; 640.0f )
            xadd = -xadd ;

        // 片方の球を描画
        DrawCircle( SphereB.x, SphereB.y, SphereRB, GetColor( 255,255,255 ) ) ;

        // 二つの球が接触していたら描画色を変える
        if( HitCheck_Sphere_Sphere( SphereA, SphereRA, SphereB, SphereRB ) == TRUE )
        {
            DrawCircle( SphereA.x, SphereA.y, SphereRA, GetColor( 255,0,0 ) ) ;
        }
        else
        {
            DrawCircle( SphereA.x, SphereA.y, SphereRA, GetColor( 0,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R16N6">宣言</a></b></td><td><font color="#000088"><b>int HitCheck_Sphere_Triangle( VECTOR SphereCenterPos, float SphereR, VECTOR TrianglePos1, VECTOR TrianglePos2, VECTOR TrianglePos3 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>三角形と球の当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VECTOR SphereCenterPos ： 球の中心座標<br>
            float SphereR ： 球の半径<br>
            VECTOR TrianglePos1 ： 三角形を形成する頂点１<br>
            VECTOR TrianglePos2 ： 三角形を形成する頂点２<br>
            VECTOR TrianglePos3 ： 三角形を形成する頂点３
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：接触している　FALSE：接触していない</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　引数で渡された球と三角形が接触しているかどうかを取得します。<br>
                    　接触している場合は TRUE が、接触していない場合は FALSE が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　球と三角形を定義して、球を左右に動かしながら当たり判定を行い、接触していた場合は球の色を変えて描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    float xadd ;
    VECTOR Sphere, Tri1, Tri2, Tri3 ;
    float SphereR ;

    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 円の座標と半径をセットする
    Sphere = VGet( 0.0f, 200.0f, 0.0f ) ;
    SphereR = 64.0f ;

    // 三角形の座標をセットする
    Tri1 = VGet( 320.0f, 180.0f, 0.0f ) ;
    Tri2 = VGet( 220.0f, 380.0f, 0.0f ) ;
    Tri3 = VGet( 420.0f, 380.0f, 0.0f ) ;

    // 座標と加算数の初期化
    xadd = 4.0f ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 線の終点座標を移動
        Sphere.x += xadd ;
        if( Sphere.x &lt; 0.0f || Sphere.x &gt; 640.0f )
            xadd = -xadd ;

        // 三角形を描画する
        DrawTriangle( Tri1.x, Tri1.y, Tri2.x, Tri2.y, Tri3.x, Tri3.y, GetColor( 255,255,255 ), TRUE ) ;

        // 球と三角形が接触していたら球の描画色を変える
        if( HitCheck_Sphere_Triangle( Sphere, SphereR, Tri1, Tri2, Tri3 ) == TRUE )
        {
            DrawCircle( Sphere.x, Sphere.y, SphereR, GetColor( 255,0,0 ), TRUE ) ;
        }
        else
        {
            DrawCircle( Sphere.x, Sphere.y, SphereR, GetColor( 0,255,0 ), TRUE ) ;
        }

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>
    -->    
        







        <tr><td><font size="3" color="#005500"><b>モデルの読み込み・複製関係の関数</b><br><br></font></td></tr>

        <tr><td><table align="center" WIDTH=850 cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N1">宣言</a></b></td><td><font color="#000088"><b>int MV1LoadModel( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの読み込み<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            FileName ：　ロードする３Ｄモデルファイルのパス文字列のアドレス</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>−１　　　　：　エラー発生<br>
                    −１以外　：　モデルのハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄモデルファイルをメモリにロードします。<br>
                    ＤＸライブラリで３Ｄモデルを扱うときに必ず使用する関数です。<br>
                    　この関数が成功するとモデルハンドルというものが返ってきます。<br>
                    これはメモリに読み込んだ３Ｄモデルファイルの識別番号で int 型の数値です。<br>
                    　読み込んだモデルを扱う際にこの識別番号を使用することになりますので、
                    MV1LoadModel の戻り値は必ずなんらかの変数に格納しておく必要があります。<br><br>

                    例　　DxChara.x をロードして、戻り値であるモデルハンドルを<br>
                    　　int 型変数 MHandle に保存します<br><br>

<pre>
    int MHandle ;

    MHandle = MV1LoadModel( "DxChara.x" ) ;
</pre>
<br>
                    <font color="#660000"><b>読み込むことのできるモデルファイル形式は x, mqo, mv1, pmd( + vmd ), pmx( + vmd ) の４種類です。<br>
                    ( 但し、pmx は pmd 相当の機能だけを使用していた場合のみ正常に読み込める仮対応状態です )</b></font><br><br>

                    　尚、形状情報とアニメーション(アニメーション)情報はファイルの内容通りに読み込めますが、
                    マテリアル情報は各ファイル形式それぞれで異なる表現をしているものを無理矢理ＤＸライブラリのマテリアル表現で扱おうとするため、
                    大抵の場合モデリングソフト上とは異なった見た目になってしまいます。<br>
                    　なので、そのような場合はＤＸライブラリに合わせてモデルファイルのマテリアルを調整していただくか、
                    ＤＸライブラリの３Ｄツールでマテリアルを調整してからライブラリの専用形式である mv1 形式で保存して、そのファイルを使っていただくことになります。<br>

                    　また、モデルファイルで使用されているテクスチャはモデルファイルの中には含まれませんので、
                    モデルファイルで指定されているフォルダにテクスチャファイルを格納しておく必要があります。<br><br><br>


                    <font color="#660000"><b>MMD( MikuMikuDance )のモデルファイル( pmd or pmx )とモーションファイル( vmd )について。</b></font><br><br>

                    <b>＜対応度について＞</b><br><br>

                    　一応モーションの再生と取れに伴うＩＫ、物理演算に対応していますが、完全に本家 MikuMikuDance と同じというわけではありません。<br><br><br>

                    <b>＜読み込みについて＞</b><br><br>

                    　MikuMikuDance ではトゥーン用のテクスチャ( toon01.bmp 等 )はモデルファイル( pmd or pmx )が存在するテクスチャとは別のフォルダにあっても問題なく読み込むことが出来ますが、
                    ＤＸライブラリではトゥーン用のテクスチャもモデルファイル( pmd or pmx )と同じフォルダに格納しておく必要があります。( トゥーン用のデフォルトテクスチャは MikuMikuDance の Dataフォルダの中にあります ) <br><br>

                    　また、ＤＸライブラリでは MMD のモデルファイル形式( pmd or pmx )とモーションファイル形式( vmd )の読み込みに対応していますが、
                    モーションファイル( vmd )はモデルファイル( pmd or pmx )を読み込む際に一緒に読み込まれるようになっています。<br>
                    　ただ、MV1LoadModel にはモーションファイルのファイル名を渡す引数はありませんので、
                    次のようなルールでモデルファイル( pmd or pmx )用のモーションファイルを検索します。<br><br>

                    　１．モデルファイル名に３桁の番号がついたモーションファイルがあるか検索して、あったら読み込む<br>
                    　　　( 検索する番号は 000 から )<br><br>
                    　　　　　例えば、Miku.pmd ( 若しくは Miku.pmx ) というファイル名を FileName として渡した場合は、<br>
                    　　　　　最初に Miku000.vmd というモーションファイルが存在するか調べます。<br><br>

                    　２．検索する番号を000から順に１づつ増やしていき、存在しないファイル名になるまで読み込む<br><br>
                    　　　　　例えば、Miku000.vmd、Miku001.vmd、Miku002.vmd と数字の繋がった３つのモーションファイルが<br>
                    　　　　　あった場合は３つとも読み込まれます。<br>
                    　　　　　仮に Miku000.vmd, Miku001.vmd, Miku005.vmd のように、番号が途切れていたら、Miku000.vmd と<br>
                    　　　　　Miku001.vmd の二つだけ読み込まれ、Miku005.vmd は読み込まれません。<br><br>
                    
                    　尚、読み込み時にＩＫ計算を行いますので、xファイルやmv1ファイルに比べて読み込み時間が非常に長くなっています。<br><br><br>

                    <b>＜ループ再生するモーションについて＞</b><br><br>

                    　モーションの中には歩きや走りといったループさせて再生を行う用途のモーションがあると思います。<br><br>
                    　そのようなモーションの vmd ファイルは、＜読み込みについて＞の解説にあったファイル名の付け方にある３桁のモーションの番号の最後に半角の L をつけてください。<br><br>

                    例：Miku000.vmd 〜 Miku002.vmd の３つのファイルがあり、Miku000.vmd と Miku002.vmd が<br>
                    　　ループ再生用途のモーションの場合<br><br>
                    
                    　Miku000.vmd　Miku001.vmd　Miku002.vmd<br><br>
                    
                    　　　　　　　　　↓<br><br>
                    
                    　Miku000L.vmd　Miku001.vmd　Miku002L.vmd<br><br><br>


                    　L を付けることで関数 <b><a href="#R1N4">MV1SetLoadModelUsePhysicsMode</a></b> の設定が「読み込み時に物理演算を行う」 DX_LOADMODEL_PHYSICS_LOADCALC
                    となっている場合( デフォルトの設定は DX_LOADMODEL_PHYSICS_LOADCALC です
                    )の物理演算がループ再生用途のモーション用にモーションの最初と最後のフレームが綺麗に繋がり自然なループ再生ができるように処理されます。<br>
                    　逆にループ用途のモーションではないのに L を付けてしまうとモーションの最後の部分が変になってしまうので注意してください。<br>
                    　また、L を付けても物理演算によって動く部分の動きが激しいときはやっぱりループ時に不自然な見え方になってしまいますので、
                    その際はリアルタイム物理演算の設定である DX_LOADMODEL_PHYSICS_REALTIME をお使いください。<br><br><br>


                    <b>＜モーションの再生について＞</b><br><br>

                    　モーションの再生は他の形式と同じように <b><a href="#R4N1">MV1AttachAnim</a></b> を使用します( AnimIndex は vmd についている番号を指定します )<br>
                    　フレーム構造の違う他のモデルのモーションを使用する場合は MV1AttachAnim の NameCheck を TRUE にしてください。<br><br>

                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで画面に表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N2">宣言</a></b></td><td><font color="#000088"><b>int MV1DuplicateModel( int SrcMHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のモデルと同じ基礎データを使用してモデルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int SrcMHandle ：　作成するモデルの基礎データを持つモデルのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>−１　　　　：　エラー発生<br>
                    −１以外　：　モデルのハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SrcMHandle が持つ基礎モデルデータを使用してモデルを作成します。<br>
                　用途としては、たとえばアクションゲームの雑魚敵など、
                同じ見た目で大量に登場するキャラクターが居る場合、
                その数だけ <b><a href="#R1N1">MV1LoadModel</a></b> をしてしまうと同じ３Ｄモデルデータが幾つもメモリ上に存在することになり効率的ではありません( それに読み込み時間も掛かります )、
                なのでそんな場合にはキャラクターモデル一つに付き一回だけ MV1LoadModel で読み込んで、
                後は MV1LoadModel ではなく MV1DuplicateModel を使用してモデルハンドルを作成するようにすれば使用メモリ容量と読み込み時間を大幅に削減することができます。<br><br>

                　因みに画像ハンドルのように一つのモデルを使用して一体描画する度に位置や再生するアニメーションなどを切り替え、
                再度描画するといったことをすることでモデルハンドル一つで複数のキャラクターを表現することは可能ですが、
                ２Ｄの画像一枚と違い３Ｄモデルには色々な状態情報が含まれていますので、キャラクターの数だけモデルハンドルを作成したほうが速度的には有利です。<br><br>

                　なお、作成されるモデルハンドルには、SrcMHandle が示すモデルの座標値や回転値、
                アタッチしているアニメーションなど MV1LoadModel 以降に設定された情報は基本的に継承されません。
                ( 特別に継承される情報を変更する関数には、その関数の解説でその旨を記載しています )<br><br>
                <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んだあと、同じデータを使用するモデルハンドルを３つ作成し、
            それぞれ座標をずらして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle[ 4 ] ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle[ 0 ] = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 同じデータを使用するモデルハンドルを３つ作成する
    ModelHandle[ 1 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;
    ModelHandle[ 2 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;
    ModelHandle[ 3 ] = MV1DuplicateModel( ModelHandle[ 0 ] ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle[ 0 ], <b><a href="#R11N1">VGet</a></b>( -200.0f, -300.0f, 600.0f ) ) ;
    MV1SetPosition( ModelHandle[ 1 ], VGet(  150.0f, -300.0f, 600.0f ) ) ;
    MV1SetPosition( ModelHandle[ 2 ], VGet(  500.0f, -300.0f, 600.0f ) ) ;
    MV1SetPosition( ModelHandle[ 3 ], VGet(  850.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle[ 0 ] ) ;
    MV1DrawModel( ModelHandle[ 1 ] ) ;
    MV1DrawModel( ModelHandle[ 2 ] ) ;
    MV1DrawModel( ModelHandle[ 3 ] ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N3">宣言</a></b></td><td><font color="#000088"><b>int MV1DeleteModel( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　削除するモデルのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle で渡されたモデルハンドルが示すモデルをメモリ上から削除します。<br>
                    　用途はメモリの節約と、モデルハンドルの節約です。( モデルハンドルは最大で 65536 個までしか作れません )<br>
                    　使用しなくなったモデルハンドルをこの関数で削除せずに次々と新たなモデルを読み込んだり <b><a href="#R1N2">MV1DuplicateModel</a></b>
                    で複製したりすると何れメモリが足りなくなるかモデルハンドルの限界数に達するかをしてしまいますので、
                    使用しなくなったモデルハンドルはこの関数で削除するようにしてください。<br><br>
                    　因みに <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b> を呼ぶと作成されていたモデルは自動的に削除されますので、
                    DxLib_End の前に作成していたモデル全てに対して MV1DeleteModel をする必要はありません。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　DxChara.x を <b><a href="#R1N1">MV1LoadModel</a></b> で読み込んだ後、ひたすら MV1DuplicateModel でモデルを作成 → 描画 → MV1DeleteModel で削除を繰り返します。
            ( サンプルでは MV1DeleteModel を使うために無意味に作成と削除を繰り返していますが、移動して描画する度に削除と作成をしなければいけないわけではありません )<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, DupModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 何かボタンが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 読み込んだデータと同じデータを使用するモデルハンドルを作成する
        DupModelHandle = <b><a href="#R1N2">MV1DuplicateModel</a></b>( ModelHandle ) ;

        // 画面に映るランダムな位置に３Ｄモデルを移動
        <b><a href="#R3N2">MV1SetPosition</a></b>( DupModelHandle, <b><a href="#R11N1">VGet</a></b>( ( float )GetRand( 639 ), ( float )-GetRand( 300 ), GetRand( 300 ) + 300.0f ) ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( DupModelHandle ) ;

        // ３Ｄモデルの削除
        <b><a href="#R1N3">MV1DeleteModel</a></b>( DupModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N4">宣言</a></b></td><td><font color="#000088"><b>int MV1SetLoadModelUsePhysicsMode( int PhysicsMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>読み込むモデルの物理演算モードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int PhysicsMode ：　読み込むモデルに適用する物理演算モード<br>
            　　　　　DX_LOADMODEL_PHYSICS_LOADCALC　　ファイル読み込み時に物理演算を行う<br>
            　　　　　DX_LOADMODEL_PHYSICS_REALTIME　　　リアルタイム物理演算を行う<br>
            　　　　　DX_LOADMODEL_PHYSICS_DISABLE　　　　物理演算を使用しない<br>
            
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R1N1">MV1LoadModel</a></b> で読み込まれる３Ｄモデルに物理演算用の情報がある場合の処理を設定します。<br>
                    　物理演算用の情報がないモデルを読み込む場合はこの関数の設定は関係ありません。<br><br><br>


                    <b>DX_LOADMODEL_PHYSICS_LOADCALC</b>　　ファイル読み込み時に物理演算を行う（デフォルト）<br><br>

                    　　ファイル読み込み時にアニメーションを再生しながらの物理演算をシミュレーション(計算)して、<br>
                    　その結果をアニメーションに含めてしまいます。<br><br>

                    　　物理演算用情報を持ったモデル特有の処理をしなくても物理演算の恩恵を受けることができ、<br>
                    　処理負荷もアニメーションを再生しながら物理演算を行う DX_LOADMODEL_PHYSICS_REALTIME より<br>
                    　低くなりますが、シミュレーションは「その場に立ち止まった状態でアニメーションを再生した」ことを<br>
                    　前提として行われるため、見た目は DX_LOADMODEL_PHYSICS_REALTIME より不自然になります。<br><br><br>


                    <b>DX_LOADMODEL_PHYSICS_REALTIME</b>　　リアルタイム物理演算を行う<br><br>

                    　　DX_LOADMODEL_PHYSICS_LOADCALC と違いリアルタイムに物理演算を行います。<br>
                    　　リアルタイムに３Ｄモデルの挙動に即した物理演算が行われるため、<br>
                    　DX_LOADMODEL_PHYSICS_LOADCALC より自然な動きになります。<br><br>

                    　　ただ、代わりに <b><a href="#R3N4">MV1SetScale</a></b> によるスケーリングができないという点と、処理負荷が<br>
                    　DX_LOADMODEL_PHYSICS_LOADCALC より高いというデメリットがあります。<br><br>

                    　　リアルタイムの物理演算には通常の３Ｄモデルを扱う関数のほかに実際に物理演算を行う関数<br>
                    　MV1PhysicsCalculation と物理演算の状態をリセットする関数 MV1PhysicsResetState を使用します。<br><br>

                    　　尚、現時点では各モデル個別に物理演算を行うため、物理演算の情報を持つモデル同士の<br>
                    　衝突などには対応していません。<br><br><br>


                    <b>DX_LOADMODEL_PHYSICS_DISABLE</b>　　物理演算を使用しない<br><br>

                    　　物理演算用の情報が含まれる３Ｄモデルを読み込んだ際も物理演算用の情報が<br>
                    　ない３Ｄモデルとして扱います。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　リアルタイム物理演算モードで Test.pmd と Test000.vmd を <b><a href="#R1N1">MV1LoadModel</a></b> で読み込んで<br>
            リアルタイム物理演算を行いながらアニメーション０をループ再生します。<br>
            　尚、Test.pmd と Test000.vmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。<br>
            　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex ;
    float TotalTime, PlayTime ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 次に読み込むモデルの物理演算モードをリアルタイム物理演算にする
    MV1SetLoadModelUsePhysicsMode( DX_LOADMODEL_PHYSICS_REALTIME ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "Test.pmd" ) ;

    // 描画先を裏画面に変更
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // カメラに映る範囲( カメラからの距離の範囲 )を設定
    <b><a href="#R12N1">SetCameraNearFar</a></b>( 10.0f, 1000.0f ) ;

    // カメラの位置と向きを設定
    <b><a href="#R12N2">SetCameraPositionAndTarget_UpVecY</a></b>( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アタッチしたアニメーションの総再生時間を取得する
    TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

    // 物理演算の状態をリセット
    <b><a href="#R3N31">MV1PhysicsResetState</a></b>( ModelHandle ) ;

    // 再生時間の初期化
    PlayTime = 0.0f ;

    // 何かキーが押されるかウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // 再生時間を進める
        PlayTime += 0.5f ;

        // 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
        if( PlayTime >= TotalTime )
        {
            PlayTime = 0.0f ;

            // 再生時間をセットする
            <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;

            // モーションがループしたときに位置が移動することがあるので物理演算の状態をリセット
            <b><a href="#R3N31">MV1PhysicsResetState</a></b>( ModelHandle ) ;
        }
        else
        {
            // 再生時間をセットする
            <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;
        }

        // 物理演算を６０分の１秒経過したという設定で実行
        <b><a href="#R3N30">MV1PhysicsCalculation</a></b>( ModelHandle, 1000.0f / 60.0f ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R1N5">宣言</a></b></td><td><font color="#000088"><b>int MV1SetLoadModelPhysicsWorldGravity( float Gravity ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>読み込むモデルの物理演算に適用する重力パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            float Gravity : Ｙ軸方向の重力の強さ( デフォルト値：-122.5f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R1N1">MV1LoadModel</a></b> で読み込まれる３Ｄモデルに物理演算用の情報があり、且つ物理演算を行う場合に適用する重力のＹ軸方向の強さを設定します。<br>
                    　デフォルト値は -122.5f で、値をより低くすれば( マイナス方向に値を大きくすれば )重力は強くなり、高くすれば( プラス方向に値を大きくすれば )重力は小さくなります。<br>
                    　例えば値をプラスにすると空に向かって重力が働くことになります。<br><br>

                    　この関数は MV1LoadModel を呼び出す前に使用します。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br><br><br><br>
        </td></tr>
            


        <tr><td><font size="3" color="#005500"><b>モデル描画関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N1">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawModel( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを画面に描画します。<br>
                    　用途はモデルを画面に表示したい場合など・・・<br><br>
                    
                    　因みに、Ｚバッファを使用した現状の３Ｄレンダリングでは半透明の描画物は視点から最も離れているものから順に描画しないと正常な見た目になりませんので、
                    もし描画するモデルの中に半透明の部分が含まれている場合は視点からの距離を考慮した上で <b><a href="#R2N2">MV1DrawFrame</a></b> や <b><a href="#R2N3">MV1DrawMesh</a></b> で描画する必要があります。
                    ( ＤＸライブラリ自体にＺソートの機能はありません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<b><a href="#R1N1">MV1LoadModel</a></b> のサンプルを参考にして下さい。
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N2">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawFrame( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの指定のフレームを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル<br>
            int FrrameIndex ： 描画するフレームの番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル中の FrameIndex 番目のフレームが持つメッシュ( ポリゴンの集合 )を画面に描画します。
                    ( ＤＸライブラリではモデル中の階層構造を「フレーム」と呼称します。また、フレームの構造は基本的にモデルファイルの通りになります )<br>
                    　フレームにメッシュが含まれていない場合は何も描画されません。<br><br>

                    　用途としては、モデルの一部分のみを描画したい場合や、モデル中に半透明の部分がありパーツ単位で前後関係を考慮して描画しなければならない場合などに使用します。<br><br>

                    　尚、モデル中に何個フレームがあるかは <b><a href="#R6N1">MV1GetFrameNum</a></b> 関数で、各フレームの名前等はそれぞれの座標などは『<a href="#G14"><b>フレーム関係</b></a>』の関数を使用することで取得することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、２番目のフレームのみ画面に描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの２番目のフレームを描画
    <b><a href="#R2N2">MV1DrawFrame</a></b>( ModelHandle, 2 ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N3">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawMesh( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの指定のメッシュを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル<br>
            int MeshIndex ： 描画するメッシュの番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル中の MeshIndex 番目のメッシュを描画します。
                    ( ＤＸライブラリではポリゴンの集合のことを「メッシュ」と呼称します )<br>
                    　モデルの一部分を描画したい場合は <b><a href="#R2N2">MV1DrawFrame</a></b> 関数を使用しますが、この関数は「フレーム」より細かい単位の「メッシュ」で描画を行います。<br>
                    　用途は MV1DrawFrame と同じで、フレームより細かい単位で描画したい場合や、フレーム中の一部分のみ半透明のものがあり、前後関係を考慮した上で個別に描画したい場合などに使用します。<br><br>

                    　構造的には、メッシュは必ずどこかのフレームに所属していて、フレームが持つメッシュを全て描画するのが MV1DrawFrame 関数、その内の一つだけを描画するのが MV1DrawMesh 関数となります。<br><br>
                    　フレームに含まれるメッシュの数ははフレームに含まれるポリゴンに使用されているマテリアル( 材質 )の数と比例します。つまり、マテリアル毎にメッシュが分かれているというわけです。<br>
                    　なので、例えば「布」「金属」「革」といった３つのマテリアルを使用したフレームが存在した場合は、そのフレームが持つメッシュの数は３つになります。<br><br>

                    　モデル中に何個メッシュがあるかは <b><a href="#R7N1">MV1GetMeshNum</a></b> 関数で、各フレームに含まれるメッシュの数は <b><a href="#R6N27">MV1GetFrameMeshNum</a></b> 関数で、
                    各フレームに含まれるメッシュの識別番号は <b><a href="#R6N28">MV1GetFrameMesh</a></b> で取得することができます。<br>
                    　また、各メッシュの情報を取得したり設定したりする関数は『<a href="#G15"><b>メッシュ関係</b></a>』に一覧があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、０番目のメッシュを画面に描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のメッシュを描画
    <b><a href="#R2N3">MV1DrawMesh</a></b>( ModelHandle, 0 ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N4">宣言</a></b></td><td><font color="#000088"><b>int MV1DrawTriangleList( int MHandle, int TriangleListIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの指定のトライアングルリストを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ：　描画するモデルのハンドル<br>
            int TriangleListIndex ： 描画するトライアングルリストの番号</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル中の TriangleListIndex 番目のトライアングルリストを描画します。<br>
                    　「メッシュ」は一つ又は複数の「トライアングルリスト」から構成されています。<br>
                    　普通は一つのメッシュに含まれるトライアングルリスト( ３角形ポリゴンの塊 )は一つですが、
                    一度に処理できるポリゴンや頂点の数が限界を超えた場合や、種類の違うタイプの頂点が一つのメッシュに混在する場合などは複数のトライアングルリストが一つのメッシュ内に含まれることがあります。<br>
                    　普段３Ｄモデルを描画する際にメッシュ以上に細かい単位で描画することは無いのですが、
                    オリジナルのシェーダープログラムを使用してモデル描画を行う場合は頂点のタイプによって使用するシェーダープログラムを変更しなければならないので、
                    オリジナルのシェーダーを使用して、且つ複数種類の頂点が混合しているようなメッシュを描画する場合のみこの関数を使用します。
                    　つまり滅多に使用する機会はありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません
            <br><br><br><br><br>
        </td></tr>

        <tr><td><font size="3" color="#005500"><b>モデル描画設定関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R19N1">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseOrigShader( int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの描画にオリジナルシェーダープログラムを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int UseFlag ： オリジナルのシェーダーを使用するかどうかのフラグ<br>
            　　　　　　　　　　　( TRUE：使用する　　FALSE：使用しない )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R2N1">MV1DrawModel</a></b> や <b><a href="#R2N2">MV1DrawFrame</a></b> などのモデル描画関数を使用してモデルを描画する場合に関数
                    <b><a href="#R17N30">SetUseVertexShader</a></b>, <b><a href="#R17N31">SetUsePixelShader</a></b> で設定したシェーダーを使用するかどうかをこの関数で設定します。<br><br>

                    　TRUE を渡してこの関数を呼び出した場合は、SetUseVertexShader と SetUsePixelShader で設定したシェーダーで描画が行われます。<br>
                    　その際の頂点シェーダーに渡される頂点データの形式については <b><a href="#R17N2">LoadVertexShader</a></b> の解説を参照してください。<br><br>

                    　また、メッシュに含まれるトライアングルリストがどの頂点データ形式が頂点シェーダーに渡されるかは、以下のプログラムによって判断することができます。<br><br>
<hr>
<pre>
int MeshNo = 0 ;   // 任意のメッシュ
int TriangleListIndex  ;
int TriangleListDataType ;

// メッシュに含まれるトライアングルリスト番号 0 のモデル全体でのトライアングルリスト番号を取得
TriangleListIndex = MV1GetMeshTList( MeshNo, 0 ) ;

// トライアングルリストの頂点データタイプを取得
TriangleListDataType = MV1GetTriangleListVertexType( TriangleListIndex ) ;
</pre>
<hr>
<br>
                    　上記プログラムの結果、TriangleListDataType に代入された値が<br><br>

                    <b>DX_MV1_VERTEX_TYPE_1FRAME</b> の場合は<br>
                    　LoadVeretxShader の解説にある「剛体メッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_4FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１〜４個のスキニングメッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_8FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１〜８個のスキニングメッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_1FRAME</b> の場合は<br>
                    　「法線マップ付き剛体メッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_4FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１〜４個の法線マップ付きスキニングメッシュの場合」のデータ形式、<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_8FRAME</b> の場合は<br>
                    　「１頂点へ影響を与えるフレームの数が１〜８個の法線マップ付きスキニングメッシュの場合」のデータ形式、<br><br>

                    　となります。<br><br>

                    　また、<b><a href="#R17N29">SetUseTextureToShader</a></b> で特にテクスチャが設定されていない場合は３Ｄモデル描画時はデフォルトで<br><br>

                    StageIndex 0 にディフューズマップテクスチャが、<br>
                    StageIndex 1 に法線マップテクスチャが<br>
                    StageIndex 2 にスペキュラマップテクスチャが、<br>
                    StageIndex 3 にトゥーンレンダリング用のディフューズグラデーションテクスチャが、<br>
                    StageIndex 4 にトゥーンレンダリング用のスペキュラグラデーションテクスチャが、<br>
                    StageIndex 5 にトゥーンレンダリング用の数値飽和処理用のボリュームテクスチャが、<br>
                    StageIndex 6 にトゥーンレンダリング用のスフィアマップテクスチャが、<br><br>

                    　それぞれ存在する場合は設定されます。<br><br><br>


                    　尚、この関数で TRUE を設定したとしてもプログラムを実行するＰＣがプログラマブルシェーダーに対応していない場合はシェーダープログラムを使用しない描画になりますので注意してください。
                    ( プログラマブルシェーダーが使用できるかどうかは <b><a href="#R17N1">GetValidShaderVersion</a></b> で確認することができます )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　オリジナルシェーダーを利用した３Ｄモデルの描画サンプルや、デフォルトのシェーダー処理についての情報などは<br>
            　<a href="../program/dxprogram_3D.html"><b>こちら</b></a>をご参照ください。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R2N2">宣言</a></b></td><td><font color="#000088"><b>int MV1SetSemiTransDrawMode( int DrawMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの半透明要素がある部分についての描画モードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int DrawMode ：　モデルの半透明要素がある部分についての描画モード<br>
            　　　　　DX_SEMITRANSDRAWMODE_ALWAYS　　　　　： 半透明かどうか関係なく描画する( デフォルト )<br>
            　　　　　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY　　　： 半透明の部分のみ描画する<br>
            　　　　　DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY ： 半透明ではない部分のみ描画する<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　モデルの半透明要素がある部分についての描画モードを設定します。<br>
		    設定できるモードは以下の３つです。<br><br><br>

                    　DX_SEMITRANSDRAWMODE_ALWAYS<br><br>

                    　　半透明の要素があるかどうか関係なく必ず描画します。<br>
	            　　デフォルトではこのモードになっています。<br><br><br>


                    　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY<br><br>

	            　　半透明の要素がある部分のみ描画します。少しでも半透明の要素がある場合は描画され、<br>
		    　　半透明の要素が少しも無い場合は描画されません。<br><br><br>


                    　DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY<br><br>
	    
	            　　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY とは逆に半透明の要素が少しでもある部分は<br>
	            　　描画されないモードです。<br><br><br><br>

		    　この関数を呼んだ後の MV1DrawModel、MV1DrawFrame、MV1DrawMesh、MV1DrawTriangleList の呼び出しに影響を与えます。<br><br>

		    　この関数の用途ですが、主に「描画する全ての３Ｄモデルの半透明要素が無い部分のみ」を先に描画して、
		    その後に「描画する全ての３Ｄモデルの半透明要素がある部分のみ」を描画するために使用します。<br><br>

		    　何故先に「半透明要素が無い部分のみ」を描画する必要があるのかと言いますと、
		    それは３Ｄ描画の前後関係解決に使用されるＺバッファと半透明描画の相性の悪さにあります。<br><br>

		    　Ｚバッファは「３Ｄ描画を行った際の各ピクセルの奥行き」を記録しておき、
		    後から同じピクセルに対して３Ｄ描画された際に「前回の３Ｄ描画を行った際に記録しておいた奥行き」より
		    「後から行った３Ｄ描画の奥行き」の方が大きい( 奥にある )場合は描画せず、
		    小さい( 手前にある )場合は描画するという処理をしてくれるもので、３Ｄ描画にはとても便利(
		    ２Ｄ描画のように手前に表示したいものを後から描画しないといけない、といった前後関係を気にする必要が無くなる為 )
		    な機能なのですが、この機能は半透明描画とはとても相性が悪いのです。<br><br>

		    　例えば「半透明のもの」は本来「半透明のものより奥のもの」が透けて見えますが、
		    このＺバッファの機能を使用しながら「半透明のもの」を「半透明のものより奥にあるもの」より先に描画してしまうと、
		    「半透明のものより奥にあるもの」を後から描画してもＺバッファに「既にもっと手前に描画されたものがあるから描画しません」
		    と、本来なら「半透明のもの」が透けてその奥に見える筈の「半透明のものより奥にあるもの」が描画されないという事態を引き起こしてしまいます。<br><br>

		    　この問題を回避するには、以下の様な手順で描画を行う必要があります。<br><br><br>
		    
		    １．半透明要素が無いものを全て描画する<br><br>
		    
		    ２．半透明要素があるものを、奥のものから順番に描画する<br><br><br>

		    　まずＺバッファと相性の良い「半透明要素が無いもの」を先に全て描画してしまい
		    『半透明のものの奥にあるはずのものが表示されていない』という事態を回避します。<br><br>

		    　その次に、Ｚバッファと相性の悪い「半透明要素があるもの」を奥のものから順番に描画します。<br>
		    ( 前述の通り半透明のものはＺバッファを頼りにした前後関係の解決は望めないため )<br><br>

		    　これで正常な描画結果を得ることができます。<br><br>

		    　尚、「半透明要素があるもの」を奥のものから順番に描画しなかった場合に不都合が発生するのは<br><br>

		    『「半透明要素があるもの」同士が画面内で重なり、<br>
		    　且つ手前にある「半透明要素があるもの」が先に描画された場合』<br><br>
		    
		    なので、
		    「半透明要素があるもの」が少なく、滅多に「半透明要素があるもの」同士が画面内で重なることが無い、
		    重なっても一瞬で気付かない程度、という場合は「半透明要素があるもの」についても前後関係を無視して描画してしまうのもありです。
		    ( 奥のものから順番に描画するためのソート処理は負荷が高いことも多いので )<br><br>

		    　改めて MV1SetSemiTransDrawMode の用途ですが、上記の「半透明要素が無いものを先に全て描画する」
		    「半透明要素があるものを後から全て描画する」を実現するために使用します。<br><br>
		    
		    　「半透明要素が無いものを先に全て描画する」を行う場合は DrawMode に
		    DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY を渡して MV1SetSemiTransDrawMode を呼び出した後に全ての３Ｄモデルを MV1DrawModel で描画、<br><br>

		    　「半透明要素があるものを後から全て描画する」を行う場合は DrawMode に
		    　DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY を渡して MV1SetSemiTransDrawMode を呼び出した後に全ての３Ｄモデルを MV1DrawModel で描画します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　画面左側に通常の設定で半透明の３Ｄモデルと不透明の３Ｄモデルを描画、画面右側に解説にある<br>
	    　手順で同様に半透明の３Ｄモデルと不透明の３Ｄモデルを描画して結果を比較するサンプルです。<br>
            <hr>
<pre>
#include "DxLib.h"

#define CHARA_SPACE			(300.0f)
#define CHARA_X				(250.0f)

int CharaModelHandle ;

// キャラクターモデルの描画
void Chara_Draw( float x )
{
	int i ;

	// 手前から２体描画
	for( i = 0 ; i < 2 ; i ++ )
	{
		// 先頭のキャラを半透明にする
		MV1SetOpacityRate( CharaModelHandle, i == 0 ? 0.5f : 1.0f ) ;

		// 座標を設定
		MV1SetPosition( CharaModelHandle, VGet( x, 0.0f, i * CHARA_SPACE ) ) ;

		// モデルを描画
		MV1DrawModel( CharaModelHandle ) ;
	}
}

// WinMain関数
int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 400.0f, -700.0f ), VGet( 0.0f, 400.0f, 0.0f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 20.0f, 5000.0f );

	// 背景の色を灰色に変更
	SetBackgroundColor( 128,128,128 ) ;

	// 画面をクリア
	ClearDrawScreen() ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;

		// 通常の設定で画面左側にキャラクターを描画
		MV1SetSemiTransDrawMode( DX_SEMITRANSDRAWMODE_ALWAYS ) ;
		Chara_Draw( -CHARA_X ) ;

		// 画面右側に先に半透明要素の無い３Ｄモデルのみ描画する設定でキャラクターを描画した後、
		// 半透明要素のある３Ｄモデルのみ描画する設定でキャラクターを描画する
		MV1SetSemiTransDrawMode( DX_SEMITRANSDRAWMODE_NOT_SEMITRANS_ONLY ) ;
		Chara_Draw( CHARA_X ) ;

		MV1SetSemiTransDrawMode( DX_SEMITRANSDRAWMODE_SEMITRANS_ONLY ) ;
		Chara_Draw( CHARA_X ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br><br><br><br>
        </td></tr>



        <tr><td><font size="3" color="#005500"><b>モデル基本制御関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N2">宣言</a></b></td><td><font color="#000088"><b>int MV1SetPosition( int MHandle, VECTOR Position ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR Position ： モデルにセットする座標
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標をセットします。<br><br>

                    　グラフィックハンドルでは座標やスケールと言ったものは画像自体には保持せず <b><a href="dxfunc_graph1.html#R3N7">DrawGraph</a></b> や <b><a href="dxfunc_graph1.html#R3N9">DrawExtendGraph</a></b> などの描画関数を呼ぶ際に直接指定していましたが、
                    ３Ｄモデルは設定すべき情報が多く、項目の数に合わせて描画関数のバリエーションを増やしたらとんでもないことになってしまうので、
                    この <b><a href="#R3N2">MV1SetPosition</a></b> などの関数で描画を行う前に予め座標や回転値を設定するようになっています。<br><br>

                    　座標は VECTOR 型の構造体( float x, y, z をメンバ変数に持つ構造体 )が引数になっていて、
                    いちいち VECTOR 構造体を定義してメンバ変数に座標値を代入して、という手順を踏まなければならなくて面倒ですが、
                    x, y, z の値を引数で渡すと VECTOR 構造体を戻り値として返してくれる <b><a href="#R11N1">VGet</a></b> 関数を使用すれば面倒ではなくなります。<br><br>

<pre>
    // 普通に引数を渡そうとすると面倒・・・
    VECTOR Position ;

    Position.x = 0.0f ;
    Position.y = 400.0f ;
    Position.z = -600.0f ;
    MV1SetPosition( MHandle, Position ) ;

    -----------------------------------------------

    // VGet 関数を使用すれば簡単
    MV1SetPosition( MHandle, VGet( 0.0f, 400.0f, -600.0f ) ) ;
</pre>
                    <br><br>

                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

                　<b><a href="#R1N1">MV1LoadModel</a></b> のサンプルを参考にして下さい。
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N3">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetPosition( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの座標<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標を取得します。<br>
                    　<b><a href="#R3N2">MV1SetPosition</a></b> でセットした座標を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N4">宣言</a></b></td><td><font color="#000088"><b>int MV1SetScale( int MHandle, VECTOR Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの拡大値をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR Scale 　： 拡大値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの拡大値を設定します。<br>
                    　Scale で渡す VECTOR 構造体の各メンバ変数( x, y, z )の値を 2.0f にするとモデルが２倍の大きさに、逆に 0.5f 等にすると半分の大きさになります。
                    尚、マイナスの値を渡すと見た目が破綻します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、x軸方向に２倍に拡大して描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのスケールをx軸方向に２倍にする
    <b><a href="#R3N4">MV1SetScale</a></b>( ModelHandle, VGet( 2.0f, 1.0f, 1.0f ) ) ;

    // ３Ｄモデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N5">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの拡大値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの拡大値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの拡大値を取得します。<br>
                    　<b><a href="#R3N4">MV1SetScale </a></b>でセットした拡大値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N6">宣言</a></b></td><td><font color="#000088"><b>int MV1SetRotationXYZ( int MHandle, VECTOR Rotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの回転値をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR Rotate　　： 回転値( 単位はラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの回転値を設定します。<br>
                    　Rotate で渡す VECTOR 構造体の各メンバ変数( x, y, z )の値はそれぞれ x軸回転値、y軸回転値、z軸回転値を代入しておきます。
                    ( 回転値の単位はラジアンですので、度数単位の値を代入する場合は　度 * DX_PI_F / 180.0f　の計算をしてください )<br><br>

                    　キャラクターモデルの向いている方向を設定する場合は y軸回転を使用します。<br><br>

                    　尚、回転の順番は x軸回転 → y軸回転 → z軸回転 です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、y軸を回転軸として９０度回転して描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３ＤモデルのY軸の回転値を９０度にセットする
    <b><a href="#R3N6">MV1SetRotationXYZ</a></b>( ModelHandle, VGet( 0.0f, 90.0f * DX_PI_F / 180.0f, 0.0f ) ) ;

    // ３Ｄモデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N7">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetRotationXYZ( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの回転値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの回転値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの回転値を取得します。<br>
                    　<b><a href="#R3N6">MV1SetRotationXYZ</a></b> でセットした回転値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N8">宣言</a></b></td><td><font color="#000088"><b>int MV1SetRotationZYAxis( int MHandle, VECTOR ZAxis, VECTOR YAxis, float ZTwist ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのＺ軸とＹ軸の方向をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            VECTOR ZAxis ： Ｚ軸の方向<br>
            VECTOR YAxis ： Ｙ軸の方向<br>
            float　　　ZTwist ： ZAxis を回転軸とした回転値( 単位はラジアン )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの回転値をＺ軸の方向、Ｙ軸の方向と、ZAxis で指定した方向を軸とした回転値で設定します。
                    ( ZAxis, YAxis は正規化されている必要はありません )<br><br>

                    　この関数は何かのモデルをある方向に向けたい場合などに使用します。( 砲台を敵の方向に向けるなど )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、モデルのz軸の方向を画面左上の方に向けて描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 0.0f, 600.0f ) ) ;

    // ３ＤモデルのＺ軸を画面左上方向に向ける
    // ( DxChara.x はＺ軸のマイナス方向に向いているので右下方向に傾きます )
    MV1SetRotationZYAxis( ModelHandle, VGet( -0.5f, 0.5f, 0.0f ), VGet( 0.5f, 0.5f, 0.0f ), 0.0f ) ;

    // ３Ｄモデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N11">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMatrix( int MHandle, MATRIX Matrix ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標変換用行列をセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　MHandle ： モデルのハンドル<br>
            MATRIX Matrix ： 座標変換用行列
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標変換用行列をセットします。<br><br>

                    　この関数は <b><a href="#R3N2">MV1SetPosition</a></b> 関数や <b><a href="#R3N4">MV1SetScale</a></b> や <b><a href="#R3N6">MV1SetRotationXYZ</a></b>関数などの代わりに行列を使用してローカル → ワールド座標変換を行いたい場合に使用します。<br><br>
                    　この関数に単位行列以外の行列を渡すと、以後 MV1SetPosition や MV1SetScale 等の関数の設定は無視され、
                    MV1SetMatrix 関数で設定した行列のみを使用してローカル → ワールド座標変換が行われるようになります。
                    ( 解除する場合は MV1SetMatrix 関数に単位行列を渡します )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで、拡大率を２倍にしてから座標をカメラの写る位置に移動するということを行列を使用して設定した後に描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ２倍に拡大した後画面に映る位置に３Ｄモデルを移動する行列のセット
    MV1SetMatrix( ModelHandle, <b><a href="#R11N25">MMult</a></b>( <b><a href="#R11N15">MGetScale</a></b>( <b><a href="#R11N1">VGet</a></b>( 2.0f, 2.0f, 2.0f ) ), <b><a href="#R11N16">MGetTranslate</a></b>( VGet( 320.0f, -600.0f, 600.0f ) ) ) ) ;

    // ３Ｄモデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N12">宣言</a></b></td><td><font color="#000088"><b>MATRIX MV1GetMatrix( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの座標変換用行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルの座標変換用行列<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの座標変換用行列を取得します。<br>
                    　事前に <b><a href="#R3N11">MV1SetMatrix</a></b> で行列を設定していた場合はその値が、
                    設定していなかった場合は <b><a href="#R3N2">MV1SetPosition</a></b> や <b><a href="#R3N4">MV1SetScale</a></b> 等の関数で設定した値の結果( 行列 )が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を読み込んで複製した後、最初に読み込んだモデルハンドルの方に座標位置変更や拡大率の設定を行い、
            その結果の行列を複製したモデルに設定して描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, SubModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ModelHandle と同じモデルを使用するモデルの作成
    SubModelHandle = <b><a href="#R1N2">MV1DuplicateModel</a></b>( ModelHandle ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 0.0f, 600.0f ) ) ;

    // ３Ｄモデルの拡大率を０．５倍にする
    <b><a href="#R3N4">MV1SetScale</a></b>( ModelHandle, VGet( 0.5f, 0.5f, 0.5f ) ) ;

    // ModelHandle に設定した座標変換パラメータの結果の行列を SubModelHandle の座標変換行列として設定する
    MV1SetMatrix( SubModelHandle, MV1GetMatrix( ModelHandle ) ) ;

    // SubModelHandle の方の３Ｄモデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( SubModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N13">宣言</a></b></td><td><font color="#000088"><b>int MV1SetVisible( int MHandle, int VisibleFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画するかどうかを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int VisibleFlag ： 描画するかどうか( TRUE：表示する  FALSE：表示しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画するかどうかを設定します。<br>
                    　この関数で描画しない設定にすると、以後 <b><a href="#R2N1">MV1DrawModel</a></b> 等の描画関数を使用しても描画されなくなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x を <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b> が返す値が奇数秒の時だけ描画する。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // 何かキーが押されるかウインドウが閉じられるまでループする
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリアする
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルをカウンタが奇数秒の時は描画して、偶数表のときは描画しないようにする
        if( <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b>() % 2000 < 1000 )
        {
            MV1SetVisible( ModelHandle, TRUE ) ;
        }
        else
        {
            MV1SetVisible( ModelHandle, FALSE ) ;
        }

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N14">宣言</a></b></td><td><font color="#000088"><b>int MV1GetVisible( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画するかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　TRUE：モデルを描画する  FALSE：モデルを描画しない</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画するかどうかの設定値を取得します。<br>
                    　<b><a href="#R3N13">MV1SetVisible</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N15">宣言</a></b></td><td><font color="#000088"><b>int MV1SetDifColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのディフューズカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f 〜 1.0f = 0% 〜 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのディフューズカラー( 拡散光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のディフューズカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途としては選択されているモデルの表現や、簡単な色違い表現などがあります。<br><br>

                    　因みに引数の COLOR_F は float r, g, b, a を持つ構造体です。<br>
                    これの実体を定義してメンバ変数に値を代入して引数に渡す、と言うことをすると非常に面倒なので、
                    引数に r, g, b, a の値を渡すと COLOR_F 構造体を戻り値として返す関数 <b><a href="#R14N14">GetColorF</a></b> を使用すると便利です。<br><br>
<pre>
// ディフューズカラーの赤成分を５０％にする
MV1SetDifColorScale( ModelHandle, GetColorF( 0.5f, 1.0f, 1.0f, 1.0f ) ) ;
</pre>

                    <br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のディフューズカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのディフューズカラーの緑成分と青成分を０％にする
    <b><a href="#R3N15">MV1SetDifColorScale</a></b>( ModelHandle, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N16">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetDifColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのディフューズカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ディフューズカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのディフューズカラーに適用するスケール値を取得します。<br>
                    　<b><a href="#R3N15">MV1SetDifColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N17">宣言</a></b></td><td><font color="#000088"><b>int MV1SetSpcColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのスペキュラカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f 〜 1.0f = 0% 〜 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのスペキュラカラー( 反射光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のスペキュラカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途としては光沢があるオブジェクトの光沢の色を変化させたり、光沢を無くしたりすることができます。<br><br>

                    　因みに、モデルのマテリアルに設定されているスペキュラカラー値に対するスケールなので、
                    設定対象のモデルのマテリアルに元々スペキュラカラー成分が無い場合( スペキュラカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のスペキュラカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのスペキュラカラーの緑成分と青成分を０％にする
    MV1SetSpcColorScale( ModelHandle, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N18">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetSpcColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのスペキュラカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのスペキュラカラーに適用するスケール値を取得します。<br>
                    　<b><a href="#R3N17">MV1SetSpcColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N19">宣言</a></b></td><td><font color="#000088"><b>int MV1SetEmiColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのエミッシブカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f 〜 1.0f = 0% 〜 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのエミッシブカラー( 自己発光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のエミッシブカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途としては自己発光しているオブジェクトの自己発光を止めたり、自己発光の色を変化させたりすることができます。<br><br>

                    　因みに、モデルのマテリアルに設定されているエミッシブカラー値に対するスケールなので、
                    設定対象のモデルのマテリアルに元々エミッシブカラー成分が無い場合( エミッシブカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のエミッシブカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのエミッシブカラーの緑成分と青成分を０％にする
    MV1SetEmiColorScale( ModelHandle, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N20">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetEmiColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのエミッシブカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>エミッシブカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのエミッシブカラーに適用するスケール値を取得します。<br>
                    　<b><a href="#R3N19">MV1SetEmiColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N21">宣言</a></b></td><td><font color="#000088"><b>int MV1SetAmbColorScale( int MHandle, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのアンビエントカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int　　　　　MHandle ： モデルのハンドル<br>
            COLOR_F Scale　　： カラースケール値( 0.0f 〜 1.0f = 0% 〜 100% )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルのマテリアルのアンビエントカラー( 環境光色 )のスケール値を設定します。<br><br>
                    　例えばこの関数の引数で渡す Scale の 赤、緑、青、α成分の内の 緑とα成分を 1.0f、他を 0.0f にして呼ぶと、
                    モデル描画時にマテリアル中のアンビエントカラーの緑成分とα成分以外が 0.0f として描画されます。<br><br>

                    　用途はあまり思いつきませんが、環境光の影響を受けたり受けなかったりを変化させることができます。<br><br>

                    　因みに、モデルのマテリアルに設定されているアンビエントカラー値に対するスケールなので、
                    設定対象のモデルのマテリアルに元々アンビエントカラー成分が無い場合( アンビエントカラー成分 r, g, b, a が 0.0f の場合 )はスケール値を何にしても見た目の変化はありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x のアンビエントカラーの緑成分と青成分を０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルのアンビエントカラーの緑成分と青成分を０％にする
    MV1SetAmbColorScale( ModelHandle, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N22">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetAmbColorScale( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルのアンビエントカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アンビエントカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルを描画する際にマテリアルのアンビエントカラーに適用するスケール値を取得します。<br>
                    　<b><a href="#R3N21">MV1SetAmbColorScale</a></b> でセットした設定値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N23">宣言</a></b></td><td><font color="#000088"><b>int MV1GetSemiTransState( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルに半透明要素があるかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：半透明要素がある　FALSE：半透明要素は無い</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに半透明の要素があるかどうかを取得します。<br><br>

                    　例えば、モデル中のどれかのマテリアルのテクスチャに半透明の部分があったり、
                    モデル中のどれかのフレームの不透明度が 1.0f ではなかったりすると TRUE が返ってきます。<br><br>

                    　半透明要素を持つモデルをＺソートする場合に、各モデルに半透明要素があるかどうかを判定する際などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の不透明度を上下キーで操作できるようにした上で、
              画面上に MV1GetSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float OpacityRate ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // 不透明度を初期化
    OpacityRate = 1.0f ;

    // ESCキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面のクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 上キーが押されたら不透明度を上げる
        if( CheckHitKey( KEY_INPUT_UP ) )
        {
            OpacityRate += 0.05f ;
            if( OpacityRate > 1.0f )
            {
                OpacityRate = 1.0f ;
            }
        }

        // 下キーが押されたら不透明度を下げる
        if( CheckHitKey( KEY_INPUT_DOWN ) )
        {
            OpacityRate -= 0.05f ;
            if( OpacityRate < 0.0f )
            {
                OpacityRate = 0.0f ;
            }
        }

        // ３Ｄモデルの不透明度を設定する
        <b><a href="#R3N24">MV1SetOpacityRate</a></b>( ModelHandle, OpacityRate ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 現在の不透明度と、MV1GetSemiTransState の戻り値を描画する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),
            "ESC Key:Exit OpacityRate:%f SemiTransState:%d",
            OpacityRate, MV1GetSemiTransState( ModelHandle ) ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

            
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N24">宣言</a></b></td><td><font color="#000088"><b>int MV1SetOpacityRate( int MHandle, float Rate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの不透明度を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            float Rate ： 不透明度( 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの不透明度を設定します。<br><br>

                    　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、
                    1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。<br><br>
                
                    　モデルを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の不透明度を５０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの不透明度を50%にする
    MV1SetOpacityRate( ModelHandle, 0.5f ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N25">宣言</a></b></td><td><font color="#000088"><b>float MV1GetOpacityRate( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの不透明度を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>モデルに設定されている不透明度<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに設定されている不透明度を取得します。<br>
                    　<b><a href="#R3N24">MV1SetOpacityRate</a></b> でセットした値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N26">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseZBuffer( int MHandle, int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画する際にＺバッファを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int Flag ： Ｚバッファを使用するかどうかのフラグ<br>
            　　　　　　( TRUE：使用する( 初期設定 )  FALSE：使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際にＺバッファを使用するかどうかを設定します。<br><br>
                    
                    　<b><a href="#R14N12">SetUseZBuffer3D</a></b> のモデル用の関数で、
                    効果は SetUseZBuffer3D と全く同じです。
                    ( Ｚバッファの詳しい説明は SetUseZBuffer3D 関数の解説に記述してあります )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N27">宣言</a></b></td><td><font color="#000088"><b>int MV1SetWriteZBuffer( int MHandle, int Flag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルを描画する際にＺバッファを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int Flag ： Ｚバッファに書き込みを行うかどうかのフラグ<br>
            　　　　　　( TRUE：書き込む( 初期設定 )  FALSE：書き込まない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際にＺバッファを使用するかどうかを設定します。<br><br>
                    
                    　<b><a href="#R14N13">SetWriteZBuffer3D</a></b> のモデル用の関数で、
                    効果は SetWriteZBuffer3D と全く同じです。
                    ( Ｚバッファの詳しい説明は <b><a href="#R14N12">SetUseZBuffer3D</a></b> 関数の解説に記述してあります )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N28">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseVertDifColor( int MHandle, int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデル描画のライティング計算に頂点データのディフューズカラーを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int UseFlag ： 頂点データのディフューズカラーを使用するかどうか<br>
            　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際のライティング計算に頂点データのディフューズカラーをマテリアルのディフューズカラーとして使用するかどうかを設定します。( 初期設定では使用しません )<br><br>
                    
                    　この関数で頂点ディフューズカラーを使用する設定にした場合はマテリアルのディフューズカラー設定は無視され、
                    代わりに頂点ディフューズカラーが使用されます。<br><br>

                    　尚、ライティング計算を <b><a href="#R13N44">SetUseLighting</a></b> 関数で無効にした場合はこの関数の設定に関係なくマテリアルのディフューズカラーは無視され、頂点ディフューズカラーが使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N27">MV1SetMeshUseVertDifColor関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N29">宣言</a></b></td><td><font color="#000088"><b>int MV1SetUseVertSpcColor( int MHandle, int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデル描画のライティング計算に頂点データのスペキュラカラーを使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int UseFlag ： 頂点データのスペキュラカラーを使用するかどうか<br>
            　　　　　　　　( TRUE=使用する( デフォルト )　　FALSE=使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルを描画する際のライティング計算に頂点データのスペキュラカラーをマテリアルのスペキュラカラーとして使用するかどうかを設定します。( 初期設定では使用しません )<br><br>
                    
                    　この関数で頂点スペキュラカラーを使用する設定にした場合はマテリアルのスペキュラカラー設定は無視され、
                    代わりに頂点スペキュラカラーが使用されます。<br><br>

                    　尚、ライティング計算を <b><a href="#R13N44">SetUseLighting</a></b> 関数で無効にした場合はこの関数の設定に関係なくマテリアルのスペキュラカラーは無視され、頂点スペキュラカラーが使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N30">宣言</a></b></td><td><font color="#000088"><b>int MV1PhysicsCalculation( int MHandle, float MillisecondTime ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの物理演算を指定時間分経過したと仮定して計算する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle　　　　　 ： モデルのハンドル<br>
            float MillisecondTime ： 経過時間( 単位：ミリ秒 )<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　関数 <b><a href="#R1N4">MV1SetLoadModelUsePhysicsMode</a></b>を使用して読み込む３Ｄモデルに対してリアルタイム物理演算を行うように指定した上で、
                物理演算用の情報を持つ３Ｄモデルを関数 <b><a href="#R1N1">MV1LoadModel</a></b>
                    で読み込んだ場合に、この関数を使用して実際の物理演算を行います。<br><br>

                    　引数の MillisecondTime で経過したと仮定する時間を指定します。<br>
                    　単位はミリ秒( １秒は 1000.0fミリ秒 )です、通常のゲームは１秒間に６０回、
                    若しくは３０回画面が更新されるので、これに基づいて引数を指定する場合は<br><br>

                    １秒間に６０回の場合は１回に 1000.0f ミリ秒の６０分の１分だけ処理するので<br><br>

                    　　1000.0f / 60.0f = 16.66667f<br><br>

                    １秒間に３０回の場合は１回に 1000.0f ミリ秒の３０分の１分だけ処理するので<br><br>

                    　　1000.0f / 30.0f = 33.33333f<br><br>

                    となります。<br><br>

                    　この関数の結果はモデルの位置や姿勢を変更する関数( <b><a href="#R3N2">MV1SetPosition</a></b> や <b><a href="#R3N6">MV1SetRotationXYZ</a></b>、<b><a href="#R3N11">MV1SetMatrix</a></b>、<b><a href="#R4N1">MV1AttachAnim</a></b>、<b><a href="#R4N3">MV1SetAttachAnimTime</a></b>
                    )を使用すると無効になってしまいますので、物理演算の結果を描画する場合は必ず<br><br>

                    　<b>MV1SetPosition や MV1SetRotationXYZ、MV1SetAttachAnimTime などの関数で姿勢を決定した後</b><br><br>
                    
                    に、この関数を実行するようにしてください。<br><br>

                    ＜注意＞<br>
                    リアルタイム物理演算を使用する場合は <b><a href="#R3N4">MV1SetScale</a></b> によるスケーリングを行うと正常な演算結果が得られなくなりますので MV1SetScale を使用する場合はリアルタイム物理演算は行わないでください。<br><br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　リアルタイム物理演算モードで Test.pmd を <b><a href="#R1N1">MV1LoadModel</a></b> で読み込んで<br>
            リアルタイム物理演算を行いながらキーボードの上下左右でモデルの位置を移動します。<br>
            　尚、Test.pmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。<br>
            　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int PosX, PosZ, PosY ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 次に読み込むモデルの物理演算モードをリアルタイム物理演算にする
    <b><a href="#R1N4">MV1SetLoadModelUsePhysicsMode</a></b>( DX_LOADMODEL_PHYSICS_REALTIME ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "Test.pmd" ) ;

    // 描画先を裏画面に変更
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // カメラに映る範囲( カメラからの距離の範囲 )を設定
    <b><a href="#R12N1">SetCameraNearFar</a></b>( 10.0f, 1000.0f ) ;

    // カメラの位置と向きを設定
    <b><a href="#R12N2">SetCameraPositionAndTarget_UpVecY</a></b>( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

    // 座標をリセット
    PosX = 0 ;
    PosY = 0 ;
    PosZ = 0 ;

    // ウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // キーボードの上下左右でモデルの座標を変更
        // ( シフトキーを押しながら上下キーでモデルを上下に移動 )
        if( CheckHitKey( KEY_INPUT_LSHIFT ) )
        {
            if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosY -- ;
            if( CheckHitKey( KEY_INPUT_UP    ) ) PosY ++ ;
        }
        else
        {
            if( CheckHitKey( KEY_INPUT_LEFT  ) ) PosX -- ;
            if( CheckHitKey( KEY_INPUT_RIGHT ) ) PosX ++ ;
            if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosZ -- ;
            if( CheckHitKey( KEY_INPUT_UP    ) ) PosZ ++ ;
        }

        // モデルの座標をセット
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( PosX * 0.5f, PosY * 0.5f, PosZ * 0.5f ) ) ;

        // 物理演算を６０分の１秒経過したという想定で実行
        MV1PhysicsCalculation( ModelHandle, 1000.0f / 60.0f ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R3N31">宣言</a></b></td><td><font color="#000088"><b>int MV1PhysicsResetState( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルの物理演算の状態をリセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　関数 <b><a href="#R1N4">MV1SetLoadModelUsePhysicsMode</a></b>を使用して読み込む３Ｄモデルに対してリアルタイム物理演算を行うように指定した上で、
                    物理演算用の情報を持つ３Ｄモデルを関数 <b><a href="#R1N1">MV1LoadModel</a></b>
                    で読み込んだ場合に、この関数を使用して物理演算の状態のリセットを行います。<br><br>

                    　リセットする必要が発生するタイミングは主にワープ( 瞬間的に離れた場所に移動 )した場合です。<br><br>

                    　現実では人間はワープしませんし( できませんし )、ゲーム中のキャラクターも特殊能力の設定でもない限りはワープしませんが、
                    ステージを移動した場合や、ゲームオーバーになってキャラクターがスタート地点に移動した場合など、
                    ゲームの手続きとしてのワープはごく普通に発生します。<br><br>

                    　ゲームの手続きとして瞬間的に長距離移動しただけなのにも関わらす、この際に物理演算の状態をリセットしないと物理演算プログラムは
                    「その物体がものすごい速さで瞬間的に長距離移動した」として物理演算を行ってしまい、モデルの表示がおかしくなってしまいます。<br><br>

                    　なので、キャラクターをワープさせた際などにはこの関数でモデルの物理演算の状態をリセットしてやってください。<br>
                </td>
            </tr>
        </table></td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　リアルタイム物理演算モードで Test.pmd を <b><a href="#R1N1">MV1LoadModel</a></b> で読み込んで<br>
            リアルタイム物理演算を行いながらキーボードの上下左右でモデルの位置を移動します。<br><br>

            　スペースキーが押されたらモデルを原点にワープさせ、MV1PhysicsResetState でモデルの物理演算の状態をリセットします。<br><br>

            　尚、Test.pmd はＤＸライブラリのパッケージには含まれていませんので、別途用意してください。<br>
            　PMDのキャラクターは大体同じ大きさですので、カメラの設定などはそのままで問題ないと思います。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int PosX, PosZ, PosY ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 次に読み込むモデルの物理演算モードをリアルタイム物理演算にする
    <b><a href="#R1N4">MV1SetLoadModelUsePhysicsMode</a></b>( DX_LOADMODEL_PHYSICS_REALTIME ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "Test.pmd" ) ;

    // 描画先を裏画面に変更
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // カメラに映る範囲( カメラからの距離の範囲 )を設定
    <b><a href="#R12N1">SetCameraNearFar</a></b>( 10.0f, 1000.0f ) ;

    // カメラの位置と向きを設定
    <b><a href="#R12N2">SetCameraPositionAndTarget_UpVecY</a></b>( VGet( 0.0f, 19.0f, -22.5f ), VGet( 0.0f, 10.0f, 0.0f ) ) ;

    // 座標をリセット
    PosX = 0 ;
    PosY = 0 ;
    PosZ = 0 ;

    // ウインドウが閉じられるまでループ
    while( ProcessMessage() == 0 )
    {
        // 画面をクリア
        ClearDrawScreen() ;

        // キーボードの上下左右でモデルの座標を変更
        // ( シフトキーを押しながら上下キーでモデルを上下に移動 )
        if( CheckHitKey( KEY_INPUT_LSHIFT ) )
        {
            if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosY -- ;
            if( CheckHitKey( KEY_INPUT_UP    ) ) PosY ++ ;
        }
        else
        {
            if( CheckHitKey( KEY_INPUT_LEFT  ) ) PosX -- ;
            if( CheckHitKey( KEY_INPUT_RIGHT ) ) PosX ++ ;
            if( CheckHitKey( KEY_INPUT_DOWN  ) ) PosZ -- ;
            if( CheckHitKey( KEY_INPUT_UP    ) ) PosZ ++ ;
        }

        // モデルの座標をセット
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( PosX * 0.5f, PosY * 0.5f, PosZ * 0.5f ) ) ;

        // スペースキーが押されたら原点に戻る
        if( GetInputChar( TRUE ) == ' ' )
        {
            PosX = 0 ;
            PosY = 0 ;
            PosZ = 0 ;

            // モデルの座標を原点に移動
            <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, VGet( 0.0f, 0.0f, 0.0f ) ) ;

            // モデルの物理演算の状態をリセット
            MV1PhysicsResetState( ModelHandle ) ;
        }

        // 物理演算を６０分の１秒経過したという想定で実行
        <b><a href="#R3N30">MV1PhysicsCalculation</a></b>( ModelHandle, 1000.0f / 60.0f ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        ScreenFlip() ;
    }

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

    
        <tr><td><font size="3" color="#005500"><b>アニメーション関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N1">宣言</a></b></td><td><font color="#000088"><b>int MV1AttachAnim( int MHandle, int AnimIndex, int AnimSrcMHandle, int NameCheck ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アニメーションをアタッチする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle　　　　　　： アニメーションをアタッチするモデルのハンドル<br>
            int AnimIndex　　　　　： アタッチするアニメーション番号<br>
            int AnimSrcMHandle　： アタッチするアニメーションを持っているモデルのハンドル<br>
            　　　　　　　　　　　　　　　( -1 を渡すと MHandle と同じモデルハンドルが使用されます )<br>
            int NameCheck　　　　： AnimSrcMHandle が -1 以外の場合にアタッチするアニメーションの<br>
            　　　　　　　　　　　　　　フレームの名前とアタッチされる側のモデルのフレームの名前が<br>
            　　　　　　　　　　　　　　一致していない場合アタッチしないかどうか<br>
            　　　　　　　　　　　　　　( TRUE：アタッチしない　FALSE：アタッチする )<br>
            　　　　　　　　　　　　　　この引数は AnimSrcMHandle が -1 の場合は無視されます
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：アニメーションアタッチ番号</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアニメーションをアタッチします。<br><br>
                    
                    　アニメーションとは主にモデル内のフレームに対する動きのデータで、
                    キャラクターモデルが歩いたり走ったりといった表現をする際に使用します。
                    ( アニメーションのデータ自体は予めアニメーションデータを作成できるソフトを使用して作成しておく必要があります )<br><br>

                    　ＤＸライブラリではアニメーションを再生する際に、
                    最初に再生したいアニメーションを指定する作業「アニメーションのアタッチ」をする必要があります。<br><br>

                    　アタッチ自体は簡単で、この関数でアタッチしたいアニメーションの番号を渡すだけです。<br><br>
                    　そして、アニメーションのアタッチが無事完了すると戻り値としてアタッチ番号が返ってきます。<br>
                    　これは「ハンドル」と呼べるほどのものではありませんが、
                    モデルハンドルなどと同様にアタッチしたアニメーションに関する操作はすべてこのアタッチ番号を使用して行いますので、
                    アタッチ番号もモデルハンドルなどと同じように何かの変数にとっておく必要があります。<br><br>

<pre>
// 例 ： モデルに含まれる 0番目のアニメーションをアタッチしてアニメーションの総時間を取得する
int AttachIndex ;
float AnimTime ;

AttachIndex = MV1AttachAnim( MHandle, 0, -1, FALSE ) ;
AnimTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( MHandle, AttachIndex ) ;
</pre>
                    <br>
                    　アニメーションはアタッチした時点でアタッチしたアニメーションのカウント０の状態がモデルに反映されます。<br>
                    　そして、アニメーションの再生カウントを変更する際は <b><a href="#R4N3">MV1SetAttachAnimTime</a></b> を使用します。<br>
                    　ＤＸライブラリには自動的にカウンタを進める仕組みはありませんので、
                    「MV1PlayAnim」 や 「MV1StopAnim」 のような名称の関数は存在しません。<br>
                    　なので、MV1SetAttachAnimTime にセットする再生時間を徐々に進めることでアニメーションを再生します。<br><br>

                    　引数 AnimSrcMHandle は同じフレーム構造を持った MHandle とは別のモデルのモデルに含まれているアニメーションを MHandle のモデルで再生する際に使用します。
                    ( 同じアニメーションを使用する見た目の違うキャラクターモデルが複数ある場合などは、
                    アニメーションだけのファイルと見た目の違うフレーム構造が同じメッシュだけのファイルを別々に用意することで各キャラクターモデルのファイルにはアニメーションデータを含める必要がなくなるので、
                    アニメーションデータの容量分だけデータサイズを削減することができます )<br><br>

                    　引数 NameCheck は AnimSrcMHandle を使用して別のモデルファイルに含まれるアニメーションをアタッチする場合に、
                    アニメーションデータ側のフレームの名前とモーションをアタッチするモデルデータ側のフレームの名前を比較して違った場合はアタッチしないという処理をするかどうかを指定する引数で、
                    TRUE を渡すと比較して、FALSE を渡すと比較しません。<br><br>

                    　名前を比較しない場合はフレームの階層構造と各階層のフレームの数がモデル側とアニメーション側で完全に一致していないと正常にアニメーションを再生することができません。<br>
                    　名前を比較する場合はフレームの階層構造と名前が一致していればモデル側にあってアニメーション側に無いフレームがあっても正常にアニメーションを再生することができます。
                    ( ただし、同じ階層に同名のフレームが複数ある場合は正常にアニメーションを再生することはできません )<br><br>

                    　名前比較を行うかどうかはアタッチするモーションデータにあわせて判断してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のアニメーションをループ再生します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex ;
    float TotalTime, PlayTime ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アタッチしたアニメーションの総再生時間を取得する
    TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

    // 再生時間の初期化
    PlayTime = 0.0f ;

    // 何かキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 再生時間を進める
        PlayTime += 100.0f ;

        // 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
        if( PlayTime >= TotalTime )
        {
            PlayTime = 0.0f ;
        }

        // 再生時間をセットする
        <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N2">宣言</a></b></td><td><font color="#000088"><b>int MV1DetachAnim( int MHandle, int AttachIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アニメーションをデタッチする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： アニメーションをデタッチするモデルのハンドル<br>
            int AttachIndex ： デタッチするアニメーションのアタッチ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションをデタッチ( 外すこと )します。<br><br>

                    　アニメーションは同時に幾つでもアタッチすることができ、
                    <b><a href="#R4N6">MV1SetAttachAnimBlendRate</a></b>
                    関数でアタッチしている各アニメーションの影響率も設定することができるので、
                    一応、すべてのアニメーションをアタッチして、MV1SetAttachAnimBlendRate
                    関数で表示したいアニメーションの影響率だけを上げるということもできるのですが、
                    それをすると使用メモリや処理負荷が多少上昇します。<br><br>

                    　なので、ＤＸライブラリのモデル機能では使用するアニメーションのみをアタッチして、
                    再生が終わったらこの関数でアタッチしたアニメーションをデタッチする( 外す )ことを想定しています。<br><br>

                    　因みに、
                    <b><a href="#R1N3">MV1DeleteModel</a></b> 関数でモデルを削除する際にアタッチしたアニメーションは自動的にデタッチされますので、
                    削除する前にアタッチしたすべてのアニメーションをこの関数でデタッチしておかなければならないということはありません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のアニメーションと１番のアニメーションを交互に再生します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex, PlayAnim ;
    float TotalTime, PlayTime ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アタッチしたアニメーションの総再生時間を取得する
    TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

    // 再生時間の初期化
    PlayTime = 0.0f ;

    // 再生しているアニメーションを０番にする
    PlayAnim = 0 ;

    // アニメーション０の再生が終わるか、何かキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 再生時間を進める
        PlayTime += 100.0f ;

        // 再生時間がアニメーションの総再生時間に達したら次のアニメーションにする
        if( PlayTime >= TotalTime )
        {
            // 再生しているアニメーションを、今までが０番だったら１番に、１番だったら０番にする
            if( PlayAnim == 0 )
            {
                PlayAnim = 1 ;
            }
            else
            {
                PlayAnim = 0 ;
            }

            // 今までアタッチしていたアニメーションのデタッチ
            MV1DetachAnim( ModelHandle, AttachIndex ) ;

            // ３Ｄモデルの PlayAnim 番目のアニメーションをアタッチする
            AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, PlayAnim, -1, FALSE ) ;

            // アタッチしたアニメーションの総再生時間を取得する
            TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

            // 再生時間の初期化
            PlayTime = 0.0f ;
        }

        // 再生時間をセットする
        <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N3">宣言</a></b></td><td><font color="#000088"><b>int MV1SetAttachAnimTime( int MHandle, int AttachIndex, float Time ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションの再生時間を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： 再生時間を設定するアニメーションのアタッチ番号<br>
            float Time ： 再生時間
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの再生時間を設定します。<br><br>

                    　ＤＸライブラリのアニメーション機能には自動的にアニメーションを再生する機能はありませんので、
                    この関数を使用してアニメーションの再生時間を設定します。<br><br>

                    　アニメーションのキーが存在しない時間が指定された場合は、
                    指定された時間の前後にあるキーからの補間値がモデルに反映されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のアニメーションの再生時間 10000.0f の状態を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アタッチしたアニメーションの再生時間を 10000.0f にする
    <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, 10000.0f ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N4">宣言</a></b></td><td><font color="#000088"><b>float MV1GetAttachAnimTime( int MHandle, int AttachIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションの再生時間を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： 再生時間を取得するアニメーションのアタッチ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アニメーションに設定されている再生時間<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの再生時間を取得します。<br>
                    <b><a href="#R4N3">MV1SetAttachAnimTime</a></b> でセットした値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N5">宣言</a></b></td><td><font color="#000088"><b>float MV1GetAttachAnimTotalTime( int MHandle, int AttachIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションの総時間を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： 総時間取得するアニメーションのアタッチ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アニメーションの総時間<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの総時間を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のアニメーションの総時間を画面左上に描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex ;
    float TotalTime ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ３Ｄモデルの０番目のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 0, -1, FALSE ) ;

    // アニメーション０番の総時間を画面に描画
    TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "%f", TotalTime ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N6">宣言</a></b></td><td><font color="#000088"><b>int MV1SetAttachAnimBlendRate( int MHandle, int AttachIndex, float Rate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションのブレンド率を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： アニメーションのアタッチ番号<br>
            float Rate ： ブレンド率( 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションのブレンド率を設定します。<br><br>

                    　例えば、アニメーション０とアニメーション１を合成して表示したいときにします。<br>
                    　そんな状況があるのかといいますと、結構あります。<br><br>
                    　例えば歩いている状態から走っているアニメーションに切り替えたい場合、
                    最良の見た目を求めるのでしたら歩いている状態から走っている状態に移行するアニメーションを作り、
                    それを歩くアニメーションと走るアニメーションの間に再生するべきですが、
                    実際のゲームでは大抵の場合歩いているアニメーションのどのタイミングで走るアニメーションに切り替わるのかを事前に知る方法はありませんので、
                    歩くアニメーションを途中で止めて走るアニメーションを流すことになります。<br><br>
                    
                    　ですが、歩くアニメーションを止めて走るアニメーションを再生するとはっきりと切り替わりが見えてしまいあまり見た目的に良くありません、
                    こんな時にこの関数を使用して歩くアニメーションのブレンド率を徐々に下げ、
                    走るアニメーションのブレンド率を徐々に上げることで歩くアニメーションから走るアニメーションへの以降の様子をぼかして違和感を軽減することが出来ます。<br><br>

                    　他にも全く姿勢の違うアニメーションへの切り替えの違和感を軽減する際などに使用できます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる直立しているアニメーションから右手を前に出しているアニメーションへ徐々に移行します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AttachIndex1, AttachIndex2 ;
    float Rate ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 画面が切り替わるのをちょっと待つ
    <b><a href="dxfunc_other.html#R6N1">WaitTimer</a></b>( 1000 ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルの立っているアニメーション( ４番目のアニメーション )をアタッチする
    AttachIndex1 = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, 4, -1, FALSE ) ;

    // ３Ｄモデルの手を前に出しているアニメーション( ５番目のアニメーション )をアタッチする
    AttachIndex2 = MV1AttachAnim( ModelHandle, 5, -1, FALSE ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // ４番目のアニメーションから５番目のアニメーションに徐々に移行する
    for( Rate = 0.0f ; Rate < 1.0f ; Rate += 0.01f )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 立っているアニメーションのブレンド率をセット
        <b><a href="#R4N6">MV1SetAttachAnimBlendRate</a></b>( ModelHandle, AttachIndex1, 1.0f - Rate ) ;

        // 手を前に出しているアニメーションのブレンド率をセット
        MV1SetAttachAnimBlendRate( ModelHandle, AttachIndex2, Rate ) ;

        // モデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映する
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N7">宣言</a></b></td><td><font color="#000088"><b>float MV1GetAttachAnimBlendRate( int MHandle, int AttachIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションのブレンド率を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： ブレンド率を取得するアニメーションのアタッチ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アニメーションに設定されているブレンド率<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションのブレンド率を取得します。<br>
                    <b><a href="#R4N6">MV1SetAttachAnimBlendRate</a></b> でセットした値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N8">宣言</a></b></td><td><font color="#000088"><b>int MV1GetAttachAnim( int MHandle, int AttachIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションのアニメーション番号を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： アニメーション番号を取得するアニメーションのアタッチ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アタッチしているアニメーションの番号<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの番号を取得します。<br>
                    <b><a href="#R4N1">MV1AttachAnim</a></b> の第二引数( int AnimIndex )で渡した値がそのまま返ってきます。<br><br>

                    具体的な用途は思いつきませんが、必要になることがあるような気がするので追加しました。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N13">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetAttachAnimFrameLocalPosition( int MHandle, int AttachIndex, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アタッチしているアニメーションの指定フレーム( ボーン )のローカル座標を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AttachIndex ： アニメーション番号を取得するアニメーションのアタッチ番号<br>
	    int FrameIndex ： ローカル座標を取得するフレーム( ボーン )番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>指定のフレーム( ボーン )のローカル座標<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
		　MHandle のモデルハンドルが示すモデルにアタッチしたアニメーションの、<b><a href="#R4N3">MV1SetAttachAnimTime</a></b> で設定されている再生時間での FrameIndex で指定するフレーム( ボーン )のローカル座標を取得します。<br>
		　アニメーションに設定されている各フレームの移動値を取得したい場合に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                サンプルプログラムコーナーの『<b><a href="../program/dxprogram_AnimationMove.html">アニメーションによる座標移動</a></b>』を参照してください。
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N9">宣言</a></b></td><td><font color="#000088"><b>int MV1GetAnimNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>アニメーションの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：モデルに含まれるアニメーションの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるアニメーションの総数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれるアニメーションの一覧を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AnimNum, i ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // モデルに含まれるアニメーションの数を取得する
    AnimNum = MV1GetAnimNum( ModelHandle ) ;

    // アニメーションの一覧を描画する
    for( i = 0 ; i &lt; AnimNum ; i ++ )
    {
        // 左から順に、アニメーション番号、アニメーション名、アニメーションの総時間を描画する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, i * 16, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),
            "No:%d Name:%s Time:%f",
            i,
            <b><a href="#R4N10">MV1GetAnimName</a></b>( ModelHandle, i ),
            <b><a href="#R4N12">MV1GetAnimTotalTime</a></b>( ModelHandle, i ) ) ;
    }

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N10">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetAnimName( int MHandle, int AnimIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定番号のアニメーション名を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AnimIndex ： アニメーション名を取得したいアニメーションの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>NULL以外：指定番号のアニメーション名</td></tr>
            <tr><td width="100">　</td><td>NULL：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるアニメーションの名前を取得します。<br><br>
                    　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R4N9">MV1GetAnimNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N11">宣言</a></b></td><td><font color="#000088"><b>MV1GetAnimIndex( int MHandle, char *AnimName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定名のアニメーション番号を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            char *AnimName ： 番号を取得したいアニメーションの名前
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：アニメーション番号</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれる指定名を持つアニメーションの番号を取得します。<br><br>
                
                    　名前からアニメーション番号を検索したい場合に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる Animation_2 という名前のアニメーションを再生します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, AnimIndex, AttachIndex ;
    float TotalTime, PlayTime ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // Animation_2 という名前のアニメーションの番号を取得する
    AnimIndex = MV1GetAnimIndex( ModelHandle, "Animation_2" ) ;

    // 取得したアニメーション番号のアニメーションをアタッチする
    AttachIndex = <b><a href="#R4N1">MV1AttachAnim</a></b>( ModelHandle, AnimIndex, -1, FALSE ) ;

    // アタッチしたアニメーションの総再生時間を取得する
    TotalTime = <b><a href="#R4N5">MV1GetAttachAnimTotalTime</a></b>( ModelHandle, AttachIndex ) ;

    // 再生時間の初期化
    PlayTime = 0.0f ;

    // 何かキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 再生時間を進める
        PlayTime += 100.0f ;

        // 再生時間がアニメーションの総再生時間に達したら再生時間を０に戻す
        if( PlayTime >= TotalTime )
        {
            PlayTime = 0.0f ;
        }

        // 再生時間をセットする
        <b><a href="#R4N3">MV1SetAttachAnimTime</a></b>( ModelHandle, AttachIndex, PlayTime ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R4N12">宣言</a></b></td><td><font color="#000088"><b>float MV1GetAnimTotalTime( int MHandle, int AnimIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定番号のアニメーションの総時間を得る<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int AnimIndex ： 総時間を取得したいアニメーションの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１．０ｆ以外：指定番号のアニメーションの総時間</td></tr>
            <tr><td width="100">　</td><td>−１．０ｆ：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるアニメーションの総時間を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R4N9">MV1GetAnimNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><font size="3" color="#005500"><b>マテリアル関係</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N1">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMaterialNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルで使用しているマテリアルの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：モデルに含まれるマテリアルの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの総数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれるアニメーションの情報を一つづつ描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, MaterialNum, i ;
    COLOR_F Color ;
    char *Name ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // モデルに含まれるマテリアルの数を取得する
    MaterialNum = MV1GetMaterialNum( ModelHandle ) ;

    // マテリアルの情報を一つづつ描画する
    for( i = 0 ; i &lt; MaterialNum ; i ++ )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // マテリアルの名前を描画
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),  "Name            %s", MV1GetMaterialName( ModelHandle, i ) ) ;

        // マテリアルのディフューズカラーを描画
        Color = <b><a href="#R5N4">MV1GetMaterialDifColor</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Diffuse  Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

        // マテリアルのスペキュラカラーを描画
        Color = <b><a href="#R5N6">MV1GetMaterialSpcColor</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Specular Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

        // マテリアルのエミッシブカラーを描画
        Color = <b><a href="#R5N8">MV1GetMaterialEmiColor</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Emissive Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

        // マテリアルのアンビエントカラーを描画
        Color = <b><a href="#R5N10">MV1GetMaterialAmbColor</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 64, GetColor( 255,255,255 ), "Ambient  Color  R:%f  G:%f  B:%f  A:%f", Color.r, Color.g, Color.b, Color.a ) ;

        // マテリアルのスペキュラの強さ描画
        DrawFormatString( 0, 80, GetColor( 255,255,255 ), "Specular Power  %f", <b><a href="#R5N12">MV1GetMaterialSpcPower</a></b>( ModelHandle, i ) ) ;

        // 描画ブレンドモードの描画
        switch( <b><a href="#R5N21">MV1GetMaterialDrawBlendMode</a></b>( ModelHandle, i ) )
        {
        case DX_BLENDMODE_NOBLEND : Name = "DX_BLENDMODE_NOBLEND" ; break ;
        case DX_BLENDMODE_ALPHA   : Name = "DX_BLENDMODE_ALPHA"   ; break ;
        case DX_BLENDMODE_ADD     : Name = "DX_BLENDMODE_ADD"     ; break ;
        case DX_BLENDMODE_SUB     : Name = "DX_BLENDMODE_SUB"     ; break ;
        case DX_BLENDMODE_INVSRC  : Name = "DX_BLENDMODE_INVSRC"  ; break ;
        case DX_BLENDMODE_MULA    : Name = "DX_BLENDMODE_MULA"    ; break ;
        }
        DrawFormatString( 0, 96, GetColor( 255,255,255 ), "Draw Blend Mode   %s", Name ) ;

        // 描画ブレンドパラメータの描画
        DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Draw Blend Param  %d", <b><a href="#R5N23">MV1GetMaterialDrawBlendParam</a></b>( ModelHandle, i ) ) ;

        // キー入力待ち
        <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N2">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetMaterialName( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの名前を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： 名前を取得したいマテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>NULL 以外：マテリアルの名前</td></tr>
            <tr><td width="100">　</td><td>NULL：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの名前を取得します。<br><br>
                    　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N3">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialDifColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのディフューズカラーを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： ディフューズカラーを変更するマテリアルの番号<br>
            COLOR_F Color ： ディフューズカラー( 拡散光色 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのディフューズカラー( 拡散光色 )を変更します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のマテリアルのディフューズカラーを真っ赤にしてモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルのディフューズカラーを真っ赤にします
    MV1SetMaterialDifColor( ModelHandle, 0, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N4">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMaterialDifColor( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのディフューズカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ディフューズカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのディフューズカラー( 拡散光色 )を取得します。<br><br>

                    　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。
                    ( 値の範囲は 0.0f 〜 1.0f ( ０％〜１００％ ) )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N5">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialSpcColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのスペキュラカラーを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： スペキュラカラーを変更するマテリアルの番号<br>
            COLOR_F Color ： スペキュラカラー( 拡散光色 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラカラー( 反射光色 )を変更します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のマテリアルのスペキュラカラーを緑色にしてモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルのスペキュラカラーを緑にします
    MV1SetMaterialSpcColor( ModelHandle, 0, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 1.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N6">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMaterialSpcColor( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのスペキュラカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラカラー( 反射光色 )を取得します。<br><br>

                    　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。
                    ( 値の範囲は 0.0f 〜 1.0f ( ０％〜１００％ ) )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N7">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialEmiColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのエミッシブカラーを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： エミッシブカラーを変更するマテリアルの番号<br>
            COLOR_F Color ： エミッシブカラー( 自己発光色 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのエミッシブカラー( 自己発光色 )を変更します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のマテリアルのエミッシブカラーを暗い黄色にしてモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルのエミッシブカラーを暗い黄色にします
    MV1SetMaterialEmiColor( ModelHandle, 0, <b><a href="#R14N14">GetColorF</a></b>( 0.2f, 0.2f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N8">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMaterialEmiColor( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのエミッシブカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>エミッシブカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのエミッシブカラー( 自己発光色 )を取得します。<br><br>

                    　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。
                    ( 値の範囲は 0.0f 〜 1.0f ( ０％〜１００％ ) )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N9">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialAmbColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのアンビエントカラーを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： アンビエントカラーを変更するマテリアルの番号<br>
            COLOR_F Color ： アンビエントカラー( 環境光色 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのアンビエントカラー( 環境光色 )を変更します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のマテリアルのアンビエントカラーを紫色にしてモデルを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルのアンビエントカラーを紫色にします
    MV1SetMaterialAmbColor( ModelHandle, 0, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 1.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N10">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMaterialAmbColor( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのアンビエントカラーを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>アンビエントカラー</TD></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのアンビエントカラー( 環境光色 )を取得します。<br><br>

                    　戻り値は COLOR_F 構造体で、中にはそれぞれ赤、緑、青、α成分を表す変数 float r, g, b, a ; が含まれています。
                    ( 値の範囲は 0.0f 〜 1.0f ( ０％〜１００％ ) )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N11">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialSpcPower( int MHandle, int MaterialIndex, float Power ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのスペキュラの強さを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： スペキュラの強さを変更するマテリアルの番号<br>
            float Power ： スペキュラの強さ
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラの強さを変更します。<br><br>

                    　具体的には反射する光の範囲が鋭くなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のマテリアルのスペキュラの強さを変更します。<br>
            　　( 変化がわかりにくいので、スペキュラカラーも明るくしています )<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルのスペキュラカラーを明るくします
    <b><a href="#R5N5">MV1SetMaterialSpcColor</a></b>( ModelHandle, 0, <b><a href="#R14N14">GetColorF</a></b>( 0.457f, 0.687f, 0.948f, 0.f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルのスペキュラの強さを 0.1f にします
    MV1SetMaterialSpcPower( ModelHandle, 0, 19.0f ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N12">宣言</a></b></td><td><font color="#000088"><b>float MV1GetMaterialSpcPower( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのスペキュラの強さを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラの強さ</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラの強さを取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N24">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMaterialDifMapTexture( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルでディフューズマップとして使用されているテクスチャ番号を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：テクスチャの番号</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのディフューズマップとして使用されているテクスチャの番号を取得します。<br>
                    　取得した番号は関数 <b><a href="#R15N4">MV1GetTextureGraphHandle</a></b> などの引数として使用します。
                    ( テクスチャの番号はモデルに含まれるテクスチャに振られる番号で、グラフィックハンドルではありませんのでご注意ください )<br><br>

                    　モデルのテクスチャを変更したり利用したりしたいときに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる４番目のマテリアルにディフューズテクスチャとして使用されている<br>
            　テクスチャの番号を取得して、そのテクスチャのグラフィックハンドルを取得して画面に描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int TexIndex ;
    int GrHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // マテリアル番号４で使用されているテクスチャの番号を取得する
    TexIndex = MV1GetMaterialDifMapTexture( ModelHandle, 4 ) ;

    // モデルで使用されているテクスチャのグラフィックハンドルを取得する
    GrHandle = <b><a href="#R15N4">MV1GetTextureGraphHandle</a></b>( ModelHandle, TexIndex ) ;

    // 取得したグラフィックハンドルを画面に描画する
    <b><a href="dxfunc_graph1.html#R3N7">DrawGraph</a></b>( 0, 0, GrHandle, TRUE ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N25">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMaterialSpcMapTexture( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルでスペキュラマップとして使用されているテクスチャ番号を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：テクスチャの番号</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのスペキュラマップとして使用されているテクスチャの番号を取得します。<br>
                    　取得した番号は関数 <b><a href="#R15N4">MV1GetTextureGraphHandle</a></b> などの引数として使用します。
                    ( テクスチャの番号はモデルに含まれるテクスチャに振られる番号で、グラフィックハンドルではありませんのでご注意ください )<br><br>

                    　モデルのテクスチャを変更したり利用したりしたいときに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　マテリアルで使用されているテクスチャを画面に描画するサンプルが <a href="#R5N24">MV1GetMaterialDifMapTexture 関数</a> にあります。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N26">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMaterialNormalMapTexture( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルで法線マップとして使用されているテクスチャ番号を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：テクスチャの番号</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの法線マップとして使用されているテクスチャの番号を取得します。<br>
                    　取得した番号は関数 <b><a href="#R15N4">MV1GetTextureGraphHandle</a></b> などの引数として使用します。
                    ( テクスチャの番号はモデルに含まれるテクスチャに振られる番号で、グラフィックハンドルではありませんのでご注意ください )<br><br>

                    　モデルのテクスチャを変更したり利用したりしたいときに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　マテリアルで使用されているテクスチャを画面に描画するサンプルが <a href="#R5N24">MV1GetMaterialDifMapTexture 関数</a> にあります。<br><br><br><br>
        </td></tr>

<!--
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N13">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialDifMapTexPath( int MHandle, int MaterialIndex, char *TexPath ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのディフューズマップテクスチャのパスを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle : モデルのハンドル<br>
            int MaterialIndex : マテリアルの番号<br>
            char *TexPath : 変更後のテクスチャのパス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルが使用するディフューズマップテクスチャを変更します。<br>
                    　テクスチャパスは読み込んだモデルをカレントフォルダとした相対パスではなく、現在のカレントフォルダの相対パスです。<br>
                    　形状は同じでテクスチャだけ違うキャラクターを登場させたい場合などに使用します。<br><br>

                    　尚、使用するテクスチャは 2 のｎ乗( 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, ... )のサイズである必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる４番目のマテリアルで使用するディフューズマップテクスチャを DxCharaEye2.tga に変更します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる４番目のマテリアルが使用するディフューズマップを DxCharaEye2.tga に変更します
    MV1SetMaterialDifMapTexPath( ModelHandle, 4, "DxCharaEye2.tga" ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N14">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetMaterialDifMapTexPath( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのディフューズマップテクスチャのパスを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle : モデルのハンドル<br>
            int MaterialIndex : マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>ディフューズマップテクスチャのパス( 無い場合は NULL )</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルで使用されているディフューズマップテクスチャファイルのパスを取得します。<br><br>
                
                    　ディフューズマップを使用していない場合は NULL が返ってきます。<br>
                    　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N15">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialSpcMapTexPath( int MHandle, int MaterialIndex, char *TexPath ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのスペキュラマップテクスチャのパスを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle : モデルのハンドル<br>
            int MaterialIndex : マテリアルの番号<br>
            char *TexPath : 変更後のテクスチャのパス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルが使用するスペキュラマップテクスチャを変更します。<br>
                    　テクスチャパスは読み込んだモデルをカレントフォルダとした相対パスではなく、現在のカレントフォルダの相対パスです。<br>
                    　形状は同じでテクスチャだけ違うキャラクターを登場させたい場合などに使用します。<br><br>

                    　尚、使用するテクスチャは 2 のｎ乗( 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, ... )のサイズである必要があります。<br><br>
                    　因みに、スペキュラマップは Pixel Shader Model 2.0 と Vertex Shader Model 2.0
                    が使用できるグラフィックスデバイスを使用していない場合は無効ですので、
                    沢山の環境でプレイできるゲームを作成したい場合はスペキュラマップの効果が無いとゲームとして成り立たないような表現( 敵の弱点がスペキュラマップで浮き上がる等 )は避ける必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる１番目のマテリアルで使用するスペキュラマップテクスチャを DxCharaTex.bmp に変更します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる１番目のマテリアルが使用するスペキュラマップを DxCharaTex.bmp に変更します
    MV1SetMaterialSpcMapTexPath( ModelHandle, 1, "DxCharaTex.bmp" ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N16">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetMaterialSpcMapTexPath( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのスペキュラマップテクスチャのパスを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle : モデルのハンドル<br>
            int MaterialIndex : マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>スペキュラマップテクスチャのパス( 無い場合は NULL )</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルで使用されているスペキュラマップテクスチャファイルのパスを取得します。<br><br>
                
                    　スペキュラマップを使用していない場合は NULL が返ってきます。<br>
                    　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N17">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetMaterialNormalMapTexPath( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの法線マップテクスチャのパスを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle : モデルのハンドル<br>
            int MaterialIndex : マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>法線マップテクスチャのパス( 無い場合は NULL )</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルで使用されている法線マップテクスチャファイルのパスを取得します。<br><br>
                
                    　法線マップを使用していない場合は NULL が返ってきます。<br>
                    　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N18">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetMaterialBumpMapTexPath( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの凸凹マップテクスチャのパスを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>凸凹マップテクスチャのパス( 無い場合は NULL )</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルで使用されている凸凹マップテクスチャファイルのパスを取得します。<br><br>
                
                    　凸凹マップを使用していない場合は NULL が返ってきます。<br>
                    　尚、戻り値は const 型( 変更不可能型 )ですので、もし戻り値を変数に代入する場合は const char * 型の変数にする必要があります。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N19">宣言</a></b></td><td><font color="#000088"><b>float MV1GetMaterialBumpMapNextPixelLength( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの凸凹マップテクスチャの１ピクセル辺りの距離を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>凸凹マップテクスチャの１ピクセル辺りの距離</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルで使用されている凸凹マップテクスチャファイルの１ピクセル辺りの距離を取得します。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>
-->


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N20">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialDrawBlendMode( int MHandle, int MaterialIndex, int BlendMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの描画ブレンドモードを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号<br>
            int BlendMode ： 描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのブレンドモードを変更します。<br>
                    　現在モデル描画で正常に動作するブレンドモードは DX_BLENDMODE_ALPHA, DX_BLENDMODE_ADD の２種類のみです。
                    ( ハードウエアが対応している場合は DX_BLENDMODE_SUB も正常に機能します )<br>
                    　ブレンドモードの説明に関しては <b><a href="dxfunc_graph1.html#R3N17">SetDrawBlendMode</a></b> 関数の解説を参照してください。<br><br>

                    　ブレンドモードのパラメータの変更は <b><a href="#R5N22">MV1SetMaterialDrawBlendParam</a></b> 関数を使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる１番目のマテリアルの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,0,255 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる１番目のマテリアルの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
    <b><a href="#R5N20">MV1SetMaterialDrawBlendMode</a></b>( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N21">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMaterialDrawBlendMode( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの描画ブレンドモードを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの描画ブレンドモードを取得します。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N22">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialDrawBlendParam( int MHandle, int MaterialIndex, int BlendParam ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの描画ブレンドパラメータを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号<br>
            int BlendParame ： 描画ブレンドパラメータ( 0 〜 255 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルのブレンドパラメータを変更します。<br>
                    ( ブレンドパラメータの説明に関しては <b><a href="dxfunc_graph1.html#R3N17">SetDrawBlendMode</a></b> 関数の解説を参照してください )<br><br>

                    　尚、ブレンドモードの変更は <b><a href="#R5N20">MV1SetMaterialDrawBlendMode</a></b> 関数を使用してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる１番目のマテリアルの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更して、
            ブレンドパラメータを128にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,0,255 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のマテリアルの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
    MV1SetMaterialDrawBlendMode( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

    // マテリアルのブレンドパラメータを 128 に変更する
    <b><a href="#R5N22">MV1SetMaterialDrawBlendParam</a></b>( ModelHandle, 1, 128 ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N23">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMaterialDrawBlendParam( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの描画ブレンドパラメータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>描画ブレンドパラメータ( 0 〜 255 )</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの描画ブレンドパラメータを取得します。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R5N1">MV1GetMaterialNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N35">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialDrawAlphaTest( int MHandle, int MaterialIndex, int Enable, int Mode, int Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの描画アルファテストの設定を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号<br>
            int Enable ： アルファテストを有効にするかどうか( TRUE：有効にする　FALSE：無効にする（デフォルト） )<br>
	    int Mode ： テストモード( DX_CMP_GREATER等 )<br>
	    int Param ： 描画アルファ値との比較に使用する値( 0〜255 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれる指定のマテリアルの描画時にアルファテストを行うかどうかや、行う場合のテストモードを変更します。<br>
                    　アルファテストとは描画する色のアルファ値によって描画を行うかどうかを決定する機能で、
		    主に描画負荷の軽減とＺバッファへどれだけ透明なピクセルでも書き込むか等を決定する為に使用します。<br><br>

		    　Ｚバッファにはアルファ値が 1 でほぼ完全に透明の物でも不透明の物と同様にしっかりと深度情報が書き込まれてしまいます。<br>
		    　すると、その後『ほぼ完全に透明の物』の奥に別の物を描画しようとすると『ほぼ完全に透明の物』に隠れて描画されないという現象が発生してしまいます。<br>
		    　理想的には描画物を画面奥にあるものから順に描画すればこのような問題は発生しないのですが、
		    描画物が大量にあって画面奥にあるものから順に描画しようとするとソートの処理負荷が高くなってしまう等必ずしも常に理想的な描画が行えるとは限らないので、
		    そのような場合にアルファテスト機能を使って、一定以上の透明度のものはそもそも描画しない、などの設定を行ってから描画します。<br><br>

		    アルファテストとして使用できるモードは引数 Mode で指定するのですが、モードには以下の種類があります。<br><br>

<table BORDER=2 CELLSPACING=5 CELLPADDING=5>
	<tr><td>DX_CMP_NEVER</td><td>描画アルファ値がどのような値でも描画しない</td></tr>
	<tr><td>DX_CMP_LESS</td><td>描画アルファ値が Param より小さい場合は描画する</td></tr>
	<tr><td>DX_CMP_EQUAL</td><td>描画アルファ値が Param と等しい場合は描画する</td></tr>
	<tr><td>DX_CMP_LESSEQUAL</td><td>描画アルファ値が Param と同じか、より小さい場合は描画する</td></tr>
	<tr><td>DX_CMP_GREATER</td><td>描画アルファ値が Param より大きい場合は描画する</td></tr>
	<tr><td>DX_CMP_NOTEQUAL</td><td>描画アルファ値が Param と異なる場合は描画する</td></tr>
	<tr><td>DX_CMP_GREATEREQUAL</td><td>描画アルファ値が Param と同じか、より大きい場合は描画する</td></tr>
	<tr><td>DX_CMP_ALWAYS</td><td>描画アルファ値がどのような値でも描画する</td></tr>
</table>
<br>

                    　DX_CMP_NEVER と DX_CMP_ALWAYS 以外のモードでは引数 Param で指定するアルファ値を比較用の値として使用します。<br>
                    　大体は『一定以上のアルファ値の場合のみ描画するようにしたい』ので、DX_CMP_GREATER か DX_CMP_GREATEREQUAL を使用します。<br><br>

		    　例：マテリアル番号１を透明度が８０％以下(アルファ値が51以上)の部分のみ描画するように設定する<br><br>

                    　　　MV1SetMaterialDrawAlphaTest( MHandle, 1, TRUE, DX_CMP_GREATEREQUAL, 51 ) ;<br><br>

                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　　ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N36">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialDrawAlphaTestAll( int MHandle, int Enable, int Mode, int Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>全てのマテリアルの描画アルファテストの設定を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int Enable ： アルファテストを有効にするかどうか( TRUE：有効にする　FALSE：無効にする（デフォルト） )<br>
	    int Mode ： テストモード( DX_CMP_GREATER等 )<br>
	    int Param ： 描画アルファ値との比較に使用する値( 0〜255 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれる全てのマテリアルに対して描画時にアルファテストを行うかどうかや、行う場合のテストモードを変更します。<br><br>

                    　<b><a href="#R5N35">MV1SetMaterialDrawAlphaTest</a></b> の処理を全てのマテリアルに対して行うという以外は全て MV1SetMaterialDrawAlphaTest と同じなので、
		    引数の解説などは MV1SetMaterialDrawAlphaTest の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                　　ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N27">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialOutLineWidth( int MHandle, int MaterialIndex, float Width ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのトゥーンレンダリングで使用する輪郭線の太さを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号<br>
            float Width ： 輪郭線の太さ
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの立体的な( カメラとモデルとの距離に影響される )輪郭線の太さを変更します。<br>
                    　輪郭線は pmd ファイルを読み込んだ場合に表示されます。<br><br><br>

                    <b>＜＜輪郭線の太さ決定の仕組み＞＞</b><br><br>

                    　輪郭線は立体的な太さ( MV1SetMaterialOutLineWidth で指定する太さ )と、平面的な太さ( <b><a href="#R5N26">MV1SetMaterialOutLineDotWidth</a></b> で指定する太さ )の二種類があります。<br>
                    　立体的な太さはカメラとモデルとの距離で実際に画面に描画される輪郭線の太さが変化します。( 離れれば離れるほど細く、近づけば近づくほど太く )<br>
                    　平面的な太さはカメラとモデルとの距離に関係なく常に一定の太さで描画されます。<br><br>

                    　ＤＸライブラリでは、立体的・平面的の両方の計算で太さを求め、より太い結果の太さを用いて輪郭線を描画します。<br>
                    　これは「近づけば近づくほど輪郭線は太くなって欲しいけど、どれだけ離れても最低限の太さで輪郭線を描画したい」
                    という処理を実現するためにこうなりました。<br><br>

                    　尚、より太い計算結果を採用する関係で、輪郭線を描画したくない場合は MV1SetMaterialOutLineWidth と <b><a href="#R5N26">MV1SetMaterialOutLineDotWidth</a></b> の両方で太さを 0.0f に設定する必要があります。<br><br>

                    　また、<b><a href="#R3N4">MV1SetScale</a></b> でモデルのスケールを変更するとこのパラメータにもスケーリングが掛かってしまいますので注意してください。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N28">宣言</a></b></td><td><font color="#000088"><b>float MV1GetMaterialOutLineWidth( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのトゥーンレンダリングで使用する輪郭線の太さを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>輪郭線の太さ</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの立体的な輪郭線の太さを取得します。<br><br>

                　　　輪郭線の太さの詳細は <b><a href="#R5N27">MV1SetMaterialOutLineWidth</a></b> の解説を参照してください。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N29">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialOutLineDotWidth( int MHandle, int MaterialIndex, float Width ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのトゥーンレンダリングで使用する輪郭線のドット単位の太さを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号<br>
            float Width ： 輪郭線の太さ
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの平面的な( カメラとモデルとの距離に影響されない )輪郭線の太さを変更します。<br>
                    　輪郭線は pmd ファイルを読み込んだ場合に表示されます。<br><br>

                　　　輪郭線の太さの詳細は <b><a href="#R5N27">MV1SetMaterialOutLineWidth</a></b> の解説を参照してください。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N30">宣言</a></b></td><td><font color="#000088"><b>float MV1GetMaterialOutLineDotWidth( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのトゥーンレンダリングで使用する輪郭線のドット単位の太さを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>輪郭線の太さ</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの平面的な輪郭線の太さを取得します。<br><br>

                　　　輪郭線の太さの詳細は <b><a href="#R5N27">MV1SetMaterialOutLineWidth</a></b> の解説を参照してください。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N31">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMaterialOutLineColor( int MHandle, int MaterialIndex, COLOR_F Color ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのトゥーンレンダリングで使用する輪郭線の色を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号<br>
            COLOR_F Color ： 輪郭線の色
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの輪郭線の色を変更します。デフォルトの輪郭線の色は真っ黒 GetColorF( 0.0f, 0.0f, 0.0f, 1.0f ) です。<br>
                    　色の値の取得は <b><a href="#R14N14">GetColorF</a></b> を使うと便利です。<br>
                    　尚、輪郭線は pmd ファイルを読み込んだ場合に表示されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R5N32">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMaterialOutLineColor( int MHandle, int MaterialIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルのトゥーンレンダリングで使用する輪郭線の色を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MaterialIndex ： マテリアルの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>輪郭線の色</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるマテリアルの輪郭線の色を取得します。<br><br>
                    　基本的に <b><a href="#R5N31">MV1SetMaterialOutLineColor</a></b> で設定した値を返すだけの関数です。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br><br><br>
        </td></tr>


        <tr><td><font size="3" color="#005500"><b>テクスチャ関係</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N1">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTextureNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルで使用されているテクスチャの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：モデルで使用されているテクスチャの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用されているテクスチャの総数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo で使用されているテクスチャの情報を一つづつ描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int i, TextureNum ;
    int Width, Height, GrHandle ;
    const char *String ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // モデルに含まれるテクスチャの総数を取得する
    TextureNum = MV1GetTextureNum( ModelHandle ) ;

    // テクスチャの数だけ繰り返し
    for( i = 0 ; i &lt; TextureNum ; i ++ )
    {
        // 画面をクリアする
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // テクスチャのグラフィックハンドルを取得する
        GrHandle = <b><a href="#R15N4">MV1GetTextureGraphHandle</a></b>( ModelHandle, i ) ;

        // テクスチャの名前を描画する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),  "Name                  %s", <b><a href="#R15N2">MV1GetTextureName</a></b>( ModelHandle, i ) ) ;

        // テクスチャの大きさを描画する
        GetGraphSize( GrHandle, &amp;Width, &amp;Height ) ;
        DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Size                  %dx%d", Width, Height ) ;

        // テクスチャのＵ値のアドレスモードを描画する
        switch( <b><a href="#R15N6">MV1GetTextureAddressModeU</a></b>( ModelHandle, i ) )
        {
        case DX_TEXADDRESS_WRAP   : String = "DX_TEXADDRESS_WRAP" ;   break ;
        case DX_TEXADDRESS_MIRROR : String = "DX_TEXADDRESS_MIRROR" ; break ;
        case DX_TEXADDRESS_CLAMP  : String = "DX_TEXADDRESS_CLAMP" ;  break ;
        }
        DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Address Mode U        %s", String ) ;

        // テクスチャのＶ値のアドレスモードを描画する
        switch( <b><a href="#R15N7">MV1GetTextureAddressModeV</a></b>( ModelHandle, i ) )
        {
        case DX_TEXADDRESS_WRAP   : String = "DX_TEXADDRESS_WRAP" ;   break ;
        case DX_TEXADDRESS_MIRROR : String = "DX_TEXADDRESS_MIRROR" ; break ;
        case DX_TEXADDRESS_CLAMP  : String = "DX_TEXADDRESS_CLAMP" ;  break ;
        }
        DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Address Mode V        %s", String ) ;

        // テクスチャのフィルタリングモードを描画する
        switch( <b><a href="#R15N9">MV1GetTextureSampleFilterMode</a></b>( ModelHandle, i ) )
        {
        case DX_DRAWMODE_NEAREST :     String = "DX_DRAWMODE_NEAREST" ;     break ;
        case DX_DRAWMODE_BILINEAR :    String = "DX_DRAWMODE_BILINEAR" ;    break ;
        case DX_DRAWMODE_ANISOTROPIC : String = "DX_DRAWMODE_ANISOTROPIC" ; break ;
        }
        DrawFormatString( 0, 64, GetColor( 255,255,255 ), "Sample Filter Mode    %s", String ) ;

        // テクスチャを描画する
        <b><a href="dxfunc_graph1.html#R3N7">DrawGraph</a></b>( 0, 80, GrHandle, TRUE ) ;

        // キー入力待ち
        <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N2">宣言</a></b></td><td><font color="#000088"><b>const char *MV1GetTextureName( int MHandle, int TexIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャの名前を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>NULL以外：テクスチャの名前( ファイルパスではありません )</td></tr>
            <tr><td width="100">　</td><td>NULL：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用されているテクスチャの名前を取得します。<br>
                    　xファイル や mqoファイルではテクスチャの名前という情報が無いので、
                    ファイル名がテクスチャの名前として使用されます。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R15N1">MV1GetTextureNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N3">宣言</a></b></td><td><font color="#000088"><b>int MV1SetTextureGraphHandle( int MHandle, int TexIndex, int GrHandle, int SemiTransFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャとして使用するグラフィックハンドルを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号<br>
            int GrHandle ： テクスチャとして使用するグラフィックハンドル<br>
            int SemiTransFlag ： グラフィックハンドルに半透明要素があるかどうか( TRUE：ある  FALSE：ない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用するテクスチャのグラフィックハンドルを変更します。<br>
                    　変更後はモデル中の変更されたテクスチャを使用しているマテリアルの部分が GrHandle で指定した画像になります。<br>
                    　色違いキャラクターを表現したりする場合に便利です。<br><br>

                    　尚、３Ｄモデルは半透明要素があるかどうかの情報をよく使いますので、
                    セットするグラフィックハンドルに半透明の部分があるかどうかを SemiTransFlag で指定します、ある場合は TRUE を、無い場合は FALSE を渡してください。<br><br>

                    　注意点として、GrHandle に渡すグラフィックハンドルの画像の幅や高さは 2 の n乗( 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 ... )
                    である必要があり、また、LoadDivGraph で分割読込した画像や、DerivationGraph で派生させた画像は使用することができません。
                    ( エラーにはなりませんが期待する描画結果は得られません )<br><br>

                    　画像のサイズについては、グラフィックスデバイスの性能によって扱える画像の最大サイズが変化しますので。<br>
                    　2009年時点で多くの環境で安心して使える画像の最大サイズは恐らく 2048 くらいまで、
                    ３Ｄ機能を持ち始めたばかりのノートパソコン等では 1024 くらいまでの対応となります。<br><br>

                    　因みに、GrHandle に -1 を渡すと元のテクスチャのグラフィックハンドルを使用するようになります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x で使用されている目のテクスチャを緑色の目の画像に変更します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int GrHandle ;
    int TexIndex ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // 緑色の目の画像の読みこみ
    GrHandle = <b><a href="dxfunc_graph1.html#R3N2">LoadGraph</a></b>( "DxCharaEye2.tga" ) ;

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // モデルを画面に映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 400.0f ) ) ;

    // 目の部分のマテリアルで使用されているテクスチャの番号を取得
    TexIndex = <b><a href="#R5N24">MV1GetMaterialDifMapTexture</a></b>( ModelHandle, 4 ) ;

    // テクスチャで使用するグラフィックハンドルを変更する
    MV1SetTextureGraphHandle( ModelHandle, TexIndex, GrHandle, FALSE ) ;

    // モデルを描画する
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N4">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTextureGraphHandle( int MHandle, int TexIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャのグラフィックハンドルを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：テクスチャのグラフィックハンドル</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用されているテクスチャで使用されるグラフィックハンドルを取得します。<br>
                    　取得したグラフィックハンドルは普通のグラフィックハンドルと同じように <b><a href="dxfunc_graph1.html#R3N7">DrawGraph</a></b> で描画したり、
                    GetGraphSize でサイズを取得したりすることができます。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R15N1">MV1GetTextureNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N5">宣言</a></b></td><td><font color="#000088"><b>int MV1SetTextureAddressMode( int MHandle, int TexIndex, int AddrUMode, int AddrVMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャのアドレスモードを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号<br>
            int AddrUMode ： Ｕ値のアドレスモード<br>
            int AddrVMode ： Ｖ値のアドレスモード
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用するテクスチャを描画する際に使用されるアドレスモードを変更します。<br><br>
                
                    　アドレスモードとは画像サイズ以上のテクスチャ座標が指定された場合にどう表示するかというもので、以下の３種類があります。<br><br><br>

                    DX_TEXADDRESS_WRAP<br><br>

                    　画像サイズ以上のテクスチャ座標の部分は素直に繰り返します。<br><br><br>


                    DX_TEXADDRESS_MIRROR<br><br>

                    　画像サイズ以上のテクスチャ座標の部分は鏡に映されたように反転する表示と、もとの反転していない表示とを繰り返します。<br>
                    　例えば４倍のテクスチャ座標が指定された場合　通常の見た目・反転した見た目・通常の見た目・反転した見た目　という風になります。<br><br><br>

                    DX_TEXADDRESS_CLAMP<br><br>

                    　他のモードと違って画像が繰り返されず、画像サイズ以上のテクスチャ座標の部分は画像の端のピクセルが引き伸ばされたような見た目になります。<br><br><br>

                    　アドレスモードはＵ方向とＶ方向で別々に指定することができます。<br>
                    　初期状態ではＵ，Ｖ共に DX_TEXADDRESS_WRAP です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル AddressTest.mqo で使用されているテクスチャのアドレスモードを、横方向は DX_TEXADDRESS_MIRROR に<br>
            　縦方向は DX_TEXADDRESS_CLAMP にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "AddressTest.mqo" ) ;

    // モデルを画面に映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 400.0f ) ) ;

    // テクスチャ０番のアドレスモードを横方向は DX_TEXADDRESS_MIRROR に、
    // 縦方向は DX_TEXADDRESS_CLAMP に変更する
    <b><a href="#R15N5">MV1SetTextureAddressMode</a></b>( ModelHandle, 0, DX_TEXADDRESS_MIRROR, DX_TEXADDRESS_CLAMP ) ;

    // モデルを描画する
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N6">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTextureAddressModeU( int MHandle, int TexIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャのＵ値のアドレスモードを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：テクスチャのＵ値のアドレスモード</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用されているテクスチャを描画する際に使用されるＵ値のアドレスモードを取得します。<br>
                    　戻り値であるアドレスモードについては関数 <b><a href="#R15N5">MV1SetTextureAddressMode</a></b> の解説を参照してください。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R15N1">MV1GetTextureNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N7">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTextureAddressModeV( int MHandle, int TexIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャのＶ値のアドレスモードを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：テクスチャのＶ値のアドレスモード</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用されているテクスチャを描画する際に使用されるＶ値のアドレスモードを取得します。<br>
                    　戻り値であるアドレスモードについては関数 <b><a href="#R15N5">MV1SetTextureAddressMode</a></b> の解説を参照してください。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R15N1">MV1GetTextureNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N8">宣言</a></b></td><td><font color="#000088"><b>int MV1SetTextureSampleFilterMode( int MHandle, int TexIndex, int FilterMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャのフィルタリングモードを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号<br>
            int FilterMode ： フィルタリングモード
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用するテクスチャを描画する際に使用されるフィルタリングモードを変更します。<br><br>
                
                    　フィルタリングモードはポリゴンに貼り付けられ、変形して画面に表示されることになるテクスチャをどのように描画するかと言うもので、以下の３種類があります。<br><br><br>

                    DX_DRAWMODE_NEAREST<br><br>

                    　最近点フィルタリング方式です。<br>
                    　画面にピクセルを描画する際に、テクスチャ中の計算上一番適している１ピクセルのみを使って描画します。<br>
                    　画面にテクスチャの解像度以上の大きさに描画されるとドットが四角く表示されます。<br><br>


                    DX_DRAWMODE_BILINEAR<br><br>

                    　線形フィルタリング方式です。<br>
                    　画面にピクセルを描画する際に、テクスチャ中の計算上適している上位４ピクセルの色を合成して描画します。<br>
                    　画面にテクスチャの解像度以上の大きさに描画されると、
                    ドット同士の色の合成が行われるので DX_DRAWMODE_NEAREST と違いボヤっとした見た目になります。<br><br>


                    DX_DRAWMODE_ANISOTROPIC<br><br>

                    　異方性フィルタリング方式です。<br>
                    　画面に描画するピクセルの色を複雑な計算をして決定します。<br>
                    　画面に拡大されて描画される際は DX_DRAWMODE_BILINEAR とあまり違いはありませんが、
                    画面に元の画像よりも小さく、つまり縮小されて描画される場合は DX_DRAWMODE_BILINEAR より良好な描画結果が得られます。( デフォルトではこのタイプです )<br><br><br>

                    　因みに描画負荷は DX_DRAWMODE_ANISOTROPIC が一番重く、
                    次に DX_DRAWMODE_BILINEAR、一番軽いのは DX_DRAWMODE_NEAREST です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル FilterTest.mqo で使用されているテクスチャのフィルタリングモードを DX_DRAWMODE_NEAREST にして描画します。<br>
            　　ドットとドットの間がくっきり分かれた見た目になります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "FilterTest.mqo" ) ;

    // モデルを画面に映る位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 400.0f ) ) ;

    // テクスチャ０番のフィルタリングモードを DX_DRAWMODE_NEAREST に変更
    <b><a href="#R15N8">MV1SetTextureSampleFilterMode</a></b>( ModelHandle, 0, DX_DRAWMODE_NEAREST ) ;

    // モデルを描画する
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R15N9">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTextureSampleFilterMode( int MHandle, int TexIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>テクスチャのフィルタリングモードを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TexIndex ： テクスチャの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：テクスチャのフィルタリングモード</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルで使用されているテクスチャを描画する際に使用されるフィルタリングモードを取得します。<br>
                    　戻り値であるアドレスモードについては関数 <b><a href="#R15N8">MV1SetTextureSampleFilterMode</a></b> の解説を参照してください。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R15N1">MV1GetTextureNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><font size="3" color="#005500"><b>フレーム関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N1">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>−１以外：モデルに含まれるフレームの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれるフレームの情報を一つづつ表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, FrameNum, i, Parent ;
    VECTOR Position ;
    MATRIX Matrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // フレームの数を取得する
    FrameNum = <b><a href="#R6N1">MV1GetFrameNum</a></b>( ModelHandle ) ;

    // フレームの数だけループ
    for( i = 0 ; i &lt; FrameNum ; i ++ )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // フレーム名の描画
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),      "Name         %s", <b><a href="#R6N4">MV1GetFrameName</a></b>( ModelHandle, i ) ) ;

        // 親フレーム名の描画
        Parent = <b><a href="#R6N5">MV1GetFrameParent</a></b>( ModelHandle, i ) ;
        if( Parent == -2 )
        {
            DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Parent Name  None" ) ;
        }
        else
        {
            DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Parent Name  %s", MV1GetFrameName( ModelHandle, Parent ) ) ;
        }

        // 子フレームの数を描画
        DrawFormatString( 0, 32, GetColor( 255,255,255 ),     "Child Num    %d", <b><a href="#R6N6">MV1GetFrameChildNum</a></b>( ModelHandle, i ) ) ;

        // フレームのワールド座標の描画
        Position = <b><a href="#R6N8">MV1GetFramePosition</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 48, GetColor( 255,255,255 ),     "Position     x:%f y:%f z:%f", Position.x, Position.y, Position.z ) ;

        // 変換行列を描画する
        Matrix = <b><a href="#R6N10">MV1GetFrameLocalMatrix</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 64,  GetColor( 255,255,255 ),    "   Matrix    %f %f %f %f", Matrix.m[ 0 ][ 0 ], Matrix.m[ 0 ][ 1 ], Matrix.m[ 0 ][ 2 ], Matrix.m[ 0 ][ 3 ] ) ;
        DrawFormatString( 0, 80,  GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 1 ][ 0 ], Matrix.m[ 1 ][ 1 ], Matrix.m[ 1 ][ 2 ], Matrix.m[ 1 ][ 3 ] ) ;
        DrawFormatString( 0, 96,  GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 2 ][ 0 ], Matrix.m[ 2 ][ 1 ], Matrix.m[ 2 ][ 2 ], Matrix.m[ 2 ][ 3 ] ) ;
        DrawFormatString( 0, 112, GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 3 ][ 0 ], Matrix.m[ 3 ][ 1 ], Matrix.m[ 3 ][ 2 ], Matrix.m[ 3 ][ 3 ] ) ;

        // フレームのローカル座標からワールド座標に変換する行列を描画する
        Matrix = <b><a href="#R6N9">MV1GetFrameLocalWorldMatrix</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 128,  GetColor( 255,255,255 ),   "LW Matrix    %f %f %f %f", Matrix.m[ 0 ][ 0 ], Matrix.m[ 0 ][ 1 ], Matrix.m[ 0 ][ 2 ], Matrix.m[ 0 ][ 3 ] ) ;
        DrawFormatString( 0, 144,  GetColor( 255,255,255 ),   "             %f %f %f %f", Matrix.m[ 1 ][ 0 ], Matrix.m[ 1 ][ 1 ], Matrix.m[ 1 ][ 2 ], Matrix.m[ 1 ][ 3 ] ) ;
        DrawFormatString( 0, 160,  GetColor( 255,255,255 ),   "             %f %f %f %f", Matrix.m[ 2 ][ 0 ], Matrix.m[ 2 ][ 1 ], Matrix.m[ 2 ][ 2 ], Matrix.m[ 2 ][ 3 ] ) ;
        DrawFormatString( 0, 176, GetColor( 255,255,255 ),    "             %f %f %f %f", Matrix.m[ 3 ][ 0 ], Matrix.m[ 3 ][ 1 ], Matrix.m[ 3 ][ 2 ], Matrix.m[ 3 ][ 3 ] ) ;

        // フレームの表示状態を描画
        DrawFormatString( 0, 192, GetColor( 255,255,255 ),    "Visible      %d", <b><a href="#R6N14">MV1GetFrameVisible</a></b>( ModelHandle, i ) ) ;

        // フレームに半透明要素があるかどうかを描画
        DrawFormatString( 0, 208, GetColor( 255,255,255 ),    "Semi Trans   %d", <b><a href="#R6N23">MV1GetFrameSemiTransState</a></b>( ModelHandle, i ) ) ;

        // フレームに含まれるメッシュの数を描画
        DrawFormatString( 0, 224, GetColor( 255,255,255 ),    "Mesh Num     %d", <b><a href="#R6N27">MV1GetFrameMeshNum</a></b>( ModelHandle, i ) ) ;

        // フレームに含まれる三角形ポリゴンの数を描画
        DrawFormatString( 0, 240, GetColor( 255,255,255 ),    "Triangle Num %d", <b><a href="#R6N26">MV1GetFrameTriangleNum</a></b>( ModelHandle, i ) ) ;

        // キーの入力待ち
        <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N2">宣言</a></b></td><td><font color="#000088"><b>int MV1SearchFrame( int MHandle, char *FrameName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定名のフレームをモデル中から検索する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            char *FrameName ： フレーム名
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：指定名のフレームの番号</td></tr>
            <tr><td              WIDTH=100>　           </td><td>−２：指定名のフレームが見つからなかった</td></tr>
            <tr><td              WIDTH=100>　           </td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームから、指定の名前のものを検索します。<br><br>

                    　同名のフレームが複数含まれる場合は番号の若いフレームが返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる名前が Mesh_1 のフレームの番号を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // フレーム名 Mesh_1 のフレームの番号を画面に描画する
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "%d", MV1SearchFrame( ModelHandle, "Mesh_1" ) ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N3">宣言</a></b></td><td><font color="#000088"><b>int MV1SearchFrameChild( int MHandle, int FrameIndex, char *ChildName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定名のフレームを指定のフレームの子フレームの中から検索する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： 検索対象のフレームの番号<br>
            char *ChildName ： フレーム名
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：指定名のフレームの番号</td></tr>
            <tr><td              WIDTH=100>　           </td><td>−２：指定名のフレームが見つからなかった</td></tr>
            <tr><td              WIDTH=100>　           </td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデル内の指定のフレームが持つ子フレームの中から、指定の名前のフレームを検索します。<br><br>

                    　指定のフレームが持つ子フレームだけではなく、子フレームが持つ子フレームも検索の対象になります。<br>
                    　同名のフレームが含まれる場合は番号の若いフレームが返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる２番目のフレームの子フレームの中から Koshi という名前のフレームの番号を検索します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // モデルの２番目のフレームが持つ子フレームの中から AnkleR という名前のフレームの番号を検索して画面に描画する
    <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "%d", MV1SearchFrameChild( ModelHandle, 2, "AnkleR" ) ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N4">宣言</a></b></td><td><font color="#000088"><b>char *MV1GetFrameName( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの名前を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>NULL以外：フレームの名前</td></tr>
            <tr><td width="100">　</td><td>NULL：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの名前を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N5">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameParent( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの親フレームを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：親フレームの番号</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−２：親フレームが無い</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの親フレームのフレーム番号を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N6">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameChildNum( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの子フレームの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：子フレームの数</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームが持つ子フレームの数を取得します。<br><br>

                    　FrameIndex を -1 にすると親が居ないフレームの数が返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる０番目のフレームの子フレームの名前を描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, i, ChildNum, FrameIndex ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // フレーム０番の子フレームの数を取得
    ChildNum = <b><a href="#R6N6">MV1GetFrameChildNum</a></b>( ModelHandle, 0 ) ;

    // 子フレームの数だけループ
    for( i = 0 ; i &lt; ChildNum ; i ++ )
    {
        // 子フレームのフレーム番号を取得
        FrameIndex = <b><a href="#R6N7">MV1GetFrameChild</a></b>( ModelHandle, 0, i ) ;

        // 子フレームの名前を表示
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, i * 16, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "%s", <b><a href="#R6N4">MV1GetFrameName</a></b>( ModelHandle, FrameIndex ) ) ;
    }

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N7">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameChild( int MHandle, int FrameIndex, int ChildIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの子フレームを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            int ChildIndex ： 子フレーム番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：子フレームのフレーム番号</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームが持つ子フレームのフレーム番号を取得します。<br><br>

                    　FrameIndex を -1 にすると、親の居ないフレームが取得できます。<br><br>

                    　尚、ChildIndex に <b><a href="#R6N6">MV1GetFrameChildNum</a></b> 関数で取得できる子フレームの数以上の値を渡すとエラーとなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　<a href="#R6N6">MV1GetFrameChildNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N8">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetFramePosition( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの座標を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームのワールド座標</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームのワールド座標を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N10">宣言</a></b></td><td><font color="#000088"><b>MATRIX MV1GetFrameLocalMatrix( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの座標変換行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームの変換行列</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの変換行列を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N9">宣言</a></b></td><td><font color="#000088"><b>MATRIX MV1GetFrameLocalWorldMatrix( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのローカル座標からワールド座標に変換する行列を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームのローカル→ワールド行列<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームのローカル座標からワールド座標に変換する行列を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N11">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameUserLocalMatrix( int MHandle, int FrameIndex, MATRIX Matrix ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの座標変換行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            MATRIX Matrix ： フレームに設定する変換行列
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの変換行列として引数で渡す Matrix の値を使用するようにします。<br><br>

                    　この関数を使用して行列を設定すると、
                    以降 <b><a href="#R6N12">MV1ResetFrameUserLocalMatrix</a></b> で設定が解除されるまでこの関数で設定した行列が使用されます。
                    ( 行列を設定したフレームに対するキーが打たれているアニメーションを再生しても、
                    この関数で設定した行列が優先されます )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる２番目のフレームの変換行列を下方向に 300.0f 移動する<br>
            　行列にしてから描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // モデルを見える位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 800.0f ) ) ;

    // ２番目のフレームに下に動くのローカル行列をセットする
    <b><a href="#R6N11">MV1SetFrameUserLocalMatrix</a></b>( ModelHandle, 2, <b><a href="#R11N16">MGetTranslate</a></b>( VGet( 0.0f, -300.0f, 0.0f ) ) ) ; 

    // モデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N12">宣言</a></b></td><td><font color="#000088"><b>int MV1ResetFrameUserLocalMatrix( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの座標変換行列をデフォルトに戻す<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　関数 <b><a href="#R6N11">MV1SetFrameUserLocalMatrix</a></b> で設定した行列の効果を解除します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる２番目のフレームの変換行列を下方向に 300.0f 移動する<br>
            　行列をセットしたり解除したりを１秒単位で行いつつ描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, Time, UseMatrix ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // モデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // モデルを見える位置に移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 800.0f ) ) ;

    // 行列を使用するかどうかのフラグを１にする
    UseMatrix = 1 ;

    // 現在のタイムカウントを記録しておく
    Time = <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b>() ;

    // 何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // １秒経つ毎に独自の行列を使用するかどうかを変更する
        if( <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b>() - Time > 1000 )
        {
            // フラグによって処理を分岐
            if( UseMatrix == 1 )
            {
                // ２番目のフレームに下に動くのローカル行列をセットする
                <b><a href="#R6N11">MV1SetFrameUserLocalMatrix</a></b>( ModelHandle, 2, <b><a href="#R11N16">MGetTranslate</a></b>( VGet( 0.0f, -300.0f, 0.0f ) ) ) ;

                // フラグを０にする
                UseMatrix = 0 ;
            }
            else
            {
                // ２番目のフレームに設定した行列を無効化する
                <b><a href="#R6N12">MV1ResetFrameUserLocalMatrix</a></b>( ModelHandle, 2 ) ;

                // フラグを１にする
                UseMatrix = 1 ;
            }

            // 現在のタイムカウントを記録しておく
            Time = <b><a href="dxfunc_other.html#R7N1">GetNowCount</a></b>() ;
        }

        // モデルを描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N13">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameVisible( int MHandle, int FrameIndex, int VisibleFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの表示・非表示状態を変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            int VisibleFlag ： 表示状態( TRUE：表示　FALSE：非表示 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの表示状態を変更します。<br><br>

                    　VisibleFlag に FALSE を渡すと、指定のフレームが持つメッシュ、及び指定のフレームの子フレームが持つメッシュと子フレームの子フレームが持つメッシュも描画されなくなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームの表示状態を「非表示」にして描画します。<br>
            　「円柱」フレームの子フレームである「子円柱」も一緒に表示されなくなります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // １番のフレームの表示状態を「非表示」にする
    <b><a href="#R6N13">MV1SetFrameVisible</a></b>( ModelHandle, 1, FALSE ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N14">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameVisible( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの表示・非表示状態を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：フレームの表示状態( TRUE：表示  FALSE：非表示 )</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるフレームの表示状態を取得します。<br><br>

                    　親フレームの表示状態が仮に「非表示」になっていても、この関数はあくまで指定のフレームに設定されている表示状態を返します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N15">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameDifColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのディフューズカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる３番目のフレームのディフューズカラーを赤にします。<br>
            　「立方体」フレームの子フレームである「子立方体」も一緒に赤色になります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // ３番のフレームのディフューズカラーを赤にする
    <b><a href="#R6N15">MV1SetFrameDifColorScale</a></b>( ModelHandle, 3, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N16">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetFrameDifColorScale( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのディフューズカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームのディフューズカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を取得します。<br><br>

                    　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して <b><a href="#R6N15">MV1SetFrameDifColorScale</a></b> 関数で設定された値をそのまま返します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N17">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameSpcColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのスペキュラカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームのスペキュラカラーを黄色にします。<br>
            　「円柱」フレームの子フレームである「子円柱」も一緒に黄色になります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // １番のフレームのスペキュラカラーを黄色にする
    <b><a href="#R6N17">MV1SetFrameSpcColorScale</a></b>( ModelHandle, 1, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 1.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N18">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetFrameSpcColorScale( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのスペキュラカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームのスペキュラカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を取得します。<br><br>

                    　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して <b><a href="#R6N17">MV1SetFrameSpcColorScale</a></b> 関数で設定された値をそのまま返します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N19">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameEmiColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのエミッシブカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームのエミッシブカラーを水色にします。<br>
            　「円柱」フレームの子フレームである「子円柱」も一緒に水色になります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // １番のフレームのエミッシブカラーのスケール値を水色にする
    <b><a href="#R6N19">MV1SetFrameEmiColorScale</a></b>( ModelHandle, 1, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 1.0f, 1.0f, 0.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N20">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetFrameEmiColorScale( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのエミッシブカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームのエミッシブカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を取得します。<br><br>

                    　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して <b><a href="#R6N19">MV1SetFrameEmiColorScale</a></b> 関数で設定された値をそのまま返します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N21">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameAmbColorScale( int MHandle, int FrameIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのアンビエントカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる１番目のフレームのアンビエントカラーを紫色にします。<br>
            　「円柱」フレームの子フレームである「子円柱」も一緒に水色になります。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // １番のフレームのアンビエントカラーのスケール値を紫色にする
    <b><a href="#R6N21">MV1SetFrameAmbColorScale</a></b>( ModelHandle, 1, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 1.0f, 0.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N22">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetFrameAmbColorScale( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのアンビエントカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームのアンビエントカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を取得します。<br><br>

                    　スケーリングの影響は子フレームにも及びますが、この関数は指定のフレームに対して <b><a href="#R6N21">MV1SetFrameAmbColorScale</a></b> 関数で設定された値をそのまま返します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N23">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameSemiTransState( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームに半透明要素があるかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：半透明要素がある　FALSE：半透明要素は無い</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに半透明の要素があるかどうかを取得します。<br><br>

                    　例えば、フレーム内のメッシュが使用しているマテリアルのテクスチャに半透明の部分があったり、
                    指定のフレームや子フレームの何れかの不透明が 1.0f ではなかったりすると TRUE が返ってきます。<br><br>

                    　半透明要素を持つフレーム同士をＺソートする場合に、各フレームに半透明要素があるかどうかを判定する際などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo の３番目のフレームの不透明度を上下キーで操作できるようにした上で、
              画面上に MV1GetFrameSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float OpacityRate ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 100.0f, 600.0f ) ) ;

    // 不透明度を初期化
    OpacityRate = 1.0f ;

    // ESCキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面のクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 上キーが押されたら不透明度を上げる
        if( CheckHitKey( KEY_INPUT_UP ) )
        {
            OpacityRate += 0.05f ;
            if( OpacityRate > 1.0f )
            {
                OpacityRate = 1.0f ;
            }
        }

        // 下キーが押されたら不透明度を下げる
        if( CheckHitKey( KEY_INPUT_DOWN ) )
        {
            OpacityRate -= 0.05f ;
            if( OpacityRate < 0.0f )
            {
                OpacityRate = 0.0f ;
            }
        }

        // ３番目のフレームの不透明度を設定する
        <b><a href="#R6N24">MV1SetFrameOpacityRate</a></b>( ModelHandle, 3, OpacityRate ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 現在の３番目のフレームの不透明度と、MV1GetFrameOpacityState の戻り値を描画する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),
            "ESC Key:Exit OpacityRate:%f SemiTransState:%d",
            OpacityRate, <b><a href="#R6N23">MV1GetFrameSemiTransState</a></b>( ModelHandle, 3 ) ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N24">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameOpacityRate( int MHandle, int FrameIndex, float Rate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの不透明度を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            float Rate ： 不透明度( 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームの不透明度を設定します。<br><br>

                    　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、
                    1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。<br>
                    　指定のフレームの子フレームにも影響を与えます。<br><br>

                    　モデルの一部のフレームを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo の１番目のフレームの不透明度を５０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 100.0f, 600.0f ) ) ;

    // ３Ｄモデルの１番目のフレームの不透明度を50%にする
    <b><a href="#R6N24">MV1SetFrameOpacityRate</a></b>( ModelHandle, 1, 0.5f ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N25">宣言</a></b></td><td><font color="#000088"><b>float MV1GetFrameOpacityRate( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの不透明度を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>フレームに設定されている不透明度<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに設定されている不透明度を取得します。<br>
                    　<b><a href="#R6N24">MV1SetFrameOpacityRate</a></b> でセットした値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N29">宣言</a></b></td><td><font color="#000088"><b>int MV1SetFrameTextureAddressTransform( int MHandle, int FrameIndex, float TransU, float TransV, float ScaleU, float ScaleV, float RotCenterU, float RotCenterV, float Rotate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのテクスチャ座標変換パラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            float TransU ： テクスチャ座標のＵ値に加算する値( 初期値 0.0f )<br>
            float TransV ： テクスチャ座標のＶ値に加算する値( 初期値 0.0f )<br>
            float ScaleU ： テクスチャ座標のＵ値に掛ける値( 初期値 1.0f )<br>
            float ScaleV ： テクスチャ座標のＶ値に掛ける値( 初期値 1.0f )<br>
            float RotCenterU ： テクスチャ座標の回転中心となるＵ値( 初期値 0.0f )<br>
            float RotCenterV ： テクスチャ座標の回転中心となるＶ値( 初期値 0.0f )<br>
            float Rotate ： テクスチャ座標の回転値（ 単位はラジアン ）( 初期値 0.0f )<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                    　メッシュのテクスチャ座標に対して行う変換処理のパラメータを設定します。<br><br>

                    　用途としては、例えばキャラクターの顔のテクスチャに複数の表情を予め描いておいて、
                    表情を変えたいタイミングでその表情が描かれているテクスチャ座標に TransU と TransV
                    の引数を使用してメッシュに含まれる頂点のテクスチャ座標をスライドさせて描画される表情を変更する、などがあります。<br><br>

                    尚、各引数の意味は上記の注釈の通りですが、パラメータによる演算が行われる順序は<br><br>

                    １．RotCenterU, RotCenterV, Rotate による座標値の回転<br>
                    ２．TransU, TransV を座標値に加算<br>
                    ３．ScaleU, ScaleV による座標値の拡大<br><br>

                    となります。<br>
                    この関数による設定をリセットしたい場合は <b><a href="#R6N30">MV1ResetFrameTextureAddressTransform</a></b> を使用してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル TexAddrTransfTest.mqo を約１秒毎にテクスチャ座標をずらしてアニメーションさせます。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int WaitCounter, ViewPattern ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "TexAddrTransfTest.mqo" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 240.0f, 600.0f ) ) ;

    // 描画するパターンと、描画パターンを変更する間隔をカウントする変数の初期化
    ViewPattern = 0 ;
    WaitCounter = 0 ;

    // ＥＳＣキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 描画するパターンを変更する処理
        WaitCounter ++ ;
        if( WaitCounter == 60 )
        {
            WaitCounter = 0 ;

            // ６０フレーム経過したら描画パターンを変更
            ViewPattern ++ ;
            if( ViewPattern == 4 )
            {
                ViewPattern = 0 ;
            }
        }

        // 描画するパターンに応じてテクスチャ座標のＵ値をずらす値を変更
        MV1SetFrameTextureAddressTransform( ModelHandle, 0, 0.25f * ViewPattern, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 0.0f ) ;

        // モデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N30">宣言</a></b></td><td><font color="#000088"><b>int MV1ResetFrameTextureAddressTransform( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのテクスチャ座標変換パラメータをリセットする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
                　関数 <b><a href="#R6N29">MV1SetFrameTextureAddressTransform</a></b> で設定したテクスチャ座標変換パラメータを初期値にリセットします。
                効果的には MV1SetFrameTextureAddressTransform 関数の引数を注釈に「初期値」として記載されている値を渡して呼んだ場合と同じです。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N26">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameTriangleNum( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームに含まれるポリゴンの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：三角形ポリゴンの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれる三角形ポリゴンの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N1">MV1GetFrameNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N27">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameMeshNum( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームが持つメッシュの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：フレームに含まれるメッシュの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュの数を取得します。<br><br>

                    　この関数の戻り値には、子フレームが持つメッシュの数は含まれません。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の１番目のフレームに含まれるメッシュの情報を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, MeshNum, i, MeshIndex ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // １番目のフレームに含まれるメッシュの数を取得する
    MeshNum = <b><a href="#R6N27">MV1GetFrameMeshNum</a></b>( ModelHandle, 1 ) ;

    // メッシュの数だけループ
    for( i = 0 ; i &lt; MeshNum ; i ++ )
    {
        // メッシュ番号の取得
        MeshIndex = <b><a href="#R6N28">MV1GetFrameMesh</a></b>( ModelHandle, 1, i ) ;

        // メッシュが使用しているマテリアルとメッシュに含まれる三角形ポリゴンの数を描画
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, i * 16, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ), "Mesh No  %d   Material  %d    Triangle Polygon Num  %d",
            i, <b><a href="#R7N2">MV1GetMeshMaterial</a></b>( ModelHandle, MeshIndex ), <b><a href="#R7N3">MV1GetMeshTriangleNum</a></b>( ModelHandle, MeshIndex ) ) ;
    }

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R6N28">宣言</a></b></td><td><font color="#000088"><b>int MV1GetFrameMesh( int MHandle, int FrameIndex, int Index ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームの表示・非表示状態を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： フレームの番号<br>
            int Index ： フレーム内メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：メッシュの番号</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレームに含まれるメッシュの番号を取得します。<br><br>

                    　Index に <b><a href="#R6N27">MV1GetFrameMeshNum</a></b> 関数の戻り値以上の値を渡すとエラーになります。<br><br>

                    　取得したメッシュ番号は <b><a href="#R7N2">MV1GetMeshMaterial</a></b> などのメッシュ番号を必要とする関数で使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R6N27">MV1GetFrameMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>





        <tr><td><font size="3" color="#005500"><b>メッシュ関係</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N1">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルに含まれるメッシュの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：モデルに含まれるメッシュの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるメッシュの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x に含まれるメッシュの情報を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, MeshNum, i ;
    VECTOR Position ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // モデルに含まれるメッシュの数を取得する
    MeshNum = <b><a href="#R7N1">MV1GetMeshNum</a></b>( ModelHandle ) ;

    // メッシュの数だけループ
    for( i = 0 ; i &lt; MeshNum ; i ++ )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // メッシュが使用しているマテリアルの描画
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0,  0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),  "Material              %d", <b><a href="#R7N2">MV1GetMeshMaterial</a></b>( ModelHandle, i ) ) ;

        // メッシュに含まれる三角形ポリゴンの数を描画
        DrawFormatString( 0, 16, GetColor( 255,255,255 ),  "Triangle Polygon Num  %d", <b><a href="#R7N3">MV1GetMeshTriangleNum</a></b>( ModelHandle, i ) ) ;

        // メッシュの表示・非表示状態を描画
        DrawFormatString( 0, 32, GetColor( 255,255,255 ),  "Visible               %d", <b><a href="#R7N5">MV1GetMeshVisible</a></b>( ModelHandle, i ) ) ;

        // メッシュに半透明要素があるかどうかを描画
        DrawFormatString( 0, 48, GetColor( 255,255,255 ),  "Semi Trans State      %d", <b><a href="#R7N26">MV1GetMeshSemiTransState</a></b>( ModelHandle, i ) ) ;

        // メッシュがバックカリングを行うかどうかを描画
        DrawFormatString( 0, 64, GetColor( 255,255,255 ),  "Back Culling          %d", <b><a href="#R7N21">MV1GetMeshBackCulling</a></b>( ModelHandle, i ) ) ;

        // メッシュの頂点ディフューズカラーを使用するかどうかを描画
        DrawFormatString( 0, 80, GetColor( 255,255,255 ),  "Use Vertex Dif Color  %d", <b><a href="#R7N28">MV1GetMeshUseVertDifColor</a></b>( ModelHandle, i ) ) ;

        // メッシュの頂点スペキュラカラーを使用するかどうかを描画
        DrawFormatString( 0, 96, GetColor( 255,255,255 ),  "Use Vertex Spc Color  %d", <b><a href="#R7N30">MV1GetMeshUseVertSpcColor</a></b>( ModelHandle, i ) ) ;

        // メッシュに含まれる頂点のローカル座標の最大座標値を描画
        Position = <b><a href="#R7N22">MV1GetMeshMaxPosition</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 112, GetColor( 255,255,255 ), "Max Position          x %f  y %f  z %f", Position.x, Position.y, Position.z ) ;

        // メッシュに含まれる頂点のローカル座標の最小座標値を描画
        Position = <b><a href="#R7N23">MV1GetMeshMinPosition</a></b>( ModelHandle, i ) ;
        DrawFormatString( 0, 128, GetColor( 255,255,255 ), "Min Position          x %f  y %f  z %f", Position.x, Position.y, Position.z ) ;

        // キーの入力待ち
        <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N2">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshMaterial( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュが使用しているマテリアルの番号を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：マテリアルの番号</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュで使用されているマテリアルの番号を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N3">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshTriangleNum( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュに含まれる三角形ポリゴンの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：三角形ポリゴンの数</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる三角形ポリゴンの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N4">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshVisible( int MHandle, int MeshIndex, int VisibleFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの表示・非表示状態を変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int VisibleFlag ： 変更後の表示状態( TRUE：表示  FALSE：非表示 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュの表示状態を変更します。<br><br>

                    　VisibleFlag を FALSE にした場合、<b><a href="#R2N1">MV1DrawModel</a></b> 等の描画関数を呼んでも描画されなくなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x に含まれる１番目のメッシュを非表示にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // １番のメッシュの表示状態を「非表示」にする
    MV1SetMeshVisible( ModelHandle, 1, FALSE ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N5">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshVisible( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの表示・非表示状態を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：メッシュの表示状態( TRUE：表示  FALSE：非表示 )</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュの表示状態を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N6">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshDifColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのディフューズカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる０番のメッシュのディフューズカラーを赤にします。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // ０番のメッシュのディフューズカラーを赤にする
    <b><a href="#R7N6">MV1SetMeshDifColorScale</a></b>( ModelHandle, 0, <b><a href="#R14N14">GetColorF</a></b>( 1.0f, 0.0f, 0.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N7">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMeshDifColorScale( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュのディフューズカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュのディフューズカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのディフューズカラーに対するスケーリングの値を取得します。<br><br>

                    　<b><a href="#R7N6">MV1SetMeshDifColorScale</a></b> 関数で設定された値をそのまま返すだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N8">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshSpcColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのスペキュラカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる１番のメッシュのスペキュラカラーを緑にします。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // １番のメッシュのスペキュラカラーを緑にする
    <b><a href="#R7N8">MV1SetMeshSpcColorScale</a></b>( ModelHandle, 1, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 1.0f, 0.0f, 0.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N9">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMeshSpcColorScale( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュのスペキュラカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュのスペキュラカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのスペキュラカラーに対するスケーリングの値を取得します。<br><br>

                    　<b><a href="#R7N8">MV1SetMeshSpcColorScale</a></b> 関数で設定された値をそのまま返すだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N10">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshEmiColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのエミッシブカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる１番のメッシュのエミッシブカラーを青にします。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // １番のメッシュのエミッシブカラーを青にする
    <b><a href="#R7N10">MV1SetMeshEmiColorScale</a></b>( ModelHandle, 1, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 1.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N11">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMeshEmiColorScale( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュのエミッシブカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュのエミッシブカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのエミッシブカラーに対するスケーリングの値を取得します。<br><br>

                    　<b><a href="#R7N10">MV1SetMeshEmiColorScale</a></b> 関数で設定された値をそのまま返すだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N12">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshAmbColorScale( int MHandle, int MeshIndex, COLOR_F Scale ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>フレームのアンビエントカラーのスケール値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            COLOR_F Scale ： スケール値( 各色 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を設定します。<br><br>

                    　モデル中の一部分だけ色を変えたい場合などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル SimpleModel.mqo に含まれる３番のメッシュのアンビエントカラーを黄色にします。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // ３番のメッシュのアンビエントカラーを黄色にする
    <b><a href="#R7N12">MV1SetMeshAmbColorScale</a></b>( ModelHandle, 3, <b><a href="#R14N14">GetColorF</a></b>( 0.0f, 0.0f, 1.0f, 1.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N13">宣言</a></b></td><td><font color="#000088"><b>COLOR_F MV1GetMeshAmbColorScale( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュのアンビエントカラーのスケール値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュ番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュのアンビエントカラーのスケール値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュを描画する際に行うマテリアルのアンビエントカラーに対するスケーリングの値を取得します。<br><br>

                    　<b><a href="#R7N12">MV1SetMeshAmbColorScale</a></b> 関数で設定された値をそのまま返すだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N14">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshOpacityRate( int MHandle, int MeshIndex, float Rate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの不透明度を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            float Rate ： 不透明度( 0.0f 〜 1.0f )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュの不透明度を設定します。<br><br>

                    　Rate の値が 0.0f に近いほど不透明度が下がり( 透明度が上がり )、
                    1.0f に近いほど不透明度が上がり( 透明度が下がり )ます。<br>

                    　モデルの一部のメッシュを半透明で表示したかったり、だんだん透明になって消えていくなどの演出をしたい場合に使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo の０番目のメッシュの不透明度を５０％にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 透明で描画されているということが分かるように画面全体を赤で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,0,0 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 100.0f, 600.0f ) ) ;

    // ３Ｄモデルの０番目のメッシュの不透明度を50%にする
    <b><a href="#R7N14">MV1SetMeshOpacityRate</a></b>( ModelHandle, 0, 0.5f ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N15">宣言</a></b></td><td><font color="#000088"><b>float MV1GetMeshOpacityRate( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの不透明度を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュに設定されている不透明度<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに設定されている不透明度を取得します。<br>
                    　<b><a href="#R7N14">MV1SetMeshOpacityRate</a></b> でセットした値を取得するだけの関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N16">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshDrawBlendMode( int MHandle, int MeshIndex, int BlendMode ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの描画ブレンドモードを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int BlendMode ： 描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるメッシュの描画ブレンドモードを変更します。<br>
                    　マテリアルにも描画ブレンドモードの設定がありますので、この関数はマテリアルの設定を無視して描画ブレンドモードを変更したい場合に使用します。
                    ( BlendMode を -1 にすると、マテリアルのブレンドモードが使用されるようになります )<br><br>

                    　尚、現在モデル描画で正常に動作するブレンドモードは DX_BLENDMODE_ALPHA, DX_BLENDMODE_ADD の２種類のみです。
                    ( ハードウエアが対応している場合は DX_BLENDMODE_SUB も正常に機能します )<br>
                    　ブレンドモードの説明に関しては <b><a href="dxfunc_graph1.html#R3N17">SetDrawBlendMode</a></b> 関数の解説を参照してください。<br><br>

                    　ブレンドモードのパラメータの変更は関数 <b><a href="#R7N18">MV1SetMeshDrawBlendParam</a></b> を使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる１番目のメッシュの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,0,255 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる１番目のメッシュの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
    <b><a href="#R7N16">MV1SetMeshDrawBlendMode</a></b>( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N17">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshDrawBlendMode( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定のマテリアルの描画ブレンドモードを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>描画ブレンドモード( DX_BLENDMODE_ALPHA 等 )</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるメッシュのの描画ブレンドモードを取得します。<br><br>
                
                    　<b><a href="#R7N16">MV1SetMeshDrawBlendMode</a></b> 関数で設定した値を返すだけの関数です。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N18">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshDrawBlendParam( int MHandle, int MeshIndex, int BlendParam ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの描画ブレンドパラメータを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int BlendParame ： 描画ブレンドパラメータ( 0 〜 255 )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるメッシュのブレンドパラメータを変更します。<br>
                    ( ブレンドパラメータの説明に関しては <b><a href="dxfunc_graph1.html#R3N17">SetDrawBlendMode</a></b> 関数の解説を参照してください )<br><br>

                    　尚、ブレンドモードの変更は <b><a href="#R7N16">MV1SetMeshDrawBlendMode</a></b> 関数を使用してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル DxChara.x に含まれる１番目のメッシュの描画ブレンドモードを加算ブレンド( DX_BLENDMODE_ADD )に変更して、
            ブレンドパラメータを128にして描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // ブレンドモードが変更されたことがわかるように画面全体を青色で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,0,255 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる１番目のメッシュの描画ブレンドモードを DX_BLENDMODE_ADD に変更する
    <b><a href="#R7N16">MV1SetMeshDrawBlendMode</a></b>( ModelHandle, 1, DX_BLENDMODE_ADD ) ;

    // モデルに含まれる１番目のメッシュのブレンドパラメータを 128 に変更する
    <b><a href="#R7N18">MV1SetMeshDrawBlendParam</a></b>( ModelHandle, 1, 128 ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N19">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshDrawBlendParam( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの描画ブレンドパラメータを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>描画ブレンドパラメータ( 0 〜 255 )</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるメッシュの描画ブレンドパラメータを取得します。<br><br>

                    　この関数は <b><a href="#R7N18">MV1SetMeshDrawBlendParam</a></b> 関数で設定した値を返すだけの関数です。<br><br>
                <br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N20">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshBackCulling( int MHandle, int MeshIndex, int CullingFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュのバックカリングを行うかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int CullingFlag ： バックカリングを行うかどうか( TRUE：行う  FALSE：行わない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるメッシュを描画する際にバックカリング( 反対向きのポリゴンを描画しない )を行うかどうか変更します。<br><br>

                    　ポリゴンは多くの場合裏から見られることはありませんので、基本的にはバックカリングを行うという設定にしておくことで描画負荷を下げることが出来、それで何も問題はありませんが、
                    例えばペラペラの紙やスカート等、態々裏面のポリゴンを用意するのはポリゴン数的に勿体無いという場合はこの関数でバックかリングを無効にします。<br><br>

                    　ただし裏面のポリゴンを描画する際も表面のポリゴンを描画する際もライティング計算に使用される法線は同じものとなりますので、
                    ライティングの影響が強いメッシュに対してバックカリングを無効にすると見た目が変になります。( その場合は仕方が無いので裏面用に別のポリゴンを用意するしかありません )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　モデルファイル BackCulling.mqo に含まれる０番目のメッシュのバックカリングを有効な状態と無効にした状態での２パターンで描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "BackCulling.mqo" ) ;

    // バックカリングされているのがわかり易いように画面全体を青で塗りつぶす
    <b><a href="dxfunc_graph0.html#R2N2">DrawBox</a></b>( 0, 0, 640, 480, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 0,0,255 ), TRUE ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 490.0f, 50.0f, 600.0f ) ) ;

    // 最初は何もせずに３Ｄモデルを描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // 最初の位置から少し移動
    MV1SetPosition( ModelHandle, VGet( 50.0f, 50.0f, 600.0f ) ) ;

    // ３Ｄモデルに含まれる０番目のバックカリングを無効にする
    MV1SetMeshBackCulling( ModelHandle, 0, FALSE ) ;

    // ３Ｄモデルの描画
    MV1DrawModel( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N21">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshBackCulling( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュのバックカリングを行うかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：バックカリングを行うかどうか( TRUE：行う  FALSE：行わない )</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュでバックカリングを行うかどうかを取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N22">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetMeshMaxPosition( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュに含まれる頂点のローカル座標での最大値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュに含まれる頂点のローカル座標での最大値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のローカル座標での最大値を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N23">宣言</a></b></td><td><font color="#000088"><b>VECTOR MV1GetMeshMinPosition( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュに含まれる頂点のローカル座標での最小値を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>メッシュに含まれる頂点のローカル座標での最小値<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のローカル座標での最小値を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N31">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshTListNum( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュに含まれるトライアングルリストの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：メッシュに含まれるトライアングルリストの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれるトライアングルリストの数を取得します。( メッシュは１つ又は複数のトライアングルリスト( ポリゴンの塊 )で構成されています )<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の１番目のメッシュに含まれるトライアングルリストの情報を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, TriangleListNum, i, TriangleListIndex ;
    int y ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = MV1LoadModel( "DxChara.x" ) ;

    // １番目のメッシュに含まれるトライアングルリストの数を取得する
    TriangleListNum = MV1GetMeshTListNum( ModelHandle, 1 ) ;

    // トライアングルリストの数だけループ
    y = 0 ;
    for( i = 0 ; i &lt; TriangleListNum ; i ++ )
    {
        // トライアングルリスト番号の取得
        TriangleListIndex = MV1GetMeshTList( ModelHandle, 1, i ) ;

        // トライアングルリスト番号を描画
        DrawFormatString( 0, y, GetColor( 255,255,255 ), "TriangleListIndex %d", TriangleListIndex ) ;

        // トライアングルリストの頂点タイプを描画
        switch( MV1GetTriangleListVertexType( ModelHandle, TriangleListIndex ) )
        {
        case DX_MV1_VERTEX_TYPE_1FRAME :
            DrawString( 0, y + 16, "頂点タイプ：１フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_4FRAME :
            DrawString( 0, y + 16, "頂点タイプ：１〜４フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_8FRAME :
            DrawString( 0, y + 16, "頂点タイプ：１〜８フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_FREE_FRAME :
            DrawString( 0, y + 16, "頂点タイプ：９フレーム以上の影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_1FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる１フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_4FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる１〜４フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_8FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる１〜８フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_FREE_FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる９フレーム以上の影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;
        }

        // トライアングルリストのポリゴン数と頂点数を描画
        DrawFormatString( 0, y + 32, GetColor( 255,255,255 ), "ポリゴン数：%-5d   頂点数：%-5d",
            MV1GetTriangleListPolygonNum( ModelHandle, TriangleListIndex ),
            MV1GetTriangleListVertexNum( ModelHandle, TriangleListIndex ) ) ;

        // 描画Ｙ座標を進める
        y += 64 ;
    }

    // キーの入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N32">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshTList( int MHandle, int MeshIndex, int Index ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュに含まれるトライアングルリストを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int Index ： メッシュ内トライアングルリストの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：トライアングルリストの番号</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれるトライアングルリストの番号を取得します。<br><br>

                    　Index に <b><a href="#R6N31">MV1GetMeshTListNum</a></b> 関数の戻り値以上の値を渡すとエラーになります。<br><br>

                    　取得したトライアングルリストの番号は MV1DrawTriangleList や MV1GetTriangleListVertexType などの関数で使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N31">MV1GetMeshTListNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N26">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshSemiTransState( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュに半透明要素があるかどうかを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>TRUE：半透明要素がある　FALSE：半透明要素は無い</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに半透明の要素があるかどうかを取得します。<br><br>

                    　例えば、メッシュが使用しているマテリアルのテクスチャに半透明の部分があったり、
                    メッシュの不透明度が 1.0f ではなかったりすると TRUE が返ってきます。<br><br>

                    　半透明要素を持つメッシュをＺソートする場合に、各メッシュに半透明要素があるかどうかを判定する際などに使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x の０番目のメッシュの不透明度を上下キーで操作できるようにした上で、
              画面上に MV1GetMeshSemiTransState 関数の戻り値を表示して半透明要素があるかどうかを確認できるようにしています。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float OpacityRate ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "DxChara.x" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, -300.0f, 600.0f ) ) ;

    // 不透明度を初期化
    OpacityRate = 1.0f ;

    // ESCキーが押されるかウインドウが閉じられるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面のクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 上キーが押されたら不透明度を上げる
        if( CheckHitKey( KEY_INPUT_UP ) )
        {
            OpacityRate += 0.05f ;
            if( OpacityRate > 1.0f )
            {
                OpacityRate = 1.0f ;
            }
        }

        // 下キーが押されたら不透明度を下げる
        if( CheckHitKey( KEY_INPUT_DOWN ) )
        {
            OpacityRate -= 0.05f ;
            if( OpacityRate < 0.0f )
            {
                OpacityRate = 0.0f ;
            }
        }

        // ３Ｄモデルの１番目のメッシュの不透明度を設定する
        <b><a href="#R7N14">MV1SetMeshOpacityRate</a></b>( ModelHandle, 1, OpacityRate ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 現在の不透明度と、MV1GetMeshSemiTransState の戻り値を描画する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,255 ),
            "ESC Key:Exit OpacityRate:%f SemiTransState:%d",
            OpacityRate, <b><a href="#R7N26">MV1GetMeshSemiTransState</a></b>( ModelHandle, 1 ) ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>





        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N27">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshUseVertDifColor( int MHandle, int MeshIndex, int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int UseFlag ： 頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうか( TRUE：使用する  FALSE：使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを設定します。<br>
                    ( デフォルトでは頂点ディフューズカラーは使用しません )<br><br>

                    　この関数で頂点ディフューズカラーを使用する設定にした場合はマテリアルのディフューズカラー設定は無視され、代わりに頂点ディフューズカラーが使用されます。<br><br>

                    　モデリングソフトでライティングの結果を頂点カラーに反映した場合等に使用します。<br>
                    　尚、ライティング計算を <b><a href="#R13N44">SetUseLighting</a></b> 関数で無効にした場合はこの関数の設定に関係なくマテリアルのディフューズカラーは無視され、頂点ディフューズカラーが使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModelVertexColor.mqo を最初は普通に描画し、キーが押された後３番目のメッシュの頂点ディフューズカラーを<br>
            　有効にして( マテリアルのディフューズカラーを無効にして )再度モデルを描画します。<br>
            　　３番目のメッシュの頂点ディフューズカラーは真っ黒なので、キーが押された後はエミッシブカラー( 自己発光色 )と<br>
            　アンビエントカラー( 環境光色 )のみの平坦な見た目に変化します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModelVertexColor.mqo" ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // ３Ｄモデルの描画
    <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // 画面をクリア
    <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

    // ３番目のメッシュの頂点ディフューズカラーを使用する設定に変更する
    MV1SetMeshUseVertDifColor( ModelHandle, 3, TRUE ) ;

    // ３Ｄモデルの描画
    MV1DrawModel( ModelHandle ) ;

    // キーの入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N28">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshUseVertDifColor( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかの設定を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>頂点ディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうか( TRUE：使用する  FALSE：使用しない )<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のディフューズカラーをマテリアルのディフューズカラーの代わりに使用するかどうかを取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N29">宣言</a></b></td><td><font color="#000088"><b>int MV1SetMeshUseVertSpcColor( int MHandle, int MeshIndex, int UseFlag ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号<br>
            int UseFlag ： 頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうか( TRUE：使用する  FALSE：使用しない )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを設定します。<br><br>

                    　この関数で頂点スペキュラカラーを使用する設定にした場合はマテリアルのスペキュラカラー設定は無視され、代わりに頂点スペキュラカラーが使用されます。<br><br>

                    　ただ、現時点ではライブラリのモデルデータ読みこみプログラムに頂点のスペキュラカラーを設定する処理が組み込まれていないので、
                    この関数で頂点スペキュラカラーを有効にしてもマテリアルのスペキュラカラーが無効化されるだけとなります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R7N30">宣言</a></b></td><td><font color="#000088"><b>int MV1GetMeshUseVertSpcColor( int MHandle, int MeshIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>メッシュの頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかの設定を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int MeshIndex ： メッシュの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>頂点スペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうか( TRUE：使用する  FALSE：使用しない )<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のメッシュに含まれる頂点のスペキュラカラーをマテリアルのスペキュラカラーの代わりに使用するかどうかを取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R7N1">MV1GetMeshNum関数</a> のサンプルを参照してください。<br><br><br><br><br><br>
        </td></tr>






        <tr><td><font size="3" color="#005500"><b>シェイプ関数</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N1">宣言</a></b></td><td><font color="#000088"><b>int MV1GetShapeNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルに含まれるシェイプの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：モデルに含まれるシェイプの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるシェイプ( キャラクターモデルの表情などに使用される一部の頂点の変形情報 )の数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N2">宣言</a></b></td><td><font color="#000088"><b>int MV1SearchShape( int MHandle, char *ShapeName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>指定名のシェイプをモデル中から検索する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            char *ShapeName ： 検索するシェイプの名前
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：指定名のシェイプの番号</td></tr>
            <tr><td              WIDTH=100>　           </td><td>−２：指定名のシェイプが見つからなかった</td></tr>
            <tr><td              WIDTH=100>　           </td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるシェイプ( キャラクターモデルの表情などに使用される一部の頂点の変形情報 )から、指定の名前のものを検索します。<br><br>

                    　同名のシェイプが複数含まれる場合は番号の若いシェイプが返ってきます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N3">宣言</a></b></td><td><font color="#000088"><b>int MV1SetShapeRate( int MHandle, int ShapeIndex, float Rate ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェイプの適用率を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int ShapeIndex ： 有効率を変更するシェイプの番号<br>
            float Rate ： 適用率（ 0.0f（０％） 〜 1.0f（１００％） ）<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
		　MHandle のモデルハンドルが示すモデルに含まれるシェイプ( キャラクターモデルの表情などに使用される一部の頂点の変形情報 )の適用率を変更します。<br>
                　第二引数の ShapeIndex で渡すシェイプの番号はＤＸライブラリ付属のモデルビューアー( DxLibModelViewer.exe )で確認できる他に、
		<a href="#R21N2">MV1SearchShape</a> を使用してシェイプの名前から検索することもできます。<br>
		　第三引数の Rate でシェイプの適用率を float 型の値で指定します、有効な値は 0.0f（ ０％ ）から 1.0f（ １００％ ）となります。
		<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R21N4">宣言</a></b></td><td><font color="#000088"><b>float MV1GetShapeRate( int MHandle, int ShapeIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェイプの適用率を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int ShapeIndex ： 適用率を取得するシェイプの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　0.0f以上：シェイプの適用率（ 0.0f（０％） 〜 1.0f（１００％） ）</td></tr>
            <tr><td width="100">　</td><td>-1.0f：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>
		　MHandle のモデルハンドルが示すモデルに含まれるシェイプ( キャラクターモデルの表情などに使用される一部の頂点の変形情報 )の適用率を取得します。<br>
                　第二引数の ShapeIndex で渡すシェイプの番号はＤＸライブラリ付属のモデルビューアー( DxLibModelViewer.exe )で確認できる他に、
		<a href="#R21N2">MV1SearchShape</a> を使用してシェイプの名前から検索することもできます。
		<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                ありません
            <br><br><br><br><BR><BR>
        </td></tr>









        <tr><td><font size="3" color="#005500"><b>トライアングルリスト関係</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R18N1">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTriangleListNum( int MHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>モデルに含まれるトライアングルリストの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：モデルに含まれるトライアングルリストの数</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルに含まれるトライアングルリストの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル DxChara.x に含まれるトライアングルリストの情報を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle, TriangleListNum, i ;
    int y ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = MV1LoadModel( "DxChara.x" ) ;

    // モデルに含まれるトライアングルリストの数を取得する
    TriangleListNum = MV1GetTriangleListNum( ModelHandle ) ;

    // トライアングルリストの数だけループ
    y = 0 ;
    for( i = 0 ; i &lt; TriangleListNum ; i ++ )
    {
        // トライアングルリスト番号を描画
        DrawFormatString( 0, y, GetColor( 255,255,255 ), "No %d", i ) ;

        // トライアングルリストのポリゴン数と頂点数を描画
        DrawFormatString( 48, y, GetColor( 255,255,255 ), "ポリゴン数：%-5d   頂点数：%-5d",
            MV1GetTriangleListPolygonNum( ModelHandle, i ),
            MV1GetTriangleListVertexNum( ModelHandle, i ) ) ;

        // トライアングルリストの頂点タイプを描画
        switch( MV1GetTriangleListVertexType( ModelHandle, i ) )
        {
        case DX_MV1_VERTEX_TYPE_1FRAME :
            DrawString( 0, y + 16, "頂点タイプ：１フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_4FRAME :
            DrawString( 0, y + 16, "頂点タイプ：１〜４フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_8FRAME :
            DrawString( 0, y + 16, "頂点タイプ：１〜８フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_FREE_FRAME :
            DrawString( 0, y + 16, "頂点タイプ：９フレーム以上の影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_1FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる１フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_4FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる１〜４フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_8FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる１〜８フレームの影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;

        case DX_MV1_VERTEX_TYPE_NMAP_FREE_FRAME :
            DrawString( 0, y + 16, "頂点タイプ：法線マップ用の情報が含まれる９フレーム以上の影響を受ける頂点", GetColor( 255,255,255 ) ) ;
            break ;
        }

        // 描画Ｙ座標を進める
        y += 32 ;
    }

    // キーの入力待ち
    WaitKey() ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R18N2">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTriangleListVertexType( int MHandle, int TListIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>トライアングルリストの頂点データタイプを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TListIndex ： トライアングルリストの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：頂点データタイプ</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のトライアングルリストに含まれる頂点のデータタイプを取得します。<br>
                    　オリジナルの頂点シェーダープログラムを使用する場合は頂点のデータタイプによって頂点シェーダープログラムを変えなければならないので、
                    主にどの頂点シェーダープログラムを使用するべきかを判断する際にこの関数を使用します。<br><br>

                    　頂点データのシェーダー内での具体的なデータ形式については関数 <b><a href="#R17N2">LoadVertexShader</a></b> の解説をご覧ください。<br><br>

                    <font color="#660000"><b>頂点データタイプ一覧</b></font><br><br>

                    <b>DX_MV1_VERTEX_TYPE_1FRAME</b><br><br>

                    　１フレームの影響のみ受ける頂点データタイプです。<br>
                    　１頂点が複数のフレームの影響を受けないモデルはこのデータタイプになります。<br><br>

                    <b>DX_MV1_VERTEX_TYPE_4FRAME</b><br><br>
                    
                    　１〜４フレームの影響を受ける頂点データタイプです。<br>
                    　１頂点が２フレーム以上４フレーム以下の影響を受ける頂点が一つでも存在するトライアングルリストは<br>
                    　このデータタイプになります。<br>
                    　PMDモデルは基本的に全てこの頂点データタイプになります。<br><br>

                    <b>DX_MV1_VERTEX_TYPE_8FRAME</b><br><br>
                    
                    　１〜８フレームの影響を受ける頂点データタイプです。<br>
                    　１頂点が５フレーム以上４フレーム以下の影響を受ける頂点が一つでも存在するトライアングルリストは<br>
                    　このデータタイプになります。<br>
                    　普通の人型モデルなどでは普通１頂点が５フレーム以上の影響を受けることはありませんので、<br>
                    　特殊なモデルのみこの形式になります。<br><br>

                    <b>DX_MV1_VERTEX_TYPE_FREE_FRAME</b><br><br>
                    
                    　９フレーム以上の影響を受ける頂点データタイプです。<br>
                    　１頂点が９フレーム以上の影響を受ける頂点が一つでも存在するトライアングルリストは<br>
                    　このデータタイプになります。<br>
                    　滅多にこの形式になることはありません。<br>
                    　尚、DirectX9 では一般的な方法では頂点シェーダーで１頂点９フレーム以上を扱う手段が無いので、<br>
                    　この形式の場合は頂点シェーダーを使用することはできません。<br><br>

                    <b>DX_MV1_VERTEX_TYPE_NMAP_1FRAME</b><br>
                    <b>DX_MV1_VERTEX_TYPE_NMAP_4FRAME</b><br>
                    <b>DX_MV1_VERTEX_TYPE_NMAP_8FRAME</b><br>
                    <b>DX_MV1_VERTEX_TYPE_NMAP_FREE_FRAME</b><br><br>

                    　それぞれ NMAP が付いていない名称のタイプに法線マップの情報が追加されたものです。<br>
                    　MV1GetMaterialNormalMapTexture の戻り値が -1 以外のマテリアルを使用するメッシュに含まれる<br>
                    　トライアングルリストは全て上記４タイプのいずれかになります。<br><br>

                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R18N1">MV1GetTriangleListNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R18N3">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTriangleListPolygonNum( int MHandle, int TListIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>トライアングルリストに含まれるポリゴンの数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TListIndex ： トライアングルリストの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：三角形ポリゴンの数</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のトライアングルリストに含まれる三角形ポリゴンの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R18N1">MV1GetTriangleListNum関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R18N4">宣言</a></b></td><td><font color="#000088"><b>int MV1GetTriangleListVertexNum( int MHandle, int TListIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>トライアングルリストに含まれる頂点の数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int TListIndex ： トライアングルリストの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>０以上：頂点の数</td></tr>
            <tr><td              WIDTH=100>           　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のトライアングルリストに含まれる頂点データの数を取得します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R18N1">MV1GetTriangleListNum関数</a> のサンプルを参照してください。<br><br><br><br><br><br><br>
        </td></tr>



        <tr><td><font size="3" color="#005500"><b>コリジョン( 衝突判定 )関係</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N1">宣言</a></b></td><td><font color="#000088"><b>int MV1SetupCollInfo( int MHandle, int FrameIndex, int XDivNum, int YDivNum, int ZDivNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>コリジョン情報を構築する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： コリジョンの情報を構築するフレームの番号<br>
            int XDivNum ： コリジョン情報のＸ軸方向の空間分割数<br>
            int YDivNum ： コリジョン情報のＹ軸方向の空間分割数<br>
            int ZDivNum ： コリジョン情報のＺ軸方向の空間分割数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとの当たり判定を行うための情報のセットアップを行います。<br><br>

                    　３Ｄを扱うゲームでは多くの場合３Ｄモデルとの当たり判定を行っています。
                    この MV1SetupCollInfo を含むコリジョン関係関数は、その当たり判定処理の手助けをするものです。<br><br>

                    　その使い方ですが、コリジョン関係の機能を使用するにはまずこの関数でコリジョン情報として使用したいポリゴンを持つフレームのポリゴンをコリジョン情報として使うための準備をしてやる必要があります。
                    そのフレームは FrameIndex で指定しますが、ここで FrameIndex を -1 にすることでモデル全体のポリゴンをコリジョン情報として準備することができます。<br>
                    　因みにコリジョン処理は非常に負荷の高い処理ですので、
                    例えばステージモデルとの当たり判定を行う場合等は描画用のステージモデルをそのまま当たり判定用のモデルとして使うのではなく、
                    当たり判定用の粗いポリゴンメッシュを収めるフレームを用意して、
                    そのフレームに対して MV1SetupCollInfo をした方が良いです。
                    ( そしてそのフレームは <b><a href="#R6N13">MV1SetFrameVisible</a></b> 関数で描画されないようにしておきます )<br><br>

                    　セットアップ時に指定する XDivNum, YDivNum, ZDivNum ですが、
                    コリジョン処理の仕組みとして、
                    あるコリジョン処理をする際にコリジョン用のフレーム内に存在するすべてのポリゴンと接触判定をすると大変な処理負荷になってしまいますので、
                    コリジョン用のポリゴンはまずポリゴンが存在する空間を格子状に区切ってどの枠にどのポリゴンが存在するかを整理して、
                    コリジョン処理を行いたい領域の周辺に存在するポリゴンとだけ接触判定をするようにして、
                    処理負荷があまり大きくならないようにします。<br>
                    　分割数の最適値ですが、
                    一つの格子が、コリジョン処理を行うオブジェクトの大きさとコリジョン用ポリゴンの平均的な大きさを比較して、
                    大きい方と同じくらいになる分割数が良いです。
                    検索対象となるポリゴンが多くなるのは問題ですが、検索対象となる格子の数が多すぎるのもまた問題ですので・・・
                    ( 例えば人型キャラクターが登場するステージの分割数でしたら、
                    人型キャラクターのモデルとコリジョン用ポリゴンの平均的な大きさを比較して、
                    人型キャラクターモデルの方が大きい場合は格子一つのサイズが人型キャラクターと同じ位の大きさになる分割数、
                    コリジョン用ポリゴンの平均的な大きさのほうが大きい場合は格子一つのサイズがコリジョン用ポリゴンの平均的な大きさと同じくらいの大きさになる分割数が最適となります )<br><br>

                    　ちなみにコリジョン情報の構築は負荷の高い処理ですので、
                    コリジョン情報の更新は <b><a href="#R9N3">MV1RefreshCollInfo</a></b> 関数を使用して明示的に行う必要があります。<br>
                    　動かないモデルをコリジョンとして使用する場合は一度この関数でコリジョン情報をセットアップした後は何もする必要はありませんが、
                    動くモデルをコリジョンとして使用する場合は MV1RefreshCollInfo を呼ばないとコリジョン情報の形状が最後に更新したときの状態のままとなってしまいますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo の０番目のフレーム( 中心の球体 )と線分の当たり判定をし、<br>
            　当たったところまで線分を描画します。<br>
            　　あと、当たっているのかどうかを判断するために上下キーで線分を移動できるようにしています。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    float y ;
    VECTOR StartPos, EndPos ;
    MV1_COLL_RESULT_POLY HitPoly ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // 画面に映る位置に３Ｄモデルを移動
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // モデルの０番目のフレームのコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, 0, 8, 8, 8 ) ;

    // 当たり判定用のラインを出すＹ座標を初期化
    y = 300.0f ;

    // ウインドウが閉じられるかＥＳＣキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // 上下キーで線分の y 座標を操作できる
        if( CheckHitKey( KEY_INPUT_UP ) == 1 )
        {
            y += 16.0f ;
        }
        if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
        {
            y -= 16.0f ;
        }

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // ０番のフレームと線分との当たり判定
        StartPos = <b><a href="#R11N1">VGet</a></b>( 0.0f, y, 600.0f ) ;
        EndPos   = VGet( 1000.0f, y, 600.0f ) ;
        HitPoly = <b><a href="#R9N4">MV1CollCheck_Line</a></b>( ModelHandle, 0, StartPos, EndPos ) ;

        // 当たった場合はその位置を描画する線分の終点とする
        if( HitPoly.HitFlag == 1 )
        {
            EndPos = HitPoly.HitPosition ;
        }

        // 線分の描画
        <b><a href="#R14N1">DrawLine3D</a></b>( StartPos, EndPos, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ) ) ;

        // 当たったかどうかを表示する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ), "HIT:%d", HitPoly.HitFlag ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N2">宣言</a></b></td><td><font color="#000088"><b>int MV1TerminateCollInfo( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>コリジョン情報の後始末をする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： コリジョンの情報の後始末を行うフレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとの当たり判定を行うための情報の後始末を行います。<br><br>
                
                    　この関数を使用して明示的に情報を破棄しなくても、
                    <b><a href="#R1N3">MV1DeleteModel</a></b> や <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b> が呼ばれた際にモデル情報と共にコリジョン情報の後始末は行われますので、
                    この関数を使用する機会はあまり無いかもしれません。<br><br>

                    　尚、<b><a href="#R9N1">MV1SetupCollInfo</a></b> で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N3">宣言</a></b></td><td><font color="#000088"><b>int MV1RefreshCollInfo( int MHandle, int FrameIndex ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>コリジョン情報を更新する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： コリジョンの情報を更新するフレームの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとの当たり判定を行うための情報の更新を行います。<br><br>

                    　動作させないモデルをコリジョンポリゴンとして使用している場合はこの関数を呼ぶ必要はありませんが、
                    <b><a href="#R3N2">MV1SetPosition</a></b> で座標を移動したり、アニメーションを流したりするモデルをコリジョンポリゴンとして使用している場合はこの関数を使用して明示的にコリジョン情報を更新する必要があります。
                    ( 更新しない場合は最後に更新した状態のままとなります )<br><br>

                    　尚、<b><a href="#R9N1">MV1SetupCollInfo</a></b> で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo の０番目のフレーム( 中心の球体 )と線分の当たり判定をし、<br>
            　当たったところまで線分を描画します。<br>
            　　そして、モデルを上下に動かしながら MV1RefreshCollInfo でコリジョン情報を更新しています。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int Add, y ;
    VECTOR StartPos, EndPos ;
    MV1_COLL_RESULT_POLY HitPoly ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // モデルの０番目のフレームのコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, 0, 8, 8, 8 ) ;

    // モデルの進行方向をセット
    Add = 8 ;

    // モデルの移動位置をセット
    y = 0 ;

    // ウインドウが閉じられるかＥＳＣキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; <b><a href="dxfunc_input.html#R5N2">CheckHitKey</a></b>( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの移動位置を上下に移動させる
        y += Add ;
        if( y &lt; -300 || y &gt; 300 )
            Add = -Add ;

        // ３Ｄモデルの位置を変更する
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f + y, 600.0f ) ) ;

        // ０番目のフレームのコリジョン情報を更新する
        <b><a href="#R9N3">MV1RefreshCollInfo</a></b>( ModelHandle, 0 ) ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // ０番のフレームと線分との当たり判定
        StartPos = VGet(    0.0f, 300.0f, 600.0f ) ;
        EndPos   = VGet( 1000.0f, 300.0f, 600.0f ) ;
        HitPoly = <b><a href="#R9N4">MV1CollCheck_Line</a></b>( ModelHandle, 0, StartPos, EndPos ) ;

        // 当たった場合はその位置を描画する線分の終点とする
        if( HitPoly.HitFlag == 1 )
        {
            EndPos = HitPoly.HitPosition ;
        }

        // 線分の描画
        <b><a href="#R14N1">DrawLine3D</a></b>( StartPos, EndPos, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ) ) ;

        // 当たったかどうかを表示する
        <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ), "HIT:%d", HitPoly.HitFlag ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        
        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N4">宣言</a></b></td><td><font color="#000088"><b>MV1_COLL_RESULT_POLY MV1CollCheck_Line( int MHandle, int FrameIndex, VECTOR PosStart, VECTOR PosEnd ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>線分とモデルの当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： コリジョンの情報を更新するフレームの番号<br>
            VECTOR PosStart ： 当たり判定で使用する線分の始点<br>
            VECTOR PosEnd ： 当たり判定で使用する線分の終点
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>当たり判定結果構造体<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンと線分との当たり判定を行います。<br>
                    ( この関数でモデルのポリゴンと線分との当たり判定を行う場合は対象となるフレーム( 若しくはモデル全体 )に対して事前に <b><a href="#R9N1">MV1SetupCollInfo</a></b> を呼んで準備を行っておく必要があります、
                    また、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )<br><br>
                    　戻り値である MV1_COLL_RESULT_POLY は当たり判定の結果が代入されている構造体で、以下のような内容になっています。<br><br>
<pre>
// コリジョン結果代入用ポリゴン
struct MV1_COLL_RESULT_POLY
{
    // どれかのポリゴンに当たったかどうか
    // ( 1：当たった  0：当たらなかった )
    int    HitFlag ;

    // 線分とポリゴンが交差した座標
    VECTOR    HitPosition ;

    // 当たったポリゴンが含まれるフレームの番号
    int    FrameIndex ;

	// 当たったポリゴンのフレーム内番号
	int PolygonIndex ;

	// 当たったポリゴンが使用しているマテリアルの番号
	int	MaterialIndex ;

    // 当たったポリゴンを形成する三点の座標
    VECTOR    Position[ 3 ] ;

    // 当たったポリゴンの法線
    VECTOR    Normal ;
} ;
</pre>
                    　注釈の通りですが、
                    どれかのポリゴンに当たったかどうかはメンバ変数 HitFlag が 1 かどうかで判断することができ、
                    線分とポリゴンが交差した座標は HitPosition に代入されます。<br>
                    　当たったポリゴンが含まれるメッシュを所有しているフレームの番号はメンバ変数 FrameIndex に、
                    当たったポリゴンが使用しているマテリアルの番号はメンバ変数 MaterialIndex に、
                    当たったポリゴンを形成する三頂点の座標はメンバ配列 Position に、
                    当たったポリゴンの法線はメンバ変数 Normal にそれぞれ代入されます。<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo と上下に動く線分との当たり判定をして、当たったところまでの線分の描画と、<br>
            　当たり判定の結果を画面に描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int Add, y ;
    VECTOR StartPos, EndPos ;
    MV1_COLL_RESULT_POLY HitPoly ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ３Ｄモデルを見える位置に移動する
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // モデル全体のコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, -1, 8, 8, 8 ) ;

    // モデルの進行方向をセット
    Add = 8 ;

    // モデルの移動位置をセット
    y = 0 ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの移動位置を上下に移動させる
        y += Add ;
        if( y &lt; 0 || y &gt; 600 )
            Add = -Add ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // モデルと線分との当たり判定
        StartPos = <b><a href="#R11N1">VGet</a></b>( -300.0f, y, 600.0f ) ;
        EndPos   = VGet( 1000.0f, y, 600.0f ) ;
        HitPoly = MV1CollCheck_Line( ModelHandle, -1, StartPos, EndPos ) ;

        // 当たった場合はその位置を描画する線分の終点とする
        if( HitPoly.HitFlag == 1 )
        {
            EndPos = HitPoly.HitPosition ;
        }

        // 線分の描画
        <b><a href="#R14N1">DrawLine3D</a></b>( StartPos, EndPos, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ) ) ;

        // 当たったかどうかで処理を分岐
        if( HitPoly.HitFlag == 1 )
        {
            // 当たった場合は衝突の情報を描画する

            // 交差した座標を描画
            <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ),  "Hit Pos   %f  %f  %f",
                HitPoly.HitPosition.x, HitPoly.HitPosition.y, HitPoly.HitPosition.z ) ;

            // 当たったポリゴンが含まれるフレームの番号を描画
            DrawFormatString( 0, 16, GetColor( 255,255,255 ), "Frame     %d", HitPoly.FrameIndex ) ;

            // 当たったポリゴンが使用しているマテリアルの番号を描画
            DrawFormatString( 0, 32, GetColor( 255,255,255 ), "Material  %d", HitPoly.MaterialIndex ) ;

            // 当たったポリゴンを形成する三頂点の座標を描画
            DrawFormatString( 0, 48, GetColor( 255,255,255 ), "Position  %f  %f  %f",
                HitPoly.Position[ 0 ].x, HitPoly.Position[ 0 ].y, HitPoly.Position[ 0 ].z ) ;
            DrawFormatString( 0, 64, GetColor( 255,255,255 ), "          %f  %f  %f",
                HitPoly.Position[ 1 ].x, HitPoly.Position[ 1 ].y, HitPoly.Position[ 1 ].z ) ;
            DrawFormatString( 0, 80, GetColor( 255,255,255 ), "          %f  %f  %f",
                HitPoly.Position[ 2 ].x, HitPoly.Position[ 2 ].y, HitPoly.Position[ 2 ].z ) ;

            // 当たったポリゴンの法線を描画
            DrawFormatString( 0, 96, GetColor( 255,255,255 ), "Normal    %f  %f  %f",
                HitPoly.Normal.x, HitPoly.Normal.y, HitPoly.Normal.z ) ;
        }
        else
        {
            // 当たらなかった場合は衝突しなかった旨だけ描画する
            <b><a href="dxfunc_graph2.html#R17N1">DrawString</a></b>( 0, 0, "NO HIT", GetColor( 255,255,255 ) ) ;
        }

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N5">宣言</a></b></td><td><font color="#000088"><b>MV1_COLL_RESULT_POLY_DIM MV1CollCheck_Sphere( int MHandle, int FrameIndex, VECTOR CenterPos, float r ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>球とモデルの当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： コリジョンの情報を更新するフレームの番号<br>
            VECTOR CenterPos ： 当たり判定で使用する球の中心座標<br>
            float r ： 当たり判定で使用する球の半径
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>当たり判定結果ポリゴン配列構造体<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンと球との当たり判定を行います。<br>
                    ( この関数でモデルのポリゴンと線分との当たり判定を行う場合は対象となるフレーム( 若しくはモデル全体 )に対して事前に <b><a href="#R9N1">MV1SetupCollInfo</a></b> を呼んで準備を行っておく必要があります、
                    また、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )<br><br>

                    　戻り値である MV1_COLL_RESULT_POLY_DIM は当たり判定の結果が代入されている構造体で、以下のような内容になっています。<br><br>
<pre>
// コリジョン結果代入用ポリゴン配列
struct MV1_COLL_RESULT_POLY_DIM
{
    // 当たったポリゴンの数
    int            HitNum ;

    // 当たったポリゴンの配列へのポインタ
    // ( 配列の要素数は HitNum です )
    MV1_COLL_RESULT_POLY    *Dim ;
} ;
</pre>
                    　また、MV1_COLL_RESULT_POLY_DIM 構造体で使用されている MV1_COLL_RESULT_POLY 構造体は以下のような内容になっています。<br><br>

<pre>
// コリジョン結果代入用ポリゴン
struct MV1_COLL_RESULT_POLY
{
    // どれかのポリゴンに当たったかどうか
    // ( 球との当たり判定の場合は必ず 1 )
    int    HitFlag ;

    // 球とポリゴンの最近点の座標
    VECTOR    HitPosition ;

    // 当たったポリゴンが含まれるフレームの番号
    int    FrameIndex ;

    // 当たったポリゴンが使用しているマテリアルの番号
    int    MaterialIndex ;

    // 当たったポリゴンを形成する三点の座標
    VECTOR    Position[ 3 ] ;

    // 当たったポリゴンの法線
    VECTOR    Normal ;
} ;
</pre>
                    　構造体の説明ですが、まず球とフレーム( 若しくはモデル全体 )との当たり判定を行うと戻り値として MV1_COLL_RESULT_POLY_DIM 構造体が返ってきます。<br>
                    　この構造体の中身にはメンバ変数 HitNum と Dim があり、当たったポリゴンの数が HitNum に代入されています。<br>
                    　この HitNum が 0 だったら球は対象のフレーム( 若しくはモデル全体 )に含まれるポリゴンに一枚も当たらなかったということです。<br>
                    　そして当たった場合は、当たったポリゴンの数が HitNum に代入され、
                    どんなポリゴンと当たったかに関する情報がポインタ Dim が示すアドレスに当たったポリゴンの数だけ要素がある配列として格納されます。<br><br>

                    　当たったかどうかだけを判断する場合は HitNum が 0 かどうかを判定するだけで、
                    当たったポリゴンに関する情報を扱いたい場合は Dim の先にある配列にアクセスするという使い方になります。<br><br>
                    ( Dim へのアクセスの仕方についてはサンプルプログラムを見ていただくとわかりやすいと思います )

                    　また、この関数は当たるポリゴンの数が不定である関係上、動的にメモリを確保していますので、
                    戻り値の情報が必要なくなった場合は <b><a href="#R9N6">MV1CollResultPolyDimTerminate</a></b> 関数に戻り値の構造体を渡して後始末を行う必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo と上下に動く球の当たり判定をして、球と当たったポリゴンとの最近点を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int Add, y, i ;
    VECTOR SpherePos ;
    MV1_COLL_RESULT_POLY_DIM HitPolyDim ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ３Ｄモデルを見える位置に移動する
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // モデル全体のコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, -1, 8, 8, 8 ) ;

    // モデルの進行方向をセット
    Add = 8 ;

    // モデルの移動位置をセット
    y = 0 ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの移動位置を上下に移動させる
        y += Add ;
        if( y &lt; 0 || y &gt; 600 )
            Add = -Add ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 当たり判定を行う球の位置をセット
        SpherePos = <b><a href="#R11N1">VGet</a></b>( 250.0f, y, 600.0f ) ;

        // モデルと球との当たり判定
        HitPolyDim = <b><a href="#R9N5">MV1CollCheck_Sphere</a></b>( ModelHandle, -1, SpherePos, 100.0f ) ;

        // 球の描画
        <b><a href="#R14N4">DrawSphere3D</a></b>( SpherePos, 100.0f, 8, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ), GetColor( 255,255,255 ), FALSE ) ;

        // 当たったかどうかで処理を分岐
        if( HitPolyDim.HitNum >= 1 )
        {
            // 当たった場合は衝突の情報を描画する

            // 当たったポリゴンの数を描画
            <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ), "Hit Poly Num   %d", HitPolyDim.HitNum ) ;

            // 当たったポリゴンの数だけ繰り返し
            for( i = 0 ; i &lt; HitPolyDim.HitNum ; i ++ )
            {
                // 当たったポリゴンを描画
                DrawTriangle3D(
                    HitPolyDim.Dim[ i ].Position[ 0 ], 
                    HitPolyDim.Dim[ i ].Position[ 1 ], 
                    HitPolyDim.Dim[ i ].Position[ 2 ], GetColor( 0,255,255 ), TRUE ) ;
            }
        }

        // 当たり判定情報の後始末
        <b><a href="#R9N6">MV1CollResultPolyDimTerminate</a></b>( HitPolyDim ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N8">宣言</a></b></td><td><font color="#000088"><b>MV1_COLL_RESULT_POLY_DIM MV1CollCheck_Capsule( int MHandle, int FrameIndex, VECTOR Pos1, VECTOR Pos2, float r ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>カプセル形状とモデルの当たり判定<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： コリジョンの情報を更新するフレームの番号<br>
            VECTOR Pos1 ： カプセルを形成する二点中の一点の座標<br>
            VECTOR Pos2 ： カプセルを形成する二点中の一点の座標<br>
            float r ： カプセルの半径
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>当たり判定結果ポリゴン配列構造体<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンとカプセル形状( 二つの球を円筒で繋いだ形状 )との当たり判定を行います。<br>
                    ( この関数でモデルのポリゴンと線分との当たり判定を行う場合は対象となるフレーム( 若しくはモデル全体 )に対して事前に <b><a href="#R9N1">MV1SetupCollInfo</a></b> を呼んで準備を行っておく必要があります、
                    また、MV1SetupCollInfo で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )<br><br>

                    　戻り値である MV1_COLL_RESULT_POLY_DIM は当たり判定の結果が代入されている構造体で、以下のような内容になっています。<br><br>
<pre>
// コリジョン結果代入用ポリゴン配列
struct MV1_COLL_RESULT_POLY_DIM
{
    // 当たったポリゴンの数
    int            HitNum ;

    // 当たったポリゴンの配列へのポインタ
    // ( 配列の要素数は HitNum です )
    MV1_COLL_RESULT_POLY    *Dim ;
} ;
</pre>
                    　また、MV1_COLL_RESULT_POLY_DIM 構造体で使用されている MV1_COLL_RESULT_POLY 構造体は以下のような内容になっています。<br><br>

<pre>
// コリジョン結果代入用ポリゴン
struct MV1_COLL_RESULT_POLY
{
    // どれかのポリゴンに当たったかどうか
    // ( カプセルとの当たり判定の場合は必ず 1 )
    int    HitFlag ;

    // 無効です
    VECTOR    HitPosition ;

    // 当たったポリゴンが含まれるフレームの番号
    int    FrameIndex ;

    // 当たったポリゴンが使用しているマテリアルの番号
    int    MaterialIndex ;

    // 当たったポリゴンを形成する三点の座標
    VECTOR    Position[ 3 ] ;

    // 当たったポリゴンの法線
    VECTOR    Normal ;
} ;
</pre>
                    　構造体の説明ですが、まずカプセルとフレーム( 若しくはモデル全体 )との当たり判定を行うと戻り値として MV1_COLL_RESULT_POLY_DIM 構造体が返ってきます。<br>
                    　この構造体の中身にはメンバ変数 HitNum と Dim があり、当たったポリゴンの数が HitNum に代入されています。<br>
                    　この HitNum が 0 だったら球は対象のフレーム( 若しくはモデル全体 )に含まれるポリゴンに一枚も当たらなかったということです。<br>
                    　そして当たった場合は、当たったポリゴンの数が HitNum に代入され、
                    どんなポリゴンと当たったかに関する情報がポインタ Dim が示すアドレスに当たったポリゴンの数だけ要素がある配列として格納されます。<br><br>

                    　当たったかどうかだけを判断する場合は HitNum が 0 かどうかを判定するだけで、
                    当たったポリゴンに関する情報を扱いたい場合は Dim の先にある配列にアクセスするという使い方になります。<br><br>
                    ( Dim へのアクセスの仕方についてはサンプルプログラムを見ていただくとわかりやすいと思います )

                    　また、この関数は当たるポリゴンの数が不定である関係上、動的にメモリを確保していますので、
                    戻り値の情報が必要なくなった場合は <b><a href="#R9N6">MV1CollResultPolyDimTerminate</a></b> 関数に戻り値の構造体を渡して後始末を行う必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo と上下に動くカプセルの当たり判定をして、カプセルと当たったポリゴンとの最近点を表示します。<br>
            <hr>
<pre>
#include "DxLib.h"

// カプセルの高さ
#define CAPSULE_H        64.0f

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int Add, y, i ;
    VECTOR CapsulePos1, CapsulePos2 ;
    MV1_COLL_RESULT_POLY_DIM HitPolyDim ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ３Ｄモデルを見える位置に移動する
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // モデル全体のコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, -1, 8, 8, 8 ) ;

    // モデルの進行方向をセット
    Add = 8 ;

    // モデルの移動位置をセット
    y = 0 ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの移動位置を上下に移動させる
        y += Add ;
        if( y &lt; 0 || y &gt; 600 )
            Add = -Add ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 当たり判定を行う球の位置をセット
        CapsulePos1 = <b><a href="#R11N1">VGet</a></b>( 250.0f, y, 600.0f ) ;
        CapsulePos2 = <b><a href="#R11N1">VGet</a></b>( 250.0f, y + CAPSULE_H, 600.0f ) ;

        // モデルとカプセルとの当たり判定
        HitPolyDim = MV1CollCheck_Capsule( ModelHandle, -1, CapsulePos1, CapsulePos2,  100.0f ) ;

        // カプセルの描画
        <b><a href="#R14N5">DrawCapsule3D</a></b>( CapsulePos1, CapsulePos2, 100.0f, 8, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ), GetColor( 255,255,255 ), FALSE ) ;

        // 当たったかどうかで処理を分岐
        if( HitPolyDim.HitNum >= 1 )
        {
            // 当たった場合は衝突の情報を描画する

            // 当たったポリゴンの数を描画
            <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ), "Hit Poly Num   %d", HitPolyDim.HitNum ) ;

            // 当たったポリゴンの数だけ繰り返し
            for( i = 0 ; i &lt; HitPolyDim.HitNum ; i ++ )
            {
                // 当たったポリゴンを描画
                <b><a href="#R14N2">DrawTriangle3D</a></b>(
                    HitPolyDim.Dim[ i ].Position[ 0 ], 
                    HitPolyDim.Dim[ i ].Position[ 1 ], 
                    HitPolyDim.Dim[ i ].Position[ 2 ], GetColor( 0,255,255 ), TRUE ) ;
            }
        }

        // 当たり判定情報の後始末
        <b><a href="#R9N6">MV1CollResultPolyDimTerminate</a></b>( HitPolyDim ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N7">宣言</a></b></td><td><font color="#000088"><b>MV1_COLL_RESULT_POLY MV1CollCheck_GetResultPoly( MV1_COLL_RESULT_POLY_DIM ResultPolyDim, int PolyNo ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>当たり判定結果ポリゴン配列から指定番のポリゴン情報を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MV1_COLL_RESULT_POLY_DIM ResultPolyDim ： 当たり判定結果ポリゴン配列構造体<br>
            int PolyNo ： 取得したいポリゴンの番号
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>当たり判定結果ポリゴン<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルと球の当たり判定を <b><a href="#R9N5">MV1CollCheck_Sphere</a></b> で行った結果の MV1_COLL_RESULT_POLY_DIM
                    構造体から指定番号の当たったポリゴンの情報を取得するための関数です。<br>
                    　MV1_COLL_RESULT_POLY_DIM 関数の中にある Dim が示す配列から情報を返すだけの関数ですが、
                    ポインタが苦手な方はこちらの関数を使用してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　モデルファイル SimpleModel.mqo と上下に動く球の当たり判定をして、球と当たったポリゴンとの最近点を表示します。<br>
            　　( MV1CollCheck_Sphere 関数のサンプルを MV1CollCheck_GetResultPoly を使用するように変更したものです )<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int Add, y, i ;
    VECTOR SpherePos ;
    MV1_COLL_RESULT_POLY_DIM HitPolyDim ;
    MV1_COLL_RESULT_POLY HitPoly ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ３Ｄモデルを見える位置に移動する
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // モデル全体のコリジョン情報を構築
    <b><a href="#R9N1">MV1SetupCollInfo</a></b>( ModelHandle, -1, 8, 8, 8 ) ;

    // モデルの進行方向をセット
    Add = 8 ;

    // モデルの移動位置をセット
    y = 0 ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの移動位置を上下に移動させる
        y += Add ;
        if( y &lt; 0 || y &gt; 600 )
            Add = -Add ;

        // ３Ｄモデルの描画
        <b><a href="#R2N1">MV1DrawModel</a></b>( ModelHandle ) ;

        // 当たり判定を行う球の位置をセット
        SpherePos = <b><a href="#R11N1">VGet</a></b>( 250.0f, y, 600.0f ) ;

        // モデルと球との当たり判定
        HitPolyDim = <b><a href="#R9N5">MV1CollCheck_Sphere</a></b>( ModelHandle, -1, SpherePos, 100.0f ) ;

        // 球の描画
        <b><a href="#R14N4">DrawSphere3D</a></b>( SpherePos, 100.0f, 8, <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ), GetColor( 255,255,255 ), FALSE ) ;

        // 当たったかどうかで処理を分岐
        if( HitPolyDim.HitNum >= 1 )
        {
            // 当たった場合は衝突の情報を描画する

            // 当たったポリゴンの数を描画
            <b><a href="dxfunc_graph2.html#R17N20">DrawFormatString</a></b>( 0, 0, GetColor( 255,255,255 ), "Hit Poly Num   %d", HitPolyDim.HitNum ) ;

            // 当たったポリゴンの数だけ繰り返し
            for( i = 0 ; i &lt; HitPolyDim.HitNum ; i ++ )
            {
                // 当たったポリゴンとの最近点の座標を描画
                HitPoly = MV1CollCheck_GetResultPoly( HitPolyDim, i ) ;
                DrawFormatString( 0, 16 + 16 * i, GetColor( 255,255,255 ), "Position   %f  %f  %f",
                    HitPoly.HitPosition.x, HitPoly.HitPosition.y, HitPoly.HitPosition.z ) ;
            }
        }

        // 当たり判定情報の後始末
        <b><a href="#R9N6">MV1CollResultPolyDimTerminate</a></b>( HitPolyDim ) ;

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R9N6">宣言</a></b></td><td><font color="#000088"><b>int MV1CollResultPolyDimTerminate( MV1_COLL_RESULT_POLY_DIM ResultPolyDim ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>当たり判定結果ポリゴン配列の後始末をする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            MV1_COLL_RESULT_POLY_DIM ResultPolyDim ： 当たり判定結果ポリゴン配列構造体
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R9N5">MV1CollCheck_Sphere</a></b> 関数の戻り値である ResultPolyDim 構造体の後始末を行います。<br><br>

                    　MV1CollCheck_Sphere 関数が返す構造体 MV1_COLL_RESULT_POLY_DIM は当たるポリゴンの数が不定な関係上、
                    当たり判定結果を代入するメモリ領域を動的に確保しているので、
                    当たり判定結果を使った処理が終了した際はこの関数で構造体の後始末を行う必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R9N5">MV1CollCheck_Sphere関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><font size="3" color="#005500"><b>参照用メッシュ関係</b><br><br></font></td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R10N1">宣言</a></b></td><td><font color="#000088"><b>int MV1SetupReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>参照用メッシュのセットアップ<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： 参照用メッシュを構築するフレームの番号<br>
            int IsTransform ： 参照用メッシュは頂点座標変換を施したものにするかどうか<br>
            　　　　　　( TRUE：変換を施したもの  FALSE：変換を施さないローカル座標のもの )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )に含まれるポリゴンの座標や法線、ＵＶ値などの情報にアクセスするための準備を行います。<br><br>

                    　３Ｄを扱うゲームを作成していると、
                    しばしば３Ｄモデルを描画する以外の用途で３Ｄモデルのポリゴンの頂点座標や法線座標を扱いたくなるときがあります、
                    最も一般的な例はモデルとの当たり判定ですが、
                    それ以外の用途でも・・・あんまり一般的な例は思いつきませんがあったりします。<br>
                    　参照用メッシュはそんなときに有効なモデルの頂点座標やポリゴン情報にアクセスするための機能です。<br><br>

                    　その使い方ですが、参照用メッシュの機能を使用するにはまずこの関数で参照したいポリゴンを参照するための準備を行う必要があります。
                    参照対象としたいフレームを引数 FrameIndex で指定して( FrameIndex を -1 にすることでモデル全体のポリゴンを参照するための準備をすることができます )、
                    加えて参照用メッシュの頂点座標を、
                    頂点座標変換を施した頂点にするかどうかを引数 IsTransform で指定します。
                    ( TRUE にすると <b><a href="#R3N2">MV1SetPosition</a></b> や <b><a href="#R4N1">MV1AttachAnim</a></b> 等で設定された頂点座標変換が行われたものが、
                    FALSE にすると MV1SetPosition や MV1AttachAnim 等の設定を無視して何も頂点座標変換が行われていないものがそれぞれ取得できます )<br>
                    　因みに参照用メッシュの構築処理はそれなりに負荷の高い処理ですので、
                    できる限り参照したいポリゴンを持つフレームのみを指定した方が良いです。<br><br>

                    　セットアップが完了した後は参照用メッシュの情報が入った構造体 MV1_REF_POLYGONLIST
                    を戻り値として返してくる関数 <b><a href="#R10N4">MV1GetReferenceMesh</a></b> を使用して、実際にポリゴンの情報を取得します。<br>

<pre>
// 参照用ポリゴンデータ構造体
struct MV1_REF_POLYGONLIST
{
    // ポリゴンの数
    int    PolygonNum ;

    // 頂点の数
    int    VertexNum ;

    // 頂点座標の最小値
    VECTOR    MinPosition ;

    // 頂点座標の最大値
    VECTOR    MaxPosition ;

    // ポリゴン構造体の配列へのポインタ
    MV1_REF_POLYGON    *Polygons ;

    // 頂点構造体の配列へのポインタ
    MV1_REF_VERTEX    *Vertexs ;
} ;
</pre>
                    int PolygonNum<br>
                    　参照用メッシュに含まれるポリゴンの数です。<br>
                    　参照の対象をフレームにした場合はフレームに含まれるメッシュが持つポリゴンの総数が、
                    参照の対象をモデルにした場合はモデルに含まれる全メッシュが持つポリゴンの総数が代入されます。<br><br>

                    int VertexNum<br>
                    　参照用メッシュに含まれる頂点の数です。<br>
                    　参照の対象をフレームにした場合はフレームに含まれるメッシュが持つ頂点の総数が、
                    参照の対象をモデルにした場合はモデルに含まれる全メッシュが持つ頂点の総数が代入されます。<br><br>

                    VECTOR MinPosition<br>
                    　参照用メッシュに含まれる頂点座標の最小値です。<br>
                    　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最小値となります。<br><br>

                    VECTOR MaxPosition<br>
                    　参照用メッシュに含まれる頂点座標の最大値です。<br>
                    　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最大値となります。<br><br>

                    MV1_REF_POLYGON *Polygons<br>
                    　参照用メッシュに含まれるポリゴン情報の配列へのポインタです。<br>
                    　配列の要素数は PolygonNum 個で、
                    中身はポリゴンが含まれているフレームの番号、
                    ポリゴンに使用されているマテリアルの番号、
                    ポリゴンの形成に使用されている頂点の番号３つなどです。<br><br>

                    MV1_REF_VERTEX *Vertexs<br>
                    　参照用メッシュに含まれる頂点情報の配列へのポインタです。<br>
                    　配列の要素数は VertexNum 個で、
                    中身は頂点の位置・法線・テクスチャ座標・頂点カラーなどです。<br>
                    　ポリゴンの情報と頂点の情報が分かれているのは多くの場合一つの頂点は複数のポリゴンで使用されているので、
                    ポリゴンの情報の中に頂点の情報を含めてしまうと同じ頂点情報が幾つものポリゴン情報の中に含まれてデータサイズが無駄に大きくなってしまうからです。<br><br>

                    　次に頂点の情報が格納される構造体 MV1_REF_VERTEX は次のような内容になっています。<br>
<pre>
struct MV1_REF_VERTEX
{
    // 位置
    VECTOR    Position ;

    // 法線
    VECTOR    Normal ;

    // テクスチャ座標
    UV    TexCoord[ 2 ] ;

    // ディフューズカラー
    COLOR_U8    DiffuseColor ;

    // スペキュラカラー
    COLOR_U8    SpecularColor ;
} ;
</pre>
                    VECTOR Position<br>
                    　頂点の座標です。<br>
                    　頂点座標変換をする指定をした場合は <b><a href="#R3N2">MV1SetPosition</a></b> や <b><a href="#R4N1">MV1AttachAnim</a></b> などの設定が反映された座標が、
                    座標変換をしないようにした場合は読み込み時のメッシュのローカル座標そのままが代入されます。<br>
                    　座標変換をする指定をした場合は <b><a href="#R10N3">MV1RefreshReferenceMesh</a></b> 関数を呼ぶことで座標値が更新されます。<br><br>

                    VECTOR Normal<br>
                    　頂点の法線です。<br>
                    　頂点座標変換をする指定をした場合は MV1SetRotation や MV1AttachAnim などの設定が反映された法線ベクトルが、
                    座標変換をしないようにした場合は読み込み時のメッシュのローカル法線がそのまま代入されます。<br>
                    　座標変換をする指定をした場合は MV1RefreshReferenceMesh 関数を呼ぶことで法線値が更新されます。<br><br>

                    UV TexCoord[ 2 ]<br>
                    　頂点のテクスチャ座標です。<br>
                    　UV は構造体で、中身は float u, v となっています。<br>
                    　一応マルチテクスチャを考慮して２つのテクスチャ座標を代入できるようになっていますが、
                    現在のバージョンでは TexCoord[ 0 ] しか使いません。<br><br>
                    
                    COLOR_U8 DiffuseColor<br>
                    　頂点のディフューズカラーです。<br>
                    　メッシュに頂点カラーが無かった場合はポリゴンが使用しているマテリアルのディフューズカラーが代入されています。<br><br>

                    COLOR_U8 SpecularColor<br>
                    　頂点のスペキュラカラーです。<br>
                    　現在のバージョンでは必ず r, g, b, a すべての要素が 0.0f となります。<br><br>

                    　次にポリゴンの情報が格納される構造体 MV1_REF_POLYGON は以下のような内容になっています。<br>
<pre>
struct MV1_REF_POLYGON
{
    // ポリゴンが含まれるメッシュを持っているフレームの番号
    unsigned short    FrameIndex ;

    // 使用しているマテリアルの番号
    unsigned short    MaterialIndex ;

    // VIndex が指すインデックスの参照先( 1：フレーム  0：モデル全体 )
    int        VIndexTarget ;

    // 三角形ポリゴンを形成する三頂点の番号
    int        VIndex[ 3 ] ;

    // 三角形ポリゴンを形成する三頂点の座標の最小値
    VECTOR    MinPosition ;

    // 三角形ポリゴンを形成する三頂点の座標の最大値
    VECTOR    MaxPosition ;
} ;
</pre>
                    unsigned short FrameIndex<br>
                    　ポリゴンが含まれるメッシュを持っているフレームの番号です。<br>
                    　すべてのポリゴンはどれかのメッシュに含まれていて、
                    すべてのメッシュはどれかのフレームに含まれているので、
                    この変数の値が不定になることはありません。<br><br>

                    unsigned short MaterialIndex<br>
                    　ポリゴンが使用しているマテリアルの番号です。<br><br>
                    
                    int VIndexTarget<br>
                    　VIndex 配列が示すインデックスの参照先を表す番号が代入されています。<br>
                    　ライブラリ内部で使用されている変数なので、通常ではこの値を利用することはありません。<br><br>

                    int VIndex[ 3 ]
                    　三角形ポリゴンを形成する三頂点の番号です。<br>
                    　例えば０番目のポリゴンで使用されている三頂点の座標を取得したい場合は以下のように記述します。
<pre>
VECTOR Position[ 3 ] ;

Position[ 0 ] = PolygonList.Vertexs[ PolygonList.Polygons[ 0 ].VIndex[ 0 ] ].Position ;
Position[ 1 ] = PolygonList.Vertexs[ PolygonList.Polygons[ 0 ].VIndex[ 1 ] ].Position ;
Position[ 2 ] = PolygonList.Vertexs[ PolygonList.Polygons[ 0 ].VIndex[ 2 ] ].Position ;
</pre>
                    VECTOR MinPosition<br>
                    　ポリゴンを形成する三頂点の座標の最小値です。<br>
                    　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最小値となります。<br><br>

                    VECTOR MaxPosition<br>
                    　ポリゴンを形成する三頂点の座標の最大値です。<br>
                    　座標値は頂点座標変換をする指定をしていた場合は座標変換されたものの最大値となります。<br><br>

                    　尚、参照用メッシュの情報を構築する処理はそれなりに負荷の高い処理ですので、
                    頂点座標変換を行う設定にした場合でも <b><a href="#R3N2">MV1SetPosition</a></b> や <b><a href="#R4N3">MV1SetAttachAnimTime</a></b> などで状態を変更しただけでは参照用メッシュの頂点座標と頂点法線は更新されません。<br>
                    　状態を変更した後に MV1RefreshReferenceMesh 関数で明示的に参照用メッシュをする必要がありますのでご注意ください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                
            　　モデルファイル SimpleModel.mqo 全体の参照用メッシュを構築したあと、ポリゴン一枚一枚の座標を利用して<br>
            　モデルのワイヤーフレームを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int i ;
    MV1_REF_POLYGONLIST RefPoly ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // ３Ｄモデルを見える位置に移動する
    <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, 300.0f, 600.0f ) ) ;

    // モデル全体の参照用メッシュを構築
    <b><a href="#R10N1">MV1SetupReferenceMesh</a></b>( ModelHandle, -1, TRUE ) ;

    // 参照用メッシュ情報の取得
    RefPoly = <b><a href="#R10N4">MV1GetReferenceMesh</a></b>( ModelHandle, -1, TRUE ) ;

    // ポリゴンの数だけ繰り返し
    for( i = 0 ; i &lt; RefPoly.PolygonNum ; i ++ )
    {
        // ポリゴンを形成する三頂点を使用してワイヤーフレームを描画する
        <b><a href="#R14N1">DrawLine3D</a></b>(
            RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
            RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
            <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ) ) ;

        DrawLine3D(
            RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
            RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
            GetColor( 255,255,0 ) ) ;

        DrawLine3D(
            RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
            RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
            GetColor( 255,255,0 ) ) ;
    }

    // キー入力待ち
    <b><a href="dxfunc_other.html#R6N3">WaitKey</a></b>() ;

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R10N2">宣言</a></b></td><td><font color="#000088"><b>int MV1TerminateReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>参照用メッシュの後始末をする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： 参照用メッシュの後始末を行うフレームの番号<br>
            int IsTransform ： 後始末の対象の参照用メッシュ<br>
            　　( TRUE：頂点座標変換を施した参照用メッシュ　FALSE：頂点座標変換を施さない参照用メッシュ )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )用に構築した参照用メッシュの後始末を行います。<br><br>
                
                    　この関数を使用して明示的に参照用メッシュを破棄しなくても、
                    <b><a href="#R1N3">MV1DeleteModel</a></b> や <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b> が呼ばれた際にモデル情報と参照用メッシュの後始末は行われますので、
                    この関数を使用する機会はあまり無いかもしれません。<br><br>

                    　尚、<b><a href="#R10N1">MV1SetupReferenceMesh</a></b> で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>

        
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R10N3">宣言</a></b></td><td><font color="#000088"><b>int MV1RefreshReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>参照用メッシュを更新する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： 参照用メッシュを更新するフレームの番号<br>
            int IsTransform ： 更新する参照用メッシュは頂点座標変換を施したものかどうか<br>
            　　　　　　( TRUE：変換を施したもの  FALSE：変換を施していないもの )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )の参照用メッシュを更新します。<br><br>

                    　モデルを動かさない場合は参照用メッシュを更新する必要はありませんが、
                    動くモデルをコリジョンポリゴンとして使用している場合はこの関数を使用して明示的にコリジョン情報を更新する必要があります。
                    ( 更新しない場合は最後に更新した状態のままとなります )<br><br>

                    　尚、<b><a href="#R10N1">MV1SetupReferenceMesh</a></b> で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
                
            　　モデルファイル SimpleModel.mqo の０番目のフレームの参照用メッシュを構築したあと、上下にモデルを移動しながら<br>
            　ポリゴン一枚一枚の座標を利用して０番目のフレームのワイヤーフレームを描画します。<br>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ModelHandle ;
    int Add, y, i ;
    MV1_REF_POLYGONLIST RefPoly ;

    // ＤＸライブラリの初期化
    if( <b><a href="../dxfunc.html#R1N1">DxLib_Init</a></b>() < 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ３Ｄモデルの読み込み
    ModelHandle = <b><a href="#R1N1">MV1LoadModel</a></b>( "SimpleModel.mqo" ) ;

    // 描画先を裏画面に変更
    <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b>( DX_SCREEN_BACK ) ;

    // ０番目のフレームの参照用メッシュを構築
    <b><a href="#R10N1">MV1SetupReferenceMesh</a></b>( ModelHandle, 0, TRUE ) ;

    // モデルの進行方向をセット
    Add = 8 ;

    // モデルの移動位置をセット
    y = 0 ;

    // ウインドウが閉じられるか何かキーが押されるまでループ
    while( <b><a href="../dxfunc.html#R1N3">ProcessMessage</a></b>() == 0 &amp;&amp; CheckHitKeyAll() == 0 )
    {
        // 画面をクリア
        <b><a href="dxfunc_graph3.html#R4N4">ClearDrawScreen</a></b>() ;

        // ３Ｄモデルの移動位置を上下に移動させる
        y += Add ;
        if( y &lt; 0 || y &gt; 600 )
            Add = -Add ;

        // ３Ｄモデルを移動する
        <b><a href="#R3N2">MV1SetPosition</a></b>( ModelHandle, <b><a href="#R11N1">VGet</a></b>( 320.0f, y, 600.0f ) ) ;

        // ０番目のフレームの参照用メッシュを更新する
        <b><a href="#R10N3">MV1RefreshReferenceMesh</a></b>( ModelHandle, 0, TRUE ) ;

        // ０番目のフレームの参照用メッシュの取得
        RefPoly = <b><a href="#R10N4">MV1GetReferenceMesh</a></b>( ModelHandle, 0, TRUE ) ;

        // ポリゴンの数だけ繰り返し
        for( i = 0 ; i &lt; RefPoly.PolygonNum ; i ++ )
        {
            // ポリゴンを形成する三頂点を使用してワイヤーフレームを描画する
            <b><a href="#R14N1">DrawLine3D</a></b>(
                RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
                RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
                <b><a href="dxfunc_graph3.html#R4N5">GetColor</a></b>( 255,255,0 ) ) ;

            DrawLine3D(
                RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 1 ] ].Position,
                RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
                GetColor( 255,255,0 ) ) ;

            DrawLine3D(
                RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 2 ] ].Position,
                RefPoly.Vertexs[ RefPoly.Polygons[ i ].VIndex[ 0 ] ].Position,
                GetColor( 255,255,0 ) ) ;
        }

        // 裏画面の内容を表画面に反映
        <b><a href="dxfunc_graph3.html#R4N7">ScreenFlip</a></b>() ;
    }

    // ＤＸライブラリの後始末
    <b><a href="../dxfunc.html#R1N2">DxLib_End</a></b>() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>

    
        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R10N4">宣言</a></b></td><td><font color="#000088"><b>MV1_REF_POLYGONLIST MV1GetReferenceMesh( int MHandle, int FrameIndex, int IsTransform ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>参照用メッシュを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int MHandle ： モデルのハンドル<br>
            int FrameIndex ： 参照用メッシュを取得するフレームの番号<br>
            int IsTransform ： 取得する参照用メッシュは頂点座標変換を施したものかどうか<br>
            　　　　　　( TRUE：変換を施したもの  FALSE：変換を施していないもの )
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>参照用メッシュを参照するための構造体<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　MHandle のモデルハンドルが示すモデルの指定のフレーム( 若しくはモデル全体 )の参照用メッシュを取得します。<br>
                    ( この関数で参照用メッシュの構造体を取得する場合は、対象となるフレーム( 若しくはモデル全体 )に対して事前に <b><a href="#R10N1">MV1SetupReferenceMesh</a></b> を呼んで準備を行っておく必要があります、
                    また、MV1SetupReferenceMesh で FrameIndex を -1 にした場合は、この関数でも FrameIndex を -1 にする必要があります )<br><br>

                    　この関数の戻り値である MV1_REF_POLYGONLIST の詳細は MV1SetupReferenceMesh 関数の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R10N1">MV1SetupReferenceMesh関数</a> のサンプル、又は <a href="#R10N3">MV1RefreshReferenceMesh関数</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><font size="3" color="#005500"><b>プログラマブルシェーダー関係関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N1">宣言</a></b></td><td><font color="#000088"><b>int GetValidShaderVersion( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>使用できるシェーダーのバージョンを取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>シェーダーバージョン×１００</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　使用できるプログラマブルシェーダーのバージョンに１００を掛けた値を取得します。( 戻り値が 200 だったらシェーダーモデル2.0が、300だったらシェーダーモデル3.0が使用可能 )<br>
                    この関数の戻り値が０だった場合はプログラマブルシェーダーを使うことはできません。<br>
                    主にプログラマブルシェーダーが使用できるかどうかを確認するために使用します。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　使用できるシェーダーモデルのバージョンを取得して、シェーダーが使用できるかどうかを画面に表示します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int ShaderVersion ;

    // ウインドウモードで起動
    ChangeWindowMode( TRUE );

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // 使用できるプログラマブルシェーダーのバージョンを取得
    ShaderVersion = GetValidShaderVersion() ;

    // バージョン番号が０だったら使用不可能
    if( ShaderVersion == 0 )
    {
        DrawString( 0, 0, "プログラマブルシェーダーを使うことはできません", GetColor( 255,255,255 ) ) ;
    }
    else
    {
        // ０以外だったら使用可能
        DrawFormatString( 0, 0, GetColor( 255,255,255 ), "プログラマブルシェーダーバージョン %.1f が使用可能です", ShaderVersion / 100.0f ) ;
    }

    // キー入力待ち
    WaitKey();

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N36">宣言</a></b></td><td><font color="#000088"><b>int GetMultiDrawScreenNum( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>同時に描画を行うことができる画面の数を取得する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td><td>なし</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>同時に描画できる画面の数</td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ピクセルシェーダーを使用すると複数の MakeScreen で作成できる描画可能画像に対して同時に描画を行うことができるのですが、
                    それにはグラフィックスデバイスがその機能に対応している必要があります。<br>
                    　この関数はグラフィックスデバイスが持つ同時に描画することができる画面の数を取得します。<br>
                    　複数の画面に対して同時に描画する機能が無い場合は戻り値として１が返ってきます。<br>
                    　主に複数の画面に対して同時に描画処理を実行することが可能かどうかを判定するために使用します。<br>
                    　<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　ありません<br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N2">宣言</a></b></td><td><font color="#000088"><b>int LoadVertexShader( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーバイナリを読み込みシェーダーハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            FileName ： 頂点シェーダーバイナリファイルのパス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>−１　　　　：　エラー発生<br>
                    −１以外　：　シェーダーハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　頂点シェーダーのプログラムをコンパイルしてできるバイナリファイルをメモリに読み込み、
                    それを使用するためのハンドル( int型の値 )を取得します。<br>
                    　コンパイル前のシェーダープログラムを読み込むことはできませんので注意してください。( シェーダープログラムをコンパイルするためのソフトはＤＸライブラリのパッケージの Tool\ShaderCompiler の中に入っています )<br>
                    　戻り値で得られるシェーダーハンドルは SetUseVertexShader の引数として使用します。<br>
                    　同時に読み込んでおけるシェーダーの数には限りがありますので、必要が無くなったら DeleteShader で削除してください。<br><br><br>

                    <font color="#660000"><b>頂点シェーダーに渡される頂点データについて</b></font><br><br>

                    　今の所頂点シェーダーに渡される頂点データは以下のように固定されています。<br><br><br>

                    <b>DrawPolygon3DToShader, DrawPolygonIndexed3DToShaderの場合<br>
                    ( DrawPolygon2DToShader, DrawPolygonIndexed2DToShader では<br>
                    　頂点シェーダーは使用されません )</b><br><br>

<pre>
struct VSInput
{
    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Position        : POSITION0 ;

    // 補助座標( VERTEX3DSHADER構造体の spos の値 )
    float4 SubPosition     : POSITION1 ;

    // 法線( VERTEX3DSHADER構造体の norm の値 )
    float3 Normal          : NORMAL0 ;

    // 接線( VERTEX3DSHADER構造体の tan の値 )
    float3 Tangent         : TANGENT ;

    // 従法線( VERTEX3DSHADER構造体の binorm の値 )
    float3 Binormal        : BINORMAL0 ;

    // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 DiffuseColor    : COLOR0 ;

    // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float4 SpecularColor   : COLOR1 ;

    // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord0   : TEXCOORD0 ;

    // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
    float2 TextureCoord1   : TEXCOORD1 ;
} ;
</pre>
<br>

                    <b>MV1DrawModel や MV1DrawFrame などの３Ｄモデル描画の場合</b><br><br>

                    剛体メッシュ( １フレームの影響を受ける頂点のみ )の場合<br>
<pre>
struct VS_INPUT
{
    float4 Position        : POSITION ;    // 座標( ローカル空間 )
    float3 Normal          : NORMAL0 ;    // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;    // ディフューズカラー
    float4 Specular        : COLOR1 ;    // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;    // テクスチャ座標
} ;
</pre>
<br>

                    法線マップ付き剛体メッシュの場合<br>
<pre>
struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    float3 Tan             : TANGENT0 ;        // 接線( ローカル空間 )
    float3 Bin             : BINORMAL0 ;    // 従法線( ローカル空間 )
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</pre>
<br>

                    １頂点へ影響を与えるフレームの数が１〜４個のスキニングメッシュの場合<br>
<pre>
struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</pre>
<br>

                    １頂点へ影響を与えるフレームの数が１〜４個の法線マップ付きスキニングメッシュの場合<br>
<pre>
struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値
    float3 Tan             : TANGENT0 ;        // 接線( ローカル空間 )
    float3 Bin             : BINORMAL0 ;    // 従法線( ローカル空間 )
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</pre>
<br>

                    １頂点へ影響を与えるフレームの数が１〜８個のスキニングメッシュの場合<br>
<pre>
struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス０
    int4   BlendIndices1   : BLENDINDICES1 ;    // スキニング処理用 Float型定数配列インデックス１
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値０
    float4 BlendWeight1    : BLENDWEIGHT1 ;    // スキニング処理用ウエイト値１
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</pre>
<br>

                    １頂点へ影響を与えるフレームの数が１〜８個の法線マップ付きスキニングメッシュの場合<br>
<pre>
struct VS_INPUT
{
    float4 Position        : POSITION ;        // 座標( ローカル空間 )
    int4   BlendIndices0   : BLENDINDICES0 ;    // スキニング処理用 Float型定数配列インデックス０
    int4   BlendIndices1   : BLENDINDICES1 ;    // スキニング処理用 Float型定数配列インデックス１
    float4 BlendWeight0    : BLENDWEIGHT0 ;    // スキニング処理用ウエイト値０
    float4 BlendWeight1    : BLENDWEIGHT1 ;    // スキニング処理用ウエイト値１
    float3 Tan             : TANGENT0 ;        // 接線( ローカル空間 )
    float3 Bin             : BINORMAL0 ;    // 従法線( ローカル空間 )
    float3 Normal          : NORMAL0 ;        // 法線( ローカル空間 )
    float4 Diffuse         : COLOR0 ;        // ディフューズカラー
    float4 Specular        : COLOR1 ;        // スペキュラカラー
    float4 TexCoords0      : TEXCOORD0 ;        // テクスチャ座標
} ;
</pre>
<br>


                    <font color="#660000"><b>ＤＸライブラリ内部で設定する頂点シェーダー定数について</b></font><br><br>

                    　ＤＸライブラリでは SetCameraPositionAndTarget_UpVecY などで設定したカメラの設定や SetLightDirection
                    などで設定したライトの設定などはライブラリ内部でシェーダー定数として設定されています。<br>
                    　以下がその一覧です。<br><br><br>

                    <b>float4型定数</b><br><br>

                    0　　　　　x：0.0f　y：1.0f<br>
                    1　　　　　マテリアルエミッシブカラー + マテリアルアンビエントカラー * グローバルアンビエントカラー<BR>
                    2〜5　　　射影行列の転置行列( ビュー座標から射影座標に変換する行列の転置行列 )<br>
                    6〜9　　　ビュー行列の転置行列( ワールド座標からビュー座標に変換する行列の転置行列 )<br>
                    10　　　　フォグ用パラメータ　x：end/(end - start)　 y：-1/(end - start)<br>
                    　　　　　　　　　　　　　　　　　 z：density　w：自然対数の低<br>
                    11　　　　マテリアルディフューズカラー<BR>
                    12　　　　マテリアルスペキュラカラー<BR>
                    13　　　　マテリアルスペキュラハイライトのパワー<BR>
                    14　　　　有効ライト0番目の位置( ビュー空間 )<br>
                    15　　　　有効ライト0番目の方向( ビュー空間 )<br>
                    16　　　　有効ライト0番目のディフューズカラー<BR>
                    17　　　　有効ライト0番目のスペキュラカラー<BR>
                    18　　　　有効ライト0番目のアンビエントカラーとマテリアルのアンビエントカラーを乗算したもの<br>
                    19　　　　有効ライト0番目の x：有効距離の二乗　y：Falloff<br>
                    　　　　　　　　　　　　　　　　　z：距離減衰パラメータ0　w：距離減衰パラメータ1<br>
                    20　　　　有効ライト0番目の x：距離減衰パラメータ1<br>
                    　　　　　　　　　　　　　　　y：スポットライト用パラメータ0( cos( Phi / 2.0f ) )<br>
                    　　　　　　　　　　　　　　　z：スポットライト用パラメータ1( 1.0f / ( cos( Theta / 2.0f ) - cos( Phi / 2.0f ) ) )<br>
                    21〜27　　有効ライト1番目のパラメータ( 内訳は 14〜20 と同じ )<br>
                    28〜34　　有効ライト2番目のパラメータ( 内訳は 14〜20 と同じ )<br>
                    35〜41　　有効ライト3番目のパラメータ( 内訳は 14〜20 と同じ )<br>
                    42　　　　　トゥーンレンダリング用の輪郭線の太さ<br>
		    43　　　　　ディフューズカラーとスペキュラカラーのソース<br>
		    　　　　　　　　　　　　　　x：ディフューズカラー( 0.0f:マテリアル  1.0f:頂点 )<br>
		    　　　　　　　　　　　　　　y：スペキュラカラー( 　0.0f:マテリアル  1.0f:頂点 )<br>
		    44〜56　　シャドウマップ処理用のパラメータ<br><br>

                    57〜87　　ライブラリでは未使用<br><br>
                    
                    88〜89　　テクスチャ座標変換行列の転置行列０( ３Ｄモデル描画時のみ有効 )<br>
                    90〜91　　テクスチャ座標変換行列の転置行列１( ３Ｄモデル描画時のみ有効 )<br>
                    92〜93　　テクスチャ座標変換行列の転置行列２( ３Ｄモデル描画時のみ有効 )<br>
                    94〜96　　ローカル座標からワールド座標に変換する行列を転置して４行目を削ったもの０<br>
                    97〜255　ローカル座標からワールド座標に変換する行列を転置して４行目を削ったもの１〜５３<br>
                    　　　　　　　( スキニングメッシュの３Ｄモデル描画時のみ有効 )<br><br><br>

                    <b>int4型定数</b><br><br>

                    0〜15　　　　ライブラリでは未使用<br><br><br>

                    <b>BOOL型定数</b><br><br>

                    0　　　　　線形フォグかどうか( TRUE：線形フォグ　FLASE：線形フォグ以外 )<br>
                    1　　　　　指数関数フォグかどうか( TRUE：指数関数フォグ　FLASE：指数関数フォグ以外 )<br>
                    2　　　　　指数関数フォグ２かどうか( TRUE：指数関数２フォグ　FLASE：指数関数２フォグ以外 )<br>
                    3　　　　　フォグを使用するかどうか( TRUE：フォグを使用する　FALSE：フォグを使用しない )<br>
                    4　　　　　ライト0を使用するかどうか( TRUE：使用する　FALSE：使用しない )<br>
                    5　　　　　ライト0はポイントライト若しくはスポットライトかどうか<br>
                    　　　　　　　　　( TRUE：ライトポイント又はスポットライト　FALSE：ライトポイント又はスポットライト以外 )<br>
                    6　　　　　ライト0はスポットライトかどうか( TRUE：スポットライト　FALSE：スポットライト以外 )<br>
                    7〜9　　　ライト1のパラメータ( 内訳は 4〜6 と同じ )<br>
                    10〜12　　ライト2のパラメータ( 内訳は 4〜6 と同じ )<br>
                    12〜14　　ライト3のパラメータ( 内訳は 4〜6 と同じ )<br><br>

                    15　　　　　ライブラリでは未使用<br><br><br>

                    　int4型を除く定数がライブラリで殆ど使ってしまっていますが、これらの定数は <b><a href="#R17N6">SetVSConstF</a></b> などの関数で上書き可能で、
                    オリジナルのシェーダープログラムで使用しない定数については上記ライブラリ定数を無視して使うことができますのでご安心ください。<br>
                    ( 例えばライトを使用しない、若しくはオリジナルのライトパラメータを使う、という場合は float4型定数 14〜41 を上書きして使用しても問題ありません )<br><br>



                    　<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を頂点シェーダーを使用して左右に動かし、<br>
            　ピクセルシェーダーを使用してフェードアウト、フェードインをさせます。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    int x ;
    int xadd ;
    float color ;
    float coloradd ;
    FLOAT4 f4 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( 220.0f, 340.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 420.0f, 340.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 220.0f, 140.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( 220.0f, 140.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet( 420.0f, 340.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 1.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet( 420.0f, 140.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,  0,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 1.0f ;
    Vertex[ 5 ].v    = 1.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "VertexShaderTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "VertexShaderTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 表示座標を移動する処理の初期化
    x = 0 ;
    xadd = 8 ;

    // 色を変化させる処理の初期化
    color = 0.0f ;
    coloradd = 1.0f / 60.0f ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 座標を移動させる
        x += xadd ;
        if( x &gt; 200 || x &lt; -200 )
        {
            xadd = -xadd ;
        }

        // 色の値を変化させる
        color += coloradd ;
        if( color &lt;= 0.0f || color &gt;= 1.0f )
        {
            coloradd = -coloradd ;
        }

        // 座標値を頂点シェーダー float4型定数０番にセット
        f4.x = ( float )x ;
        f4.y = 0.0f ;
        f4.z = 0.0f ;
        f4.w = 0.0f ;
        SetVSConstF( 0, f4 ) ;

        // 色の値をピクセルシェーダー float4型定数０番にセット
        f4.x = color ;
        f4.y = color ;
        f4.z = color ;
        f4.w = 1.0f ;
        SetPSConstF( 0, f4 ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygon3DToShader( Vertex, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用した頂点シェーダーの float4型定数の設定を無効化する
    ResetVSConstF( 0, 2 ) ;

    // 使用したピクセルシェーダーの float4型定数の設定を無効化する
    ResetPSConstF( 0, 1 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>頂点シェーダーのプログラム( コンパイルして VertexShaderTestVS.vso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// 頂点シェーダーの入力
struct VS_INPUT
{
    float4 Position             : POSITION ;    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Normal               : NORMAL0 ;     // 法線( VERTEX3DSHADER構造体の norm の値 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 SpecularColor        : COLOR1 ;      // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord1        : TEXCOORD1 ;   // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
} ;

// 頂点シェーダーの出力
struct VS_OUTPUT
{
    float4 ProjectionPosition   : POSITION ;    // 座標( 射影空間 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;


// C++ 側で設定する定数の定義
float4x4 cfViewMatrix       : register( c6 ) ;    // ワールド座標をビュー座標に変換する行列の転置行列
float4x4 cfProjectionMatrix : register( c2 ) ;    // ビュー座標を射影座標に変換する行列の転置行列

// 頂点座標に加算する値
float4 cfAddPosition : register( c0 ) ;


// main関数
VS_OUTPUT main( VS_INPUT VSInput )
{
    VS_OUTPUT VSOutput ;
    float4 lWorldPosition ;
    float4 lViewPosition ;

    // 入力の頂点座標にＣ＋＋プログラム側で設定した頂点座標を加算する
    lWorldPosition = VSInput.Position + cfAddPosition ;

    // 頂点座標をビュー空間の座標に変換する
    lViewPosition = mul( lWorldPosition, cfViewMatrix ) ;

    // ビュー空間の座標を射影空間の座標に変換する
    VSOutput.ProjectionPosition = mul( lViewPosition, cfProjectionMatrix ) ;

    // テクスチャ座標はそのまま代入
    VSOutput.TextureCoord0 = VSInput.TextureCoord0;

    // 頂点カラーはそのまま代入
    VSOutput.DiffuseColor = VSInput.DiffuseColor ;

    // 関数の戻り値がピクセルシェーダーに渡される
    return VSOutput ;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして VertexShaderTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 DrawColor            : COLOR0 ;    // 描画カラー
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler  DiffuseMapTexture      : register( s0 ) ;

// 描画カラーに乗算する値
float4 cfMultiplyColor          : register( c0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ;

    // 出力する色はテクスチャの色と C++ で設定した値とディフューズカラーを乗算したもの
    PSOutput.DrawColor = lTextureColor * cfMultiplyColor * PSInput.DiffuseColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</pre>
            <hr>

            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N3">宣言</a></b></td><td><font color="#000088"><b>int LoadPixelShader( char *FileName ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーバイナリを読み込みシェーダーハンドルを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            FileName ： ピクセルシェーダーバイナリファイルのパス
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>−１　　　　：　エラー発生<br>
                    −１以外　：　シェーダーハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ピクセルシェーダーのプログラムをコンパイルしてできるバイナリファイルをメモリに読み込み、
                    それを使用するためのハンドル( int型の値 )を取得します。<br>
                    　コンパイル前のシェーダープログラムを読み込むことはできませんので注意してください。( シェーダープログラムをコンパイルするためのソフトはＤＸライブラリのパッケージの Tool\ShaderCompiler の中に入っています )<br>
                    　戻り値で得られるシェーダーハンドルは SetUsePixelShader の引数として使用します。<br>
                    　同時に読み込んでおけるシェーダーの数には限りがありますので、必要が無くなったら DeleteShader で削除してください。<br><br><br>

                    <font color="#660000"><b>ＤＸライブラリ内部で設定するピクセルシェーダー定数について</b></font><br><br>

                    　ＤＸライブラリではフォンシェーディング( ピクセルシェーダーでライティングを行う手法 )の為にマテリアルやライトの設定をライブラリ内部でシェーダー定数として設定しています。<br>
                    　以下がその一覧です。<br><br><br>

                    <b>float4型定数</b><br><br>

                    0　　　　　x：0.0f　 y：0.5f　z：1.0f　w：2.0f<br>
                    1　　　　　マテリアルエミッシブカラー + マテリアルアンビエントカラー * グローバルアンビエントカラー<BR>
                    2　　　　　マテリアルディフューズカラー<BR>
                    3　　　　　マテリアルスペキュラカラー<BR>
                    4　　　　　マテリアルスペキュラハイライトのパワー<BR>
                    5　　　　　不透明度など<br>
                    6　　　　　トゥーンレンダリングの輪郭線の色<br>
                    7　　　　　トゥーンレンダリングの輪郭線の太さ<br>
                    8　　　　　フォグカラー<BR>
		    9　　　　　有効ライト0番目のディフューズカラー<br>
		    10　　　 　有効ライト0番目のスペキュラカラー<br>
		    11　　　 　有効ライト0番目のアンビエントカラー<br>
		    12〜14　　有効ライト1番目のパラメータ( 内訳は 9〜11 と同じ )<br>
		    15〜17　　有効ライト2番目のパラメータ( 内訳は 9〜11 と同じ )<br>
		    18〜21　　シャドウマップ処理用のパラメータ<br><br>

                    22〜31　　未使用( ピクセルシェーダー２．０で使用可能な float4型定数の数は 32個です )<br><br>

                    32　　　　 有効ライト0番目の座標( ビュー空間 )<br>
                    33　　　　 有効ライト0番目の法線( ビュー空間 )<br>
                    34　　　　 有効ライト0番目のディフューズカラー<BR>
                    35　　　 　有効ライト0番目のスペキュラカラー<BR>
                    36　　 　　有効ライト0番目のアンビエントカラーとマテリアルのアンビエントカラーを乗算したもの<br>
                    37　　　　 有効ライト0番目の x：有効距離の二乗　y：Falloff<br>
                    　　　　　　　　　　　　　　　　　z：距離減衰パラメータ0　w：距離減衰パラメータ1<br>
                    38　　　　 有効ライト0番目の x：距離減衰パラメータ1<br>
                    　　　　　　　　　　　　　　　y：スポットライト用パラメータ0( cos( Phi / 2.0f ) )<br>
                    　　　　　　　　　　　　　　　z：スポットライト用パラメータ1( 1.0f / ( cos( Theta / 2.0f ) - cos( Phi / 2.0f ) ) )<br>
                    39〜45　　有効ライト1番目のパラメータ( 内訳は 32〜38 と同じ )<br>
                    46〜52　　有効ライト2番目のパラメータ( 内訳は 32〜38 と同じ )<br>
                    53〜59　　有効ライト3番目のパラメータ( 内訳は 32〜38 と同じ )<br>
                    48〜223　 未使用( ピクセルシェーダー３．０で使用可能な float4型定数の数は 224個です )<br><br><br>

                    <b>int4型定数</b><br><br>

                    0〜15　　　　ライブラリでは未使用( ピクセルシェーダー２．０では int4型定数はありません )<br><br><br>

                    <b>BOOL型定数</b><br><br>

                    0〜15　　　　ライブラリでは未使用( ピクセルシェーダー２．０では int4型定数はありません )<br><br><br>

                    　ライブラリが殆ど使ってしまっていますが、これらの定数は SetPSConstF などの関数で上書き可能で、
                    オリジナルのシェーダープログラムで使用しない定数については上記ライブラリ定数を無視して使うことができますのでご安心ください。<br>
                    ( 例えばオリジナルのマテリアル処理を行う場合は float4型定数 1〜4 を上書きして使用しても問題ありません )<br><br>

                    　<br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　ピクセルシェーダーを使って Tex1.bmp の赤成分と青成分を入れ替えて画面に描画します。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    VERTEX2DSHADER Vert[ 6 ] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "PixelShaderTestPS.pso" ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 1.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 1.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 1.0f ;
    Vert[ 3 ].sv  = 1.0f ;

    Vert[ 4 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 4 ].rhw = 1.0f ;
    Vert[ 4 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 4 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 4 ].u   = 0.0f ;
    Vert[ 4 ].v   = 1.0f ;
    Vert[ 4 ].su  = 0.0f ;
    Vert[ 4 ].sv  = 1.0f ;

    Vert[ 5 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 5 ].rhw = 1.0f ;
    Vert[ 5 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 5 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 5 ].u   = 1.0f ;
    Vert[ 5 ].v   = 0.0f ;
    Vert[ 5 ].su  = 1.0f ;
    Vert[ 5 ].sv  = 0.0f ;

    // 使用するテクスチャを０番にセット
    SetUseTextureToShader( 0, texhandle ) ;

    // 使用するピクセルシェーダーをセット
    SetUsePixelShader( pshandle ) ;

    // シェーダーを使用した２Ｄの２ポリゴンの描画
    DrawPolygon2DToShader( Vert, 2 ) ;

    // キー入力待ち
    WaitKey() ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして PixelShaderTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor       : COLOR0 ;
    float4 SpecularColor      : COLOR1 ;
    float2 TextureCoord0      : TEXCOORD0 ;
    float2 TextureCoord1      : TEXCOORD1 ;
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 Output             : COLOR0 ;
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler DiffuseMapTexture : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor  = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ; 

    // 出力する色は青成分と赤成分を逆転したもの
    PSOutput.Output.r = lTextureColor.b ;
    PSOutput.Output.g = lTextureColor.g ;
    PSOutput.Output.b = lTextureColor.r ;
    PSOutput.Output.a = lTextureColor.a ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</pre>
            <hr>

            <br><br><br><br>
            
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N4">宣言</a></b></td><td><font color="#000088"><b>int DeleteShader( int ShaderHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーハンドルを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ShaderHandle ： 削除する頂点シェーダー又はピクセルシェーダーのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N2">LoadVertexShader</a></b> や <b><a href="#R17N3">LoadPixelShader</a></b> で読み込んだシェーダーを削除します。<br><br>

                    　一度に読み込んでおけるシェーダーの数には限りがあるので、必要が無くなったシェーダーはこの関数を使って削除する必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R17N2">LoadVertexShader</a> や <a href="#R17N3">LoadPixelShader</a>のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N5">宣言</a></b></td><td><font color="#000088"><b>int InitShader( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーハンドルを全て削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N2">LoadVertexShader</a></b> や <b><a href="#R17N3">LoadPixelShader</a></b> で読み込んだシェーダーを全て削除します。<br><br>

                    　DeleteShader では削除したいシェーダーを一つ一つ指定しなければなりませんが、この関数を使えば一度に全てのシェーダーを削除することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N6">宣言</a></b></td><td><font color="#000088"><b>int SetVSConstF( int ConstantIndex, FLOAT4 Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０〜２５５ )<br>
            FLOAT4 Param ： 設定する FLOAT4型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　頂点シェーダーのプログラムで使用するFLOAT4型定数を設定する関数です。<br>
                    　FLOAT4 は構造体で、以下のように定義されています。<br>
<pre>
struct FLOAT4
{
    float x, y, z, w ;
} ;
</pre>
                    　FLOAT4 の文字通り float 型の変数が４つあります。<br>
                    　この x, y, z, w に値を代入して SetVSConstF で定数として設定すると、それがそのまま頂点シェーダーで使えるようになります。<br><br><br>


                    ＜例＞<br><br>

                    [ C++側 ]<br><br>

                    // x=10, y=20, z=30, w=0 の FLOAT4 型の値を定数110にセット<br>
                    FLOAT4 Temp ;<br>
                    Temp.x = 10.0f ;<br>
                    Temp.y = 20.0f ;<br>
                    Temp.z = 30.0f ;<br>
                    Temp.w = 0.0f ;<br>
                    SetVSConstF( 110, Temp ) ;<br><br><br>


                    [ 頂点シェーダー側 ]<br><br>

                    // FLOAT4型定数の 110番目を ConstF110 という名前で使うように宣言<br>
                    // これで SetVSConstF( 110, Temp ) ; で設定した値が ConstF110 という名前で使用可能になる<br>
                    float4 ConstF110 : register( c110 ) ;<br><br><br>


                    　因みに ConstantIndex で有効な値が０〜２５５なのは頂点シェーダー２．０と３．０での float4型定数の最大数が 256個だからです。<br>
                    一度に沢山の FLOAT4型定数を設定したい場合は <b><a href="#R17N10">SetVSConstFArray</a></b> を使用します。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="#R17N14">ResetVSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<b><a href="#R17N2">LoadVertexShader</a></b> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N7">宣言</a></b></td><td><font color="#000088"><b>int SetVSConstFMtx( int ConstantIndex, MATRIX Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数に行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０〜２５２ )<br>
            MATRIX Param ： 設定する MATRIX型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N6">SetVSConstF</a></b> は FLOAT4型の構造体一つ分を頂点シェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数４つ分を一度に設定します。<br>
                    　何故４つかといいますと、MATRIX型は 4×4 の行列で、float型変数16個が中にあり、FLOAT4型構造体の一つが float型変数 4個分なので、
                    16 ÷ 4 = 4 というわけです。<br><br>

                    　具体的には<br>
                    定数番号 ConstantIndex に MATRIX構造体の m[0][0] m[0][1] m[0][2] m[0][3] が、<br>
                    定数番号 ConstantIndex + 1 に MATRIX構造体の m[1][0] m[1][1] m[1][2] m[1][3] が、<br>
                    定数番号 ConstantIndex + 2 に MATRIX構造体の m[2][0] m[2][1] m[2][2] m[2][3] が、<br>
                    定数番号 ConstantIndex + 3 に MATRIX構造体の m[3][0] m[3][1] m[3][2] m[3][3] が、<br>
                    それぞれ左から順に x, y, z, w に代入されて設定されます。<br><br>

                    　頂点シェーダーで使用できる FLOAT4型定数の数が２５６個なのに対し ConstantIndex で指定できる値が２５２までなのは、指定した番号から４個分の定数が必要だからです。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="#R17N14">ResetVSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を SetVSConstFMtx で設定した回転行列と頂点シェーダーを使用して回転させます。<br>
            　回転行列を定数10番に設定しているのは定数２〜９番がビュー行列と射影行列の割り当て位置になっているからです。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    float angle ;
    FLOAT4 pos ;
    MATRIX mtx ;

    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( -128.0f,  128.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet(  128.0f,  128.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( -128.0f, -128.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( -128.0f, -128.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet(  128.0f,  128.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 1.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet(  128.0f, -128.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,  0,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 1.0f ;
    Vertex[ 5 ].v    = 1.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "SetVSConstFMtxTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetVSConstFMtxTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 回転角度の値を初期化
    angle = 0.0f ;

    // 頂点シェーダー FLOAT4型定数０番に表示座標をセット
    pos.x = 320.0f ;
    pos.y = 240.0f ;
    pos.z = 0.0f ;
    pos.w = 0.0f ;
    SetVSConstF( 0, pos ) ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 回転角度を変化させる
        angle += 0.05f ;

        // 回転角度からZ軸回転行列を作成
        mtx = MGetRotZ( angle ) ;

        // 回転行列を頂点シェーダー FLOAT4型定数１０〜１３番にセット
        SetVSConstFMtx( 10, mtx ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygon3DToShader( Vertex, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用したfloat4型定数０番の設定を無効化する
    ResetVSConstF( 0, 1 ) ;

    // 使用したfloat4型定数１０〜１３番の設定を無効化する
    ResetVSConstF( 10, 4 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>頂点シェーダーのプログラム( コンパイルして SetVSConstFMtxTestVS.vso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// 頂点シェーダーの入力
struct VS_INPUT
{
    float4 Position             : POSITION ;    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Normal               : NORMAL0 ;     // 法線( VERTEX3DSHADER構造体の norm の値 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 SpecularColor        : COLOR1 ;      // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord1        : TEXCOORD1 ;   // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
} ;

// 頂点シェーダーの出力
struct VS_OUTPUT
{
    float4 ProjectionPosition   : POSITION ;    // 座標( 射影空間 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;


// C++ 側で設定する定数の定義
float4x4 cfViewMatrix       : register( c6 ) ;    // ワールド座標をビュー座標に変換する行列の転置行列
float4x4 cfProjectionMatrix : register( c2 ) ;    // ビュー座標を射影座標に変換する行列の転置行列

// 回転中心になる座標
float4 cfCenterPosition : register( c0 ) ;

// Ｚ回転行列
float4x4 cfRotateZMatrix : register( c10 ) ;


// main関数
VS_OUTPUT main( VS_INPUT VSInput )
{
    VS_OUTPUT VSOutput ;
    float4 lWorldPosition ;
    float4 lViewPosition ;

    // 入力座標にＺ回転行列を掛けて座標を回転させる
    lWorldPosition = mul( cfRotateZMatrix, VSInput.Position ) ;

    // Ｚ回転しただけだと原点に居るので、表示させたい座標に移動する
    lWorldPosition += cfCenterPosition ;

    // 頂点座標をビュー空間の座標に変換する
    lViewPosition = mul( lWorldPosition, cfViewMatrix ) ;

    // ビュー空間の座標を射影空間の座標に変換する
    VSOutput.ProjectionPosition = mul( lViewPosition, cfProjectionMatrix ) ;

    // テクスチャ座標はそのまま代入
    VSOutput.TextureCoord0 = VSInput.TextureCoord0;

    // 頂点カラーはそのまま代入
    VSOutput.DiffuseColor = VSInput.DiffuseColor ;

    // 関数の戻り値がピクセルシェーダーに渡される
    return VSOutput ;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetVSConstFMtxTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 DrawColor            : COLOR0 ;    // 描画カラー
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler  DiffuseMapTexture      : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ;

    // 出力する色はテクスチャの色とディフューズカラーを乗算したもの
    PSOutput.DrawColor = lTextureColor * PSInput.DiffuseColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</pre>
            <hr>

            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N10">宣言</a></b></td><td><font color="#000088"><b>int SetVSConstFArray( int ConstantIndex, FLOAT4 *ParamArray, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数に行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０〜２５５ )<br>
            FLOAT4 *ParamArray ： FLOAT4型配列の先頭アドレス<br>
            int ParamNum ： 設定する数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N6">SetVSConstF</a></b> は FLOAT4型の構造体一つ分を頂点シェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数を指定数分だけ一度に設定することができます。<br><br>

                    　例えば<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetVSConstFArray( 10, f4array, 3 ) ;<br><br>

                    　は、<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetVSConstF( 10, f4array[ 0 ] ) ;<br>
                    SetVSConstF( 11, f4array[ 1 ] ) ;<br>
                    SetVSConstF( 12, f4array[ 2 ] ) ;<br><br>

                    　と同じ動作をします。<br>
                    　なんでこんな関数があるのかといいますと、単純に何回も SetVSConstF を呼ぶのが面倒だからという理由以外に何回も SetVSConstF を呼ぶのは処理負荷が高いからです。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="#R17N14">ResetVSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を SetVSConstFArray を使って予め設定した画面４隅の座標に順番に描画します。<br>
            　ＨＬＳＬのソースを見ると分かると思いますが、ＨＬＳＬで int4 として宣言した変数も内部では FLOAT4型として扱われるので<br>
            　ciPositionIndex の値を設定する関数も SetVSConstF となっています。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    int posind ;
    int poscounter ;
    FLOAT4 pos[ 4 ] ;
    FLOAT4 f4 ;

    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( -64.0f,  64.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet(  64.0f,  64.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( -64.0f, -64.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;


    Vertex[ 3 ].pos  = VGet( -64.0f, -64.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 0.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    Vertex[ 4 ].pos  = VGet(  64.0f,  64.0f,  0.0f ) ;
    Vertex[ 4 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 4 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 4 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 4 ].u    = 1.0f ;
    Vertex[ 4 ].v    = 0.0f ;
    Vertex[ 4 ].su   = 0.0f ;
    Vertex[ 4 ].sv   = 0.0f ;

    Vertex[ 5 ].pos  = VGet(  64.0f, -64.0f,  0.0f ) ;
    Vertex[ 5 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 5 ].dif  = GetColorU8( 255,  0,  0,255 ) ;
    Vertex[ 5 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 5 ].u    = 1.0f ;
    Vertex[ 5 ].v    = 1.0f ;
    Vertex[ 5 ].su   = 0.0f ;
    Vertex[ 5 ].sv   = 0.0f ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "SetVSConstFArrayTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetVSConstFArrayTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 位置番号処理用の値を初期化
    posind = 0 ;
    poscounter = 0 ;

    // 頂点シェーダー FLOAT4型定数１０〜１３番に表示座標をセット
    pos[ 0 ].x = 100.0f ;
    pos[ 0 ].y = 100.0f ;
    pos[ 0 ].z = 0.0f ;
    pos[ 0 ].w = 0.0f ;
    pos[ 1 ].x = 540.0f ;
    pos[ 1 ].y = 100.0f ;
    pos[ 1 ].z = 0.0f ;
    pos[ 1 ].w = 0.0f ;
    pos[ 2 ].x = 540.0f ;
    pos[ 2 ].y = 380.0f ;
    pos[ 2 ].z = 0.0f ;
    pos[ 2 ].w = 0.0f ;
    pos[ 3 ].x = 100.0f ;
    pos[ 3 ].y = 380.0f ;
    pos[ 3 ].z = 0.0f ;
    pos[ 3 ].w = 0.0f ;
    SetVSConstFArray( 10, pos, 4 ) ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 一定時間経過したら位置番号を変更する
        poscounter ++ ;
        if( poscounter == 30 )
        {
            poscounter = 0 ;

            posind ++ ;
            if( posind == 4 )
            {
                posind = 0 ;
            }
        }

        // 位置番号を FLOAT4型の x に代入して頂点シェーダー FLOAT4型定数０番にセット
        f4.x = ( float )posind ;
        f4.y = 0 ;
        f4.z = 0 ;
        f4.w = 0 ;
        SetVSConstF( 0, f4 ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygon3DToShader( Vertex, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用したfloat4型定数１０〜１３番の設定を無効化する
    ResetVSConstF( 10, 4 ) ;

    // 使用したint4型定数０番の設定を無効化する
    ResetVSConstI( 0, 1 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>頂点シェーダーのプログラム( コンパイルして SetVSConstFArrayTestVS.vso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// 頂点シェーダーの入力
struct VS_INPUT
{
    float4 Position             : POSITION ;    // 座標( VERTEX3DSHADER構造体の pos の値 )
    float3 Normal               : NORMAL0 ;     // 法線( VERTEX3DSHADER構造体の norm の値 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー( VERTEX3DSHADER構造体の dif の値 )
    float4 SpecularColor        : COLOR1 ;      // スペキュラカラー( VERTEX3DSHADER構造体の spc の値 )
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標０( VERTEX3DSHADER構造体の u, v の値 )
    float2 TextureCoord1        : TEXCOORD1 ;   // テクスチャ座標１( VERTEX3DSHADER構造体の su, sv の値 )
} ;

// 頂点シェーダーの出力
struct VS_OUTPUT
{
    float4 ProjectionPosition   : POSITION ;    // 座標( 射影空間 )
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;


// C++ 側で設定する定数の定義
float4x4 cfViewMatrix       : register( c6 ) ;    // ワールド座標をビュー座標に変換する行列の転置行列
float4x4 cfProjectionMatrix : register( c2 ) ;    // ビュー座標を射影座標に変換する行列の転置行列

// 座標値の配列
float4 cfDrawPosition[ 4 ] : register( c10 ) ;

// 座標値配列のインデックス
int4 ciPositionIndex : register( c0 ) ;


// main関数
VS_OUTPUT main( VS_INPUT VSInput )
{
    VS_OUTPUT VSOutput ;
    float4 lWorldPosition ;
    float4 lViewPosition ;

    // 入力座標に座標インデックスで決定する座標を加算する
    lWorldPosition = VSInput.Position + cfDrawPosition[ ciPositionIndex.x ] ;

    // 頂点座標をビュー空間の座標に変換する
    lViewPosition = mul( lWorldPosition, cfViewMatrix ) ;

    // ビュー空間の座標を射影空間の座標に変換する
    VSOutput.ProjectionPosition = mul( lViewPosition, cfProjectionMatrix ) ;

    // テクスチャ座標はそのまま代入
    VSOutput.TextureCoord0 = VSInput.TextureCoord0;

    // 頂点カラーはそのまま代入
    VSOutput.DiffuseColor = VSInput.DiffuseColor ;

    // 関数の戻り値がピクセルシェーダーに渡される
    return VSOutput ;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetVSConstFArrayTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor         : COLOR0 ;      // ディフューズカラー
    float2 TextureCoord0        : TEXCOORD0 ;   // テクスチャ座標
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 DrawColor            : COLOR0 ;    // 描画カラー
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler  DiffuseMapTexture      : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ;

    // 出力する色はテクスチャの色とディフューズカラーを乗算したもの
    PSOutput.DrawColor = lTextureColor * PSInput.DiffuseColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</pre>
            <hr>

            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N14">宣言</a></b></td><td><font color="#000088"><b>int ResetVSConstF( int ConstantIndex, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>頂点シェーダーの FLOAT4 型定数の設定を無効にする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 設定を無効にする FLOAT4型定数の番号( ０〜２５５ )<br>
            int ParamNum ： 無効にする数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N6">SetVSConstF</a></b> などの関数で行った頂点シェーダーの FLOAT4型定数の設定を無効化します。<br>
                    　この関数の用途は主にＤＸライブラリ側で設定する定数の値を使用する場合です。<br>
                    　例えばある頂点シェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要ないということで FLOAT4型定数 11〜13に対して SetVSConstF で定数を上書きしたとします。
                    そしてその後別の頂点シェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要、となったときに、
                    予め ResetVSConstF を使用して 11〜13 に対して行った定数の設定を無効化することでＤＸライブラリ側が設定した定数を使用することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　効果的な使い方はしていませんが、<a href="#R17N2">LoadVertexShader</a> や <a href="#R17N7">SetVSConstFMtx</a>のサンプルで使用しています。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N17">宣言</a></b></td><td><font color="#000088"><b>int SetPSConstF( int ConstantIndex, FLOAT4 Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０〜３１ or ０〜２２３ )<br>
            FLOAT4 Param ： 設定する FLOAT4型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　ピクセルシェーダーのプログラムで使用するFLOAT4型定数を設定する関数です。<br>
                    　FLOAT4 は構造体で、以下のように定義されています。<br>
<pre>
struct FLOAT4
{
    float x, y, z, w ;
} ;
</pre>
                    　FLOAT4 の文字通り float 型の変数が４つあります。<br>
                    　この x, y, z, w に値を代入して SetVSConstF で定数として設定すると、それがそのまま頂点シェーダーで使えるようになります。<br><br><br>


                    ＜例＞<br><br>

                    [ C++側 ]<br><br>

                    // x=10, y=20, z=30, w=0 の FLOAT4 型の値を定数10にセット<br>
                    FLOAT4 Temp ;<br>
                    Temp.x = 10.0f ;<br>
                    Temp.y = 20.0f ;<br>
                    Temp.z = 30.0f ;<br>
                    Temp.w = 0.0f ;<br>
                    SetPSConstF( 10, Temp ) ;<br><br><br>


                    [ ピクセルシェーダー側 ]<br><br>

                    // FLOAT4型定数の 10番目を ConstF10 という名前で使うように宣言<br>
                    // これで SetPSConstF( 10, Temp ) ; で設定した値が ConstF10 という名前で使用可能になる<br>
                    float4 ConstF10 : register( c10 ) ;<br><br><br>


                    　因みに ConstantIndex で有効な値が０〜３１ or ０〜２２３なのは float4型定数の数がピクセルシェーダー２．０では 32個、３．０では 224個だからです。<br>
                    一度に沢山の FLOAT4型定数を設定したい場合は <b><a href="#R17N21">SetPSConstFArray</a></b> を使用します。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="#R17N25">ResetPSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を貼り付けたポリゴン２枚を SetPSConstF で設定した r, g, b の値を乗算して描画します。<br>
            　因みに x, y, z, w は r, g, b, a に対応しています。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    VERTEX2DSHADER Vert[ 6 ] ;
    int r, g, b ;
    int radd, gadd, badd ;
    FLOAT4 f4 ;

    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetPSConstFTestPS.pso" ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 1.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 1.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 1.0f ;
    Vert[ 3 ].sv  = 1.0f ;

    Vert[ 4 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 4 ].rhw = 1.0f ;
    Vert[ 4 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 4 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 4 ].u   = 0.0f ;
    Vert[ 4 ].v   = 1.0f ;
    Vert[ 4 ].su  = 0.0f ;
    Vert[ 4 ].sv  = 1.0f ;

    Vert[ 5 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 5 ].rhw = 1.0f ;
    Vert[ 5 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 5 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 5 ].u   = 1.0f ;
    Vert[ 5 ].v   = 0.0f ;
    Vert[ 5 ].su  = 1.0f ;
    Vert[ 5 ].sv  = 0.0f ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // r, g, b の値を変化させる準備
    r = 0 ;
    g = 128 ;
    b = 255 ;
    radd = 10 ;
    gadd = 7 ;
    badd = 3 ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // r, g, b の値を変化させる
        r += radd ;
        if( r >= 255 )
        {
            r = 255 ;
            radd = -radd ;
        }
        else
        if( r <= 0 )
        {
            r = 0 ;
            radd = -radd ;
        }

        g += gadd ;
        if( g >= 255 )
        {
            g = 255 ;
            gadd = -gadd ;
        }
        else
        if( g <= 0 )
        {
            g = 0 ;
            gadd = -gadd ;
        }

        b += badd ;
        if( b >= 255 )
        {
            b = 255 ;
            badd = -badd ;
        }
        else
        if( b <= 0 )
        {
            b = 0 ;
            badd = -badd ;
        }

        // r, g, b の値をピクセルシェーダーの FLOAT4型定数０番にセット
        // 定数にするときは値を 0.0f 〜 1.0f にする
        f4.x = r / 255.0f ;
        f4.y = g / 255.0f ;
        f4.z = b / 255.0f ;
        f4.w = 1.0f ;
        SetPSConstF( 0, f4 ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // シェーダーを使用した２Ｄの２ポリゴンの描画
        DrawPolygon2DToShader( Vert, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // 使用した定数を無効化する
    ResetPSConstF( 0, 1 ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetPSConstFTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor       : COLOR0 ;
    float4 SpecularColor      : COLOR1 ;
    float2 TextureCoord0      : TEXCOORD0 ;
    float2 TextureCoord1      : TEXCOORD1 ;
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 Output             : COLOR0 ;
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler DiffuseMapTexture : register( s0 ) ;

// テクスチャの色に乗算する値
float4 cfMultiplyColor : register( c0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor  = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ; 

    // 出力する色はテクスチャの色と定数を乗算したもの
    PSOutput.Output = lTextureColor * cfMultiplyColor ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</pre>
            <hr>

            <br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N18">宣言</a></b></td><td><font color="#000088"><b>int SetPSConstFMtx( int ConstantIndex, MATRIX Param ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数に行列を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０〜２２０ )<br>
            MATRIX Param ： 設定する MATRIX型の値
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N17">SetPSConstF</a></b> は FLOAT4型の構造体一つ分をピクセルシェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数４つ分を一度に設定します。<br>
                    　何故４つかといいますと、MATRIX型は 4×4 の行列で、float型変数16個が中にあり、FLOAT4型構造体の一つが float型変数 4個分なので、
                    16 ÷ 4 = 4 というわけです。<br><br>

                    　具体的には<br>
                    定数番号 ConstantIndex に MATRIX構造体の m[0][0] m[0][1] m[0][2] m[0][3] が、<br>
                    定数番号 ConstantIndex + 1 に MATRIX構造体の m[1][0] m[1][1] m[1][2] m[1][3] が、<br>
                    定数番号 ConstantIndex + 2 に MATRIX構造体の m[2][0] m[2][1] m[2][2] m[2][3] が、<br>
                    定数番号 ConstantIndex + 3 に MATRIX構造体の m[3][0] m[3][1] m[3][2] m[3][3] が、<br>
                    それぞれ左から順に x, y, z, w に代入されて設定されます。<br><br>

                    　ピクセルシェーダーで使用できる FLOAT4型定数の数が２２４個なのに対し ConstantIndex で指定できる値が２２０までなのは、指定した番号から４個分の定数が必要だからです。<br><br>

                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="#R17N25">ResetPSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>

        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N21">宣言</a></b></td><td><font color="#000088"><b>int SetPSConstFArray( int ConstantIndex, FLOAT4 *ParamArray, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数を配列を使って設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 変更する FLOAT4型定数の番号( ０〜３１ or ０〜２２３ )<br>
            FLOAT4 *ParamArray ： FLOAT4型配列の先頭アドレス<br>
            int ParamNum ： 設定する数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N17">SetPSConstF</a></b> は FLOAT4型の構造体一つ分をピクセルシェーダーの FLOAT4型定数として設定する関数でしたが、
                    この関数は FLOAT4型定数を指定数分だけ一度に設定することができます。<br><br>

                    　例えば<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetPSConstFArray( 10, f4array, 3 ) ;<br><br>

                    　は、<br><br>

                    FLOAT4 f4array[ 3 ] ;<br>
                    f4array[ 0 ].x = 100.0f ;<br>
                    f4array[ 0 ].y = 65.0f ;<br>
                    f4array[ 0 ].z = 19.0f ;<br>
                    f4array[ 0 ].w = 888.0f ;<br>
                    f4array[ 1 ].x = 296.0f ;<br>
                    f4array[ 1 ].y = 879.0f ;<br>
                    f4array[ 1 ].z = 1111.0f ;<br>
                    f4array[ 1 ].w = 6.0f ;<br>
                    f4array[ 2 ].x = 769910.0f ;<br>
                    f4array[ 2 ].y = 4023.0f ;<br>
                    f4array[ 2 ].z = 61.0f ;<br>
                    f4array[ 2 ].w = 735.0f ;<br>
                    SetPSConstF( 10, f4array[ 0 ] ) ;<br>
                    SetPSConstF( 11, f4array[ 1 ] ) ;<br>
                    SetPSConstF( 12, f4array[ 2 ] ) ;<br><br>

                    　と同じ動作をします。<br>
                    　なんでこんな関数があるのかといいますと、単純に何回も SetPSConstF を呼ぶのが面倒だからという理由以外に何回も SetPSConstF を呼ぶのは処理負荷が高いからです。<br><br>

                    　因みに ConstantIndex で有効な値が０〜３１ or ０〜２２３なのは float4型定数の数がピクセルシェーダー２．０では 32個、３．０では 224個だからです。<br>
                    　尚、この関数で値を設定した後、ＤＸライブラリ側で設定する定数が必要になった場合は <b><a href="#R17N25">ResetPSConstF</a></b> 関数で設定した値を無効にする必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　ありません。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N25">宣言</a></b></td><td><font color="#000088"><b>int ResetPSConstF( int ConstantIndex, int ParamNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>ピクセルシェーダーの FLOAT4 型定数の設定を無効にする<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ConstantIndex ： 設定を無効にする FLOAT4型定数の番号( ０〜３１ or ０〜２２３ )<br>
            int ParamNum ： 無効にする数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N17">SetPSConstF</a></b> などの関数で行ったピクセルシェーダーの FLOAT4型定数の設定を無効化します。<br>
                    　この関数の用途は主にＤＸライブラリ側で設定する定数の値を使用する場合です。<br>
                    　例えばあるピクセルシェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要ないということで FLOAT4型定数 2〜4に対して SetPSConstF で定数を上書きしたとします。
                    そしてその後別のピクセルシェーダーではＤＸライブラリ側で設定したマテリアルの定数が必要、となったときに、
                    予め ResetPSConstF を使用して 2〜4 に対して行った定数の設定を無効化することでＤＸライブラリ側が設定した定数を使用することができます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　効果的な使い方はしていませんが、<a href="#R17N2">LoadVertexShader</a> や <a href="#R17N17">SetPSConstF</a>のサンプルで使用しています。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N28">宣言</a></b></td><td><font color="#000088"><b>int SetRenderTargetToShader( int TargetIndex, int DrawScreen ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>描画先を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int TargetIndex ： 描画先を設定する出力番号<br>
            int DrawScreen ： 描画先グラフィックハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　通常描画先は <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b> を使用して変更しますが、
                    グラフィックスデバイスが対応していればピクセルシェーダーは複数の描画先に対して同時に描画を行うことができます。
                    ( ただし出力先を分けるのはピクセルシェーダーなので別画像の同一座標に描画する色を変化させる程度ですが・・・ )<br><br>

                    　ピクセルシェーダーで出力先を複数にするのは簡単で、普段ピクセルシェーダーの出力の定義は<br><br>

<pre>
struct PS_OUTPUT
{
    float4 Output             : COLOR0 ;
} ;
</pre>

                    　このようになっていますが、この Output が単純に増えます。<br>
                    　例えば出力先が３つの場合は。<br><br>

<pre>
struct PS_OUTPUT
{
    float4 Output0            : COLOR0 ;
    float4 Output1            : COLOR1 ;
    float4 Output2            : COLOR2 ;
} ;
</pre>
                    　このようになります。<br><br>

                    　グラフィックスデバイスが複数の描画先への描画に対応しているかどうか、
                    また幾つまで対応しているかは <b><a href="#R17N36">GetMultiDrawScreenNum</a></b> で調べることができます。<br><br>

                    　描画先として設定する出力番号の０番は SetDrawScreen で設定できる描画先と同じですので、
                    TargetIndex を 0 にした場合は内部で SetDrawScreen が呼ばれます。<br><br>

                    　尚、TargetIndex の 1 以上の番号に設定した描画先の設定を無効にしたい場合は、DrawScreen を -1 にして呼び出します。<br><br>

                    　複数の描画先への描画の主な用途はピクセルシェーダーの出力が単純な色だけではない特殊な用途に使用する場合で、
                    例えば出力先０番には色を、出力先１番には法線の方向を、出力先２番にはカメラからの距離を出力したい、という場合に使用します。<br>
                    　入力の二つのテクスチャにそれぞれ座標と速度を描画しておいて、
                    出力先の二つのテクスチャにそれぞれ座標に速度を足したものと減速後の速度を描画する、
                    そのテクスチャを頂点シェーダーで読み取ってその座標に絵を描画するということをすればピクセルシェーダーを使ってオブジェクトの挙動の処理を行うこともできます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　Tex1.bmp を二つの描画先に描画します、片方は画像の赤成分だけを描画して、もう片方には画像の緑成分だけを描画します。<br>
            　そしてその結果を画面に表示します。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    int screen0, screen1 ;
    VERTEX2DSHADER Vert[ 6 ] ;

    ChangeWindowMode( TRUE ) ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "SetRenderTargetTestPS.pso" ) ;

    // ２５６×２５６の描画可能なグラフィックハンドルを二つ作成する
    screen0 = MakeScreen( 256, 256 ) ;
    screen1 = MakeScreen( 256, 256 ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 0.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 0.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 0.0f ;
    Vert[ 3 ].sv  = 0.0f ;

    Vert[ 4 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 4 ].rhw = 1.0f ;
    Vert[ 4 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 4 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 4 ].u   = 0.0f ;
    Vert[ 4 ].v   = 1.0f ;
    Vert[ 4 ].su  = 0.0f ;
    Vert[ 4 ].sv  = 0.0f ;

    Vert[ 5 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 5 ].rhw = 1.0f ;
    Vert[ 5 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 5 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 5 ].u   = 1.0f ;
    Vert[ 5 ].v   = 0.0f ;
    Vert[ 5 ].su  = 0.0f ;
    Vert[ 5 ].sv  = 0.0f ;

    // 描画先０を描画可能画像の一つ目に設定
    SetRenderTargetToShader( 0, screen0 ) ;

    // 描画先１を描画可能画像の二つ目に設定
    SetRenderTargetToShader( 1, screen1 ) ;

    // 使用するテクスチャを０番にセット
    SetUseTextureToShader( 0, texhandle ) ;

    // 使用するピクセルシェーダーをセット
    SetUsePixelShader( pshandle ) ;

    // シェーダーを使用した２Ｄの２ポリゴンの描画
    DrawPolygon2DToShader( Vert, 2 ) ;

    // 描画先を表画面に変更
    SetDrawScreen( DX_SCREEN_FRONT ) ;

    // 描画先１の設定をリセット
    SetRenderTargetToShader( 1, -1 ) ;

    // 二つの描画可能画像を並べて描画
    DrawGraph(   0, 0, screen0, FALSE ) ;
    DrawGraph( 256, 0, screen1, FALSE ) ;

    // キー入力待ち
    WaitKey() ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</pre>
            <hr>

<br><br><br>
            <hr>
            <b>ピクセルシェーダーのプログラム( コンパイルして SetRenderTargetTestPS.pso になる前のＨＬＳＬソース )</b>
            <hr>
<pre>
// ピクセルシェーダーの入力
struct PS_INPUT
{
    float4 DiffuseColor       : COLOR0 ;
    float4 SpecularColor      : COLOR1 ;
    float2 TextureCoord0      : TEXCOORD0 ;
    float2 TextureCoord1      : TEXCOORD1 ;
} ;

// ピクセルシェーダーの出力
struct PS_OUTPUT
{
    float4 Output0            : COLOR0 ;
    float4 Output1            : COLOR1 ;
} ;


// C++ 側で設定する定数の定義

// 描画するテクスチャ
sampler DiffuseMapTexture : register( s0 ) ;


// main関数
PS_OUTPUT main( PS_INPUT PSInput )
{
    PS_OUTPUT PSOutput ;
    float4 lTextureColor ;

    // テクスチャーの色を取得
    lTextureColor  = tex2D( DiffuseMapTexture, PSInput.TextureCoord0 ) ; 

    // 出力先０には赤成分だけ出力
    PSOutput.Output0.r = lTextureColor.r ;
    PSOutput.Output0.g = 0.0f ;
    PSOutput.Output0.b = 0.0f ;
    PSOutput.Output0.a = 1.0f ;

    // 出力先１には緑成分だけ出力
    PSOutput.Output1.r = 0.0f ;
    PSOutput.Output1.g = lTextureColor.g ;
    PSOutput.Output1.b = 0.0f ;
    PSOutput.Output1.a = 1.0f ;

    // 関数の戻り値がラスタライザに渡される
    return PSOutput ;
}
</pre>
            <hr>

            <br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N29">宣言</a></b></td><td><font color="#000088"><b>int SetUseTextureToShader( int StageIndex, int GraphHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダー描画で使用するテクスチャを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int StageIndex ： 設定するテクスチャステージ番号<br>
            int GraphHandle ： 設定するテクスチャを持つグラフィックハンドル又は -1
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N33">DrawPolygon3DToShader</a></b> などのプログラマブルシェーダーを使用した描画で使用するグラフィックハンドルを設定する関数です。<br>
                    　DrawGraph や DrawExtendGraph などの関数では使用する画像は一つと分かっているので関数の引数にグラフィックハンドルを渡しますが、
                    シェーダーを使用した描画では複数の画像を使用することができるので、DrawPolygon3DToShader などの関数の引数としてグラフィックハンドルを渡すことは無く、
                    代わりにこの関数を使用して事前に描画に使用するグラフィックハンドルを設定しておきます。<br><br>

                    　この関数で指定した番号と、シェーダープログラムでの対応ですが、<br><br>
                    
                    sampler DiffuseMapTexture : register( s0 ) ;<br><br>

                    　例えば↑の場合の s0 の 0 の部分が StageIndex の値になります。<br>
                    　なので StageIndex に 2 を渡して設定した画像は<br><br>

                    sampler OtherTexture : register( s2 ) ;<br><br>

                    　という感じに s2 を指定することで使用することができます。<br>
                    　尚、この関数に渡すグラフィックハンドルが持つ画像は縦横のサイズが 2 の n乗では無い場合に正常な描画結果が得られませんので注意してください。<br>
                    ( 2 の n乗の値は 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192 といった値です。<br>
                    なのでこれに当てはまらない縦幅、横幅の画像を LoadGraph で読み込んでこの関数の引数に渡しても、正常な描画結果を得られません )<br><br>

                    　設定したグラフィックハンドルを外したい場合は GraphHandle の値を -1 にして関数を呼んでください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R17N2">LoadVertexShader</a> などのシェーダー関係関数のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N30">宣言</a></b></td><td><font color="#000088"><b>int SetUseVertexShader( int ShaderHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダー描画に使用する頂点シェーダーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ShaderHandle ： 使用する頂点シェーダーのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N33">DrawPolygon3DToShader</a></b> などのプログラマブルシェーダーを使用した描画で使用する頂点シェーダーを設定する関数です。<br>
                    　頂点シェーダーハンドルは <b><a href="#R17N33">LoadVertexShader</a></b> で頂点シェーダーバイナリファイルから読み込み、
                    取得することができます。<br>
                    　この関数で設定した頂点シェーダーは DrawPolygon3DToShader, <b><a href="#R17N33">DrawPolygonIndexed3DToShader</a></b> の描画時に使用されます。<br>
                    　また、<b><a href="#R19N1">MV1SetUseOrigShader</a></b> で３Ｄモデルの描画にオリジナルシェーダーを使用するように設定されていた場合は
                    <b><a href="#R2N1">MV1DrawModel</a></b> などの３Ｄモデルの描画関数が呼ばれた際にも使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R17N2">LoadVertexShader</a> などのシェーダー関係関数のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N31">宣言</a></b></td><td><font color="#000088"><b>int SetUsePixelShader( int ShaderHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダー描画に使用するピクセルシェーダーを設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            int ShaderHandle ： 使用するピクセルシェーダーのハンドル
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N33">DrawPolygon3DToShader</a></b> などのプログラマブルシェーダーを使用した描画で使用するピクセルシェーダーを設定する関数です。<br>
                    　ピクセルシェーダーハンドルは <b><a href="#R17N3">LoadPixelShader</a></b> でピクセルシェーダーバイナリファイルから読み込み、
                    取得することができます。<br>
                    　この関数で設定したピクセルシェーダーは DrawPolygon〜ToShader と付いている描画関数での描画時に使用されます。<br>
                    　また、<b><a href="#R19N1">MV1SetUseOrigShader</a></b> で３Ｄモデルの描画にオリジナルシェーダーを使用するように設定されていた場合は
                    <b><a href="#R2N1">MV1DrawModel</a></b> などの３Ｄモデルの描画関数が呼ばれた際にも使用されます。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R17N2">LoadVertexShader</a> などのシェーダー関係関数のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N32">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygon2DToShader( VERTEX2DSHADER *Vertex, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って２Ｄポリゴンを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX2DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N3">LoadPixelShader</a></b> で読み込んだピクセルシェーダーを使用して三角形ポリゴンの描画を行います。<br>
                    　Vertex の引数として用意する必要がある VERTEX2DSHADER 構造体の数は描画するポリゴンの数×３になります。<br>
                    　また、この関数を呼び出す前に <b><a href="#R17N31">SetUsePixelShader</a></b> で使用するピクセルシェーダーを設定しておく必要があります。
                    ( テクスチャを使用する場合は <b><a href="#R17N29">SetUseTextureToShader</a></b> によるテクスチャの設定も・・・ )<br>

                    　描画に使用する VERTEX2DSHADER 構造体は以下のように定義されています。<br>
<pre>
struct VERTEX2DSHADER
{
    VECTOR      pos ;      // スクリーン座標
    float       rhw ;      // 同次 W の逆数、通常は 1.0f でＯＫ
    COLOR_U8    dif ;      // ディフューズカラー
    COLOR_U8    spc ;      // スペキュラカラー
    float       u, v ;     // テクスチャ座標０
    float       su, sv ;   // テクスチャ座標１
} ;
</pre>
                    　そして、この関数では頂点処理は行われないので頂点シェーダーが使用されません、<br>
                    普段頂点シェーダーでピクセルシェーダーの入力データ形式が決定しますが、<br>
                    この関数を使用した場合のピクセルシェーダーの入力は固定で以下のようになります。<br>

<pre>
struct PS_INPUT
{
    float4 DiffuseColor  : COLOR0 ;      // ディフューズカラー
    float4 SpecularColor : COLOR1 ;      // スペキュラカラー
    float2 TextureCoord0 : TEXCOORD0 ;   // テクスチャ座標０
    float2 TextureCoord1 : TEXCOORD1 ;   // テクスチャ座標１
} ;
</pre>
                    　２Ｄのフィルター処理などを行う場合は３Ｄの処理が必要ないので、頂点シェーダーを書く必要も無くお手軽です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R17N3">LoadPixelShader</a> や <a href="#R17N6">SetPSConstF</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N33">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygon3DToShader( VERTEX3DSHADER *Vertex, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って３Ｄポリゴンを描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX3DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N2">LoadVertexShader</a></b> と <b><a href="#R17N3">LoadPixelShader</a></b> で読み込んだプログラマブルシェーダーを使用して三角形ポリゴンの描画を行います。<br>
                    　Vertex の引数として用意する必要がある VERTEX3DSHADER 構造体の数は描画するポリゴンの数×３になります。<br><br>
                    　また、この関数を呼び出す前に <b><a href="#R17N30">SetUseVertexShader</a></b> と <b><a href="#R17N31">SetUsePixelShader</a></b> で使用するシェーダーを設定しておく必要があります。
                    ( テクスチャを使用する場合は <b><a href="#R17N29">SetUseTextureToShader</a></b> によるテクスチャの設定も・・・ )<br>

                    　描画に使用する VERTEX3DSHADER 構造体は以下のように定義されています。<br>
<pre>
struct VERTEX3DSHADER
{
    VECTOR    pos ;      // 座標
    VECTOR    norm ;     // 法線
    COLOR_U8  dif ;      // ディフューズカラー
    COLOR_U8  spc ;      // スペキュラカラー
    float     u, v ;     // テクスチャ座標０
    float     su, sv ;   // テクスチャ座標１
} ;
</pre>
                    　この関数で描画処理を行った場合の頂点シェーダーの入力形式は <b><a href="#R17N2">LoadVertexShader</a></b> の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　<a href="#R17N2">LoadVertexShader</a> や <a href="#R17N7">SetVSConstFMtx</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N34">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygonIndexed2DToShader( VERTEX2DSHADER *Vertex, int VertexNum, unsigned short *Indices, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って２Ｄポリゴンを描画する(インデックスを使用)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX2DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int VertexNum ： 頂点の数( Vertex で渡す配列の長さ )<br>
            unsigned short *Indices ： 頂点番号配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N32">DrawPolygon2DToShader</a></b> と機能は殆ど同じですが、頂点番号配列を使用するところが違います。<br>
                    　例えば <b><a href="#R17N3">LoadPixelShader</a></b> のサンプルプログラムでは VERTEX2DSHADER ６個の配列を用意していますが、
                    値を代入しているところを良く見ると配列要素１番と５番、２番と４番が全く同じなのが分かります。<br>
                    　プログラムを実行してみるとわかりますが、これは二つの三角形ポリゴンをぴったりつなぎ合わせて１枚の四角いポリゴンを表現していて、
                    二つのポリゴン中で接している頂点同士は全く同じ情報を持つからです。<br>
                    　全く同じ情報を持つならその分その情報は余計なものとなります。本来なら４頂点分の情報で済むところが６頂点分の情報を持っているわけですから・・・<br>
                    　そんなときに頂点番号配列を使用します。<br><br>

                    　頂点番号配列は三角形ポリゴンが Vertex で渡した頂点配列の何番目と何番目と何番目を使って三角形ポリゴンを表現するか、という頂点番号３つの組み合わせがひたすら代入された配列です。<br>
                    　例えば四角を表現する場合は四角の(0)左上の頂点、(1)右上の頂点、(2)左下の頂点、(3)右下の頂点の４頂点を使って、<br>
                    (0)左上の頂点、(1)右上の頂点、(2)左下の頂点で三角形ポリゴン一つ、<br>
                    (2)左下の頂点、(1)右上の頂点、(3)右下の頂点で三角形ポリゴンをもう一つ表現すれば<br>
                    四角を表現することができます。<br>
                    　このように、頂点の配列＋３角形を表現するための頂点番号の配列で三角形ポリゴンを描画するのが DrawPolygonIndexed 系の関数です。<br><br>

                    　例えば上記の場合を具体的にすると、引数 Vertex に渡す頂点の配列は<br>
                    配列の０番目に四角の左上の頂点の情報<br>
                    １番目に四角の右上の頂点の情報<br>
                    ２番目に四角の左下の頂点の情報<br>
                    ３番目に四角の右下の頂点の情報を代入しておきます。<br>
                    そして VertexNum の数は 4 です。<br><br>

                    　引数 Indices に渡す頂点番号配列は<br>
                    配列の０番目に０( 左上の頂点が代入されている配列番号 )、<br>
                    配列の１番目に１( 右上の頂点が代入されている配列番号 )、<br>
                    配列の２番目に２( 左下の頂点が代入されている配列番号 )、<br>
                    配列の３番目に２( 左下の頂点が代入されている配列番号 )、<br>
                    配列の４番目に１( 右上の頂点が代入されている配列番号 )、<br>
                    配列の５番目に３( 右下の頂点が代入されている配列番号 )を代入しておきます。<br>
                    そして PolygonNum の数は 2 です。<br><br>

                    　DrwaPolygon2DToShader の場合は Vertex 配列の要素の数が PolygonNum × 3 である必要がありましたが、<br>
                    DrawPolygonIndexed2DToShader では Vertex 配列の代わりに Indices 配列の要素の数が PolygonNum × 3 である必要があります。<br><br>

                    　四角ポリゴン１枚くらいなら Indexed の関数を使う必要は無いかもしれませんが、重複する頂点の多いポリゴン集合を描画しようとした場合は結構有用です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　LoadPixelShader のサンプルプログラムのＣ＋＋の部分のみを DrawPolygonIndexed2DToShader を使用するようにしたプログラムです。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    int texhandle, pshandle ;
    VERTEX2DSHADER Vert[ 4 ] ;
    unsigned short Index[ 6 ] ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 ) return -1;

    // テクスチャを読み込む
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "PixelShaderTestPS.pso" ) ;

    // ２ポリゴン分の頂点のデータをセットアップ
    Vert[ 0 ].pos = VGet(   0.0f,   0.0f, 0.0f ) ;
    Vert[ 0 ].rhw = 1.0f ;
    Vert[ 0 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 0 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 0 ].u   = 0.0f ;
    Vert[ 0 ].v   = 0.0f ;
    Vert[ 0 ].su  = 0.0f ;
    Vert[ 0 ].sv  = 0.0f ;

    Vert[ 1 ].pos = VGet( 256.0f,   0.0f, 0.0f ) ;
    Vert[ 1 ].rhw = 1.0f ;
    Vert[ 1 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 1 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 1 ].u   = 1.0f ;
    Vert[ 1 ].v   = 0.0f ;
    Vert[ 1 ].su  = 1.0f ;
    Vert[ 1 ].sv  = 0.0f ;

    Vert[ 2 ].pos = VGet(   0.0f, 256.0f, 0.0f ) ;
    Vert[ 2 ].rhw = 1.0f ;
    Vert[ 2 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 2 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 2 ].u   = 0.0f ;
    Vert[ 2 ].v   = 1.0f ;
    Vert[ 2 ].su  = 0.0f ;
    Vert[ 2 ].sv  = 1.0f ;

    Vert[ 3 ].pos = VGet( 256.0f, 256.0f, 0.0f ) ;
    Vert[ 3 ].rhw = 1.0f ;
    Vert[ 3 ].dif = GetColorU8( 255,255,255,255 ) ;
    Vert[ 3 ].spc = GetColorU8(   0,  0,  0,  0 ) ;
    Vert[ 3 ].u   = 1.0f ;
    Vert[ 3 ].v   = 1.0f ;
    Vert[ 3 ].su  = 1.0f ;
    Vert[ 3 ].sv  = 1.0f ;

    // ２ポリゴン分の頂点番号配列のセットアップ
    Index[ 0 ] = 0 ;
    Index[ 1 ] = 1 ;
    Index[ 2 ] = 2 ;
    Index[ 3 ] = 2 ;
    Index[ 4 ] = 1 ;
    Index[ 5 ] = 3 ;

    // 使用するテクスチャを０番にセット
    SetUseTextureToShader( 0, texhandle ) ;

    // 使用するピクセルシェーダーをセット
    SetUsePixelShader( pshandle ) ;

    // シェーダーを使用した２Ｄの２ポリゴンの描画
    DrawPolygonIndexed2DToShader( Vert, 4, Index, 2 ) ;

    // キー入力待ち
    WaitKey() ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End();

    // ソフトの終了
    return 0;
}
</pre>
            <hr>

            <br><br><br><br>
            
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R17N35">宣言</a></b></td><td><font color="#000088"><b>int DrawPolygonIndexed3DToShader( VERTEX3DSHADER *Vertex, int VertexNum, unsigned short *Indices, int PolygonNum ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シェーダーを使って２Ｄポリゴンを描画する(インデックスを使用)<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            VERTEX3DSHADER *Vertex ： ポリゴンを構成する頂点配列の先頭アドレス<br>
            int VertexNum ： 頂点の数( Vertex で渡す配列の長さ )<br>
            unsigned short *Indices ： 頂点番号配列の先頭アドレス<br>
            int PolygonNum ： 描画するポリゴンの数<br>
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R17N34">DrawPolygonIndexed2DToShader</a></b> の３Ｄ版です、
                    Indexed な描画関数と Indexed が付かない描画関数との違いについては DrawPolygonIndexed2DToShader の解説を参照してください。<br>
                    　シェーダーを使用した３Ｄポリゴン描画の基本的な解説については <b><a href="#R17N33">DrawPolygon3DToShader</a></b> の解説を参照してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>

            　　LoadVertexShader のサンプルプログラムのＣ＋＋の部分のみを DrawPolygonIndexed3DToShader を使用するようにしたプログラムです。<br><br><br>
            <hr>
            <b>Ｃ＋＋のプログラム</b>
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    VERTEX3DSHADER Vertex[ 4 ] ;
    unsigned short Index[ 6 ] ;
    int vshandle ;
    int pshandle ;
    int texhandle ;
    int x ;
    int xadd ;
    float color ;
    float coloradd ;
    FLOAT4 f4 ;

    // ＤＸライブラリの初期化
    if( DxLib_Init() &lt; 0 )
    {
        // エラーが発生したら直ちに終了
        return -1 ;
    }

    // ２ポリゴン分の頂点のデータをセットアップ
    Vertex[ 0 ].pos  = VGet( 220.0f, 340.0f,  0.0f ) ;
    Vertex[ 0 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 0 ].dif  = GetColorU8( 255,  0,255,255 ) ;
    Vertex[ 0 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 0 ].u    = 0.0f ;
    Vertex[ 0 ].v    = 0.0f ;
    Vertex[ 0 ].su   = 0.0f ;
    Vertex[ 0 ].sv   = 0.0f ;

    Vertex[ 1 ].pos  = VGet( 420.0f, 340.0f,  0.0f ) ;
    Vertex[ 1 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 1 ].dif  = GetColorU8(   0,  0,255,255 ) ;
    Vertex[ 1 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 1 ].u    = 1.0f ;
    Vertex[ 1 ].v    = 0.0f ;
    Vertex[ 1 ].su   = 0.0f ;
    Vertex[ 1 ].sv   = 0.0f ;

    Vertex[ 2 ].pos  = VGet( 220.0f, 140.0f,  0.0f ) ;
    Vertex[ 2 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 2 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 2 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 2 ].u    = 0.0f ;
    Vertex[ 2 ].v    = 1.0f ;
    Vertex[ 2 ].su   = 0.0f ;
    Vertex[ 2 ].sv   = 0.0f ;

    Vertex[ 3 ].pos  = VGet( 420.0f, 140.0f,  0.0f ) ;
    Vertex[ 3 ].norm = VGet(   0.0f,   0.0f, -1.0f ) ;
    Vertex[ 3 ].dif  = GetColorU8( 255,255,  0,255 ) ;
    Vertex[ 3 ].spc  = GetColorU8(   0,  0,  0,  0 ) ;
    Vertex[ 3 ].u    = 1.0f ;
    Vertex[ 3 ].v    = 1.0f ;
    Vertex[ 3 ].su   = 0.0f ;
    Vertex[ 3 ].sv   = 0.0f ;

    // ２ポリゴン分の頂点番号配列をセットアップ
    Index[ 0 ] = 0 ;
    Index[ 1 ] = 1 ;
    Index[ 2 ] = 2 ;
    Index[ 3 ] = 2 ;
    Index[ 4 ] = 1 ;
    Index[ 5 ] = 3 ;

    // 頂点シェーダーを読み込む
    vshandle = LoadVertexShader( "VertexShaderTestVS.vso" ) ;

    // ピクセルシェーダーを読み込む
    pshandle = LoadPixelShader( "VertexShaderTestPS.pso" ) ;

    // 描画に使用する画像の読み込み
    texhandle = LoadGraph( "Tex1.bmp" ) ;

    // 描画先を裏画面にする
    SetDrawScreen( DX_SCREEN_BACK ) ;

    // 表示座標を移動する処理の初期化
    x = 0 ;
    xadd = 8 ;

    // 色を変化させる処理の初期化
    color = 0.0f ;
    coloradd = 1.0f / 60.0f ;

    // ESCキーが押されるまでループ
    while( ProcessMessage() == 0 &amp;&amp; CheckHitKey( KEY_INPUT_ESCAPE ) == 0 )
    {
        // 画面を初期化
        ClearDrawScreen() ;

        // 座標を移動させる
        x += xadd ;
        if( x &gt; 200 || x &lt; -200 )
        {
            xadd = -xadd ;
        }

        // 色の値を変化させる
        color += coloradd ;
        if( color &lt;= 0.0f || color &gt;= 1.0f )
        {
            coloradd = -coloradd ;
        }

        // 座標値を頂点シェーダー float4型定数０番にセット
        f4.x = ( float )x ;
        f4.y = 0.0f ;
        f4.z = 0.0f ;
        f4.w = 0.0f ;
        SetVSConstF( 0, f4 ) ;

        // 色の値をピクセルシェーダー float4型定数０番にセット
        f4.x = color ;
        f4.y = color ;
        f4.z = color ;
        f4.w = 1.0f ;
        SetPSConstF( 0, f4 ) ;

        // 使用する頂点シェーダーのセット
        SetUseVertexShader( vshandle ) ;

        // 使用するピクセルシェーダーをセット
        SetUsePixelShader( pshandle ) ;

        // 使用するテクスチャを０番にセット
        SetUseTextureToShader( 0, texhandle ) ;

        // シェーダーを使用した２ポリゴンの描画
        DrawPolygonIndexed3DToShader( Vertex, 4, Index, 2 ) ;

        // 裏画面の内容を表画面に反映させる
        ScreenFlip() ;
    }

    // 使用した頂点シェーダーの float4型定数の設定を無効化する
    ResetVSConstF( 0, 2 ) ;

    // 使用したピクセルシェーダーの float4型定数の設定を無効化する
    ResetPSConstF( 0, 1 ) ;

    // 読み込んだ頂点シェーダーの削除
    DeleteShader( vshandle ) ;

    // 読み込んだピクセルシェーダーの削除
    DeleteShader( pshandle ) ;

    // ＤＸライブラリの後始末
    DxLib_End() ;

    // ソフトの終了
    return 0 ;
}
</pre>
            <hr>

            <br><br><br><br>
            
        </td></tr>













        <tr><td><font size="3" color="#005500"><b>シャドウマップ関係関数</b><br><br></font></td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N1">宣言</a></b></td><td><font color="#000088"><b>int MakeShadowMap( int SizeX, int SizeY ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップを作成する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            SizeX , SizeY ：　作成するシャドウマップのサイズ( ２のｎ乗である必要があります )</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td>
                <td>−１　　　:　エラー発生<br>
                    −１以外　:　シャドウマップのハンドル<br><br></td>
            </tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　シャドウマップは３Ｄモデルの描画で影を表現する為のもので、この関数にシャドウマップの横解像度 SizeX、縦解像度 SizeY を引数として渡して作成します。<br><br>

		    ＤＸライブラリでシャドウマップを使用した影の表現する手順は以下のようになります。<br><br><br>

                    ＜最初に行うこと＞<br><br>
                    １．MakeShadowMap を使用してシャドウマップを作成<br><br><br>

		    ＜シャドウマップの準備＞<br><br>
		    ２．<b><a href="#R20N3">SetShadowMapLightDirection</a></b> を使用してシャドウマップへの描画で想定するライトの向きを設定<br><br>
		    ３．<b><a href="#R20N7">SetShadowMapDrawArea</a></b> を使用してシャドウマップに描画する３Ｄ空間の範囲を設定<br><br>
		    ４．<b><a href="#R20N4">ShadowMap_DrawSetup</a></b> を使用してシャドウマップへの描画の準備<br><br>
		    ５．シャドウマップへ描画したい全ての３Ｄモデルを <b><a href="#R2N1">MV1DrawModel</a></b> で描画<br><br>
		    ６．<b><a href="#R20N5">ShadowMap_DrawEnd</a></b> を使用してシャドウマップへの描画を終了<br><br><br>

		    ＜シャドウマップによる影の表現を伴う３Ｄモデル描画＞<br><br>
		    ７．<b><a href="#R20N6">SetUseShadowMap</a></b> を使用して使用するシャドウマップを設定<br><br>
		    ８．シャドウマップによる影の表現を伴う描画を行いたい全ての３Ｄモデルを <b><a href="#R2N1">MV1DrawModel</a></b> で描画<br><br>
		    ９．<b><a href="#R20N6">SetUseShadowMap</a></b> のシャドウマップハンドルを指定する引数( 第二引数 )に -1 を渡して呼び出し、<br>
		    　　使用するシャドウマップの設定を解除<br><br><br>

		    ＜最後に行うこと＞<br><br>
		    １０．必要が無くなったシャドウマップを <b><a href="#R20N2">DeleteShadowMap</a></b> を使用して削除<br><br><br>

		    　尚、引数のコメントにもありますが SizeX、SizeY は２のｎ乗の数値( 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096 ... )である必要があります。<br>
		    　SizeX, SizeY で指定するサイズが大きければ大きいほど描画される影の粗さが軽減されますが、その分描画負荷や使用するVRAMのサイズも大きくなりますので注意してください。<br><br>
		    　また、シャドウマップの機能はグラフィックスデバイスがシェーダーモデル2.0以降に対応している必要があり、
		    且つそれなりに処理負荷が高いので古いＰＣでも動作するソフトを作成する場合はシャドウマップの機能を使用しないか、
		    オプション等でシャドウマップの機能を使用するかどうかを選択できるようにする必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　板ポリゴンにキャラクターモデルの影を描画します。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int StageModelHandle ;
	int CharaModelHandle ;
	int ShadowMapHandle ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ステージモデルの読み込み
	StageModelHandle = MV1LoadModel( "Plane.mqo" ) ;

	// シャドウマップハンドルの作成
	ShadowMapHandle = MakeShadowMap( 1024, 1024 ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 800.0f, -800.0f ), VGet( 0.000f, 500.000f, 0.000f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 40.000f, 2000.000f );

	// ライトの方向を設定
	SetLightDirection( VGet( 0.5f, -0.5f, 0.5f ) );

	// シャドウマップが想定するライトの方向もセット
	SetShadowMapLightDirection( ShadowMapHandle, VGet( 0.5f, -0.5f, 0.5f ) ) ;

	// シャドウマップに描画する範囲を設定
	SetShadowMapDrawArea( ShadowMapHandle, VGet( -1000.0f, -1.0f, -1000.0f ), VGet( 1000.0f, 1000.0f, 1000.0f ) ) ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;


		// シャドウマップへの描画の準備
		ShadowMap_DrawSetup( ShadowMapHandle ) ;

		// シャドウマップへステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// シャドウマップへキャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// シャドウマップへの描画を終了
		ShadowMap_DrawEnd() ;


		// 描画に使用するシャドウマップを設定
		SetUseShadowMap( 0, ShadowMapHandle ) ;

		// ステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// キャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// 描画に使用するシャドウマップの設定を解除
		SetUseShadowMap( 0, -1 ) ;


		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// シャドウマップの削除
	DeleteShadowMap( ShadowMapHandle ) ;

	// ステージモデルの削除
	MV1DeleteModel( StageModelHandle ) ;

	// キャラクターモデルの削除
	MV1DeleteModel( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>


        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N2">宣言</a></b></td><td><font color="#000088"><b>int DeleteShadowMap( int SmHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップを削除する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            SmHandle：　削除するシャドウマップのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SmHandle で指定されたシャドウマップを削除します。<br>
                    　保持しておけるシャドウマップの数や、シャドウマップの保持に必要な VRAM の容量には限りがありますので、
                    不要になったシャドウマップはこの関数を使用して削除するようにしてください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>


        <tr><td>
            <b>サンプル</b><br><br>
            　　<a href="#R20N1">MakeShadowMap</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N3">宣言</a></b></td><td><font color="#000088"><b>int SetShadowMapLightDirection( int SmHandle, VECTOR Direction ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップで想定するライトの方向を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
	    SmHandle：ライトの方向を設定するシャドウマップのハンドル<br>
            Direction：シャドウマップに設定する「想定するライトの方向」
	    </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R20N1">MakeShadowMap</a></b> で作成したシャドウマップへの描画の際に想定するライトの方向を設定します。<br><br>
                    　この関数で設定したライトの方向を前提に、シャドウマップへの描画が行われます。<br><br>

                    　因みに、ライトの方向は <b><a href="#R13N8">SetLightDirection</a></b> 等の関数で設定しているのに何故この関数で別に設定しなければならないのかと言いますと、
                    今のところＤＸライブラリのシャドウマップ機能ではディレクショナルライト一つ分しか想定することができないからです。<br>
		    ( ディレクショナルライト以外や、複数のライトを使用された場合にシャドウマップでどのライトの情報を使用すればよいか判断できない )<br><br>

                    　なので、全てのライトの情報をシャドウマップへ反映させられるようになった際にはこの関数は使用する必要がなくなると思います。<br><br>

		    　尚、この関数は <b><a href="#R20N4">ShadowMap_DrawSetup</a></b> を呼ぶ前( シャドウマップへの描画を開始する前 )に呼んでおく必要がありますので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　板ポリゴンにキャラクターモデルの影を描画して、その影の角度( とライトの方向 )を回転させます。
            <hr>
<pre>
#include "DxLib.h"
#include &lt;math.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int StageModelHandle ;
	int CharaModelHandle ;
	int ShadowMapHandle ;
	float Angle ;
	VECTOR LightDirection ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ステージモデルの読み込み
	StageModelHandle = MV1LoadModel( "Plane.mqo" ) ;

	// シャドウマップハンドルの作成
	ShadowMapHandle = MakeShadowMap( 1024, 1024 ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 800.0f, -800.0f ), VGet( 0.000f, 500.000f, 0.000f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 40.000f, 2000.000f );

	// シャドウマップに描画する範囲を設定
	SetShadowMapDrawArea( ShadowMapHandle, VGet( -1000.0f, -1.0f, -1000.0f ), VGet( 1000.0f, 1000.0f, 1000.0f ) ) ;

	// ライトの角度を初期化
	Angle = 0.0f ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;


		// ライトの角度を変更
		Angle += 0.0125f ;
		if( Angle > DX_PI_F * 2.0f )
		{
			Angle -= DX_PI_F * 2.0f ;
		}

		// ライトの方向ベクトルの算出
		LightDirection.x = sin( Angle ) ;
		LightDirection.z = cos( Angle ) ;
		LightDirection.y = -1.0f ;

		// ライトの方向を設定
		SetLightDirection( LightDirection );

		// シャドウマップが想定するライトの方向もセット
		SetShadowMapLightDirection( ShadowMapHandle, LightDirection ) ;


		// シャドウマップへの描画の準備
		ShadowMap_DrawSetup( ShadowMapHandle ) ;

		// シャドウマップへステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// シャドウマップへキャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// シャドウマップへの描画を終了
		ShadowMap_DrawEnd() ;


		// 描画に使用するシャドウマップを設定
		SetUseShadowMap( 0, ShadowMapHandle ) ;

		// ステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// キャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// 描画に使用するシャドウマップの設定を解除
		SetUseShadowMap( 0, -1 ) ;


		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// シャドウマップの削除
	DeleteShadowMap( ShadowMapHandle ) ;

	// ステージモデルの削除
	MV1DeleteModel( StageModelHandle ) ;

	// キャラクターモデルの削除
	MV1DeleteModel( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>



        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N4">宣言</a></b></td><td><font color="#000088"><b>int ShadowMap_DrawSetup( int SmHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップへの描画の準備を行う<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            SmHandle：シャドウマップへの描画準備を行うシャドウマップのハンドル</td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SmHandle で指定されたシャドウマップへの描画の準備を行います。<br><br>

                    　この関数を実行すると <b><a href="dxfunc_graph3.html#R4N6">SetDrawScreen</a></b> の設定に関係なく、以降 <b><a href="#R20N5">ShadowMap_DrawEnd</a></b> が呼ばれるまで描画先は SmHandle で指定したシャドウマップになります。<br><br>
                    　なので、この関数を呼んだ後、シャドウマップに描画したい３Ｄモデルを <b><a href="#R2N1">MV1DrawModel</a></b> で描画して、
                    その後 ShadowMap_DrawEnd でシャドウマップへの描画を終了する、という形になります。<br><br>

                    　因みにシャドウマップに描画する３Ｄモデルとは「影を落としたい３Ｄモデル」ですので、おばけのような影を落としたくない３Ｄモデルはシャドウマップへの描画を行う必要はありません。<br><br>

                    　尚、この関数を呼んだ後は ShadowMap_DrawEnd を呼んでシャドウマップへの描画を終了するまでは
                    <b><a href="#R20N7">SetShadowMapDrawArea</a></b> や <b><a href="#R20N3">SetShadowMapLightDirection</a></b>、<b><a href="#R20N6">SetUseShadowMap</a></b>、<b><a href="#R20N9">TestDrawShadowMap</a></b> などのシャドウマップの設定を変更したり、
                    現在の状態を確認したりする為の関数は使用できませんので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>


        <tr><td>
            <b>サンプル</b><br><br>
            　　<a href="#R20N1">MakeShadowMap</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>




        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N5">宣言</a></b></td><td><font color="#000088"><b>int ShadowMap_DrawEnd( void ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップへの描画を終了する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
            なし
            </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　<b><a href="#R20N4">ShadowMap_DrawSetup</a></b> で開始したシャドウマップへの描画を終了します。<br>
                    　ShadowMap_DrawEnd 単体で使用することは無く、ShadowMap_DrawSetup で開始したシャドウマップへの描画を終了するには必ずこの関数を使用するので、
		    ShadowMap_DrawSetup とは常に対で使用することになります。<br><br>

                    　尚、ShadowMap_DrawSetup を呼んだ後はこの関数を呼んでシャドウマップへの描画を終了するまでは
                    <b><a href="#R20N7">SetShadowMapDrawArea</a></b> や <b><a href="#R20N3">SetShadowMapLightDirection</a></b>、<b><a href="#R20N6">SetUseShadowMap</a></b>、<b><a href="#R20N9">TestDrawShadowMap</a></b> などのシャドウマップの設定を変更したり、
                    現在の状態を確認したりする為の関数は使用できませんので注意してください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>


        <tr><td>
            <b>サンプル</b><br><br>
            　　<a href="#R20N1">MakeShadowMap</a> のサンプルを参照してください。<br><br><br><br>
        </td></tr>






        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N6">宣言</a></b></td><td><font color="#000088"><b>int SetUseShadowMap( int SmSlotIndex, int SmHandle ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>描画で使用するシャドウマップを変更する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
	    SmSlotIndex：描画で使用するシャドウマップをセットするスロット番号( ０〜２ )<br>
	    SmHandle：描画で使用するシャドウマップのハンドル<br>
            　　　　　( −１を渡すと SmSlotIndex で指定したスロットのシャドウマップを解除 )
	    </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　３Ｄモデルを <b><a href="#R2N1">MV1DrawModel</a></b> で描画する際の影表現に使用するシャドウマップを指定するための関数です。<br><br>

		    　SmSlotIndex でシャドウマップをセットするスロットを０〜２の３つから選択します、０〜２全てにシャドウマップを設定することで、最大で同時に３つのシャドウマップを使用することができます。<br>
                    　複数のシャドウマップを使用する例は以下の通りです。<br><br><br>

                    例１：<br>

                    　スロット０：動かない３Ｄモデルを一度だけ描画したシャドウマップ<br>
                    　スロット１：動く３Ｄモデルを毎フレーム描画したシャドウマップ<br>
                    　スロット２：使用しない<br><br>
		    
		    　動かない３Ｄモデルのシャドウマップへの描画が一度だけで済むので、その分の負荷が軽減できます。<br><br><br>


                    例２：<br>

                    　スロット０：プレイヤーキャラとその周辺の狭い範囲にある３Ｄモデルだけを描画したシャドウマップ<br>
                    　スロット１：広範囲の３Ｄモデルを描画したシャドウマップ<br>
                    　スロット２：使用しない<br><br>

		    　シャドウマップは描画する範囲が広くなればなるほど影が粗くなるので、
                    プレイヤーの周りは高精度の影を描画、プレイヤーから離れた箇所は低精度の影を描画とすることができます。<br><br><br>


                    例３：<br>

                    　スロット０：動かない３Ｄモデルを一度だけ描画したシャドウマップ<br>
                    　スロット１：プレイヤーキャラとその周辺の狭い範囲にある動く３Ｄモデルだけを描画したシャドウマップ<br>
                    　スロット２：広範囲の動く３Ｄモデルを描画したシャドウマップ<br><br>

		    　例１と例２を合わせた使い方です。<br><br><br><br>


                    　SmHandle に指定するシャドウマップは、<b><a href="#R20N4">ShadowMap_DrawSetup</a></b> 〜 <b><a href="#R20N5">ShadowMap_DrawEnd</a></b> を使用してシャドウマップへの３Ｄモデルの描画が行われた後のものである必要があります。<br><br>
                    　尚、シャドウマップによる影の描画が必要なくなった後は、SmHandle に -1 を渡して関数を呼び、設定したシャドウマップを解除する必要があります。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　解説の例１のサンプルです。ステージモデル用のシャドウマップとキャラクターモデル用のシャドウマップを別々に用意して、<br>
	    　ステージモデル用のシャドウマップにはメインループに入る前に一度だけステージモデルを描画して、メインループ中では<br>
	    　キャラクターモデル用のシャドウマップに対してのみ毎フレームキャラクターモデルを描画するようにしています。
            <hr>
<pre>
#include "DxLib.h"
#include &lt;math.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int StageModelHandle ;
	int CharaModelHandle ;
	int StageShadowMapHandle ;
	int CharaShadowMapHandle ;
	float Angle ;
	VECTOR CharaPosition ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ステージモデルの読み込み
	StageModelHandle = MV1LoadModel( "SimplePillarStage.mqo" ) ;

	// ステージモデル用のシャドウマップハンドルの作成
	StageShadowMapHandle = MakeShadowMap( 2048, 2048 ) ;

	// キャラクターモデル用のシャドウマップハンドルの作成
	CharaShadowMapHandle = MakeShadowMap( 2048, 2048 ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 1500.0f, -1500.0f ), VGet( 0.0f, 800.0f, -800.0f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 160.000f, 80000.000f );

	// シャドウマップに描画する範囲を設定
	SetShadowMapDrawArea( StageShadowMapHandle, VGet( -4000.0f, -1.0f, -4000.0f ), VGet( 4000.0f, 4000.0f, 4000.0f ) ) ;
	SetShadowMapDrawArea( CharaShadowMapHandle, VGet( -4000.0f, -1.0f, -4000.0f ), VGet( 4000.0f, 4000.0f, 4000.0f ) ) ;

	// ライトの方向を設定
	SetLightDirection( VGet( 0.5f, -0.5f, 0.5f ) );

	// シャドウマップが想定するライトの方向もセット
	SetShadowMapLightDirection( StageShadowMapHandle, VGet( 0.5f, -0.5f, 0.5f ) ) ;
	SetShadowMapLightDirection( CharaShadowMapHandle, VGet( 0.5f, -0.5f, 0.5f ) ) ;

	// ステージモデル用のシャドウマップへの描画の準備
	ShadowMap_DrawSetup( StageShadowMapHandle ) ;

	// ステージモデル用のシャドウマップへステージモデルの描画
	MV1DrawModel( StageModelHandle ) ;

	// ステージモデル用のシャドウマップへの描画を終了
	ShadowMap_DrawEnd() ;

	// キャラクターの位置となる角度を初期化
	Angle = 0.0f ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;


		// キャラクターの位置となる角度を変更
		Angle += 0.0125f ;
		if( Angle > DX_PI_F * 2.0f )
		{
			Angle -= DX_PI_F * 2.0f ;
		}

		// キャラクターの座標を算出
		CharaPosition.x = sin( Angle ) * 1000.0f ;
		CharaPosition.z = cos( Angle ) * 1000.0f ;
		CharaPosition.y = 0.0f ;

		// キャラクターモデルの座標を変更
		MV1SetPosition( CharaModelHandle, CharaPosition ) ;


		// キャラクターモデル用のシャドウマップへの描画の準備
		ShadowMap_DrawSetup( CharaShadowMapHandle ) ;

		// キャラクターモデル用のシャドウマップへキャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// キャラクターモデル用のシャドウマップへの描画を終了
		ShadowMap_DrawEnd() ;


		// 描画にキャラクターモデル用のシャドウマップと
		// ステージモデル用のシャドウマップのどちらも使用する
		SetUseShadowMap( 0, StageShadowMapHandle ) ;
		SetUseShadowMap( 1, CharaShadowMapHandle ) ;

		// ステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// キャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// 描画に使用するシャドウマップの設定を解除
		SetUseShadowMap( 0, -1 ) ;
		SetUseShadowMap( 1, -1 ) ;


		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// シャドウマップの削除
	DeleteShadowMap( StageShadowMapHandle ) ;
	DeleteShadowMap( CharaShadowMapHandle ) ;

	// ステージモデルの削除
	MV1DeleteModel( StageModelHandle ) ;

	// キャラクターモデルの削除
	MV1DeleteModel( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>







        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N7">宣言</a></b></td><td><font color="#000088"><b>int SetShadowMapDrawArea( int SmHandle, VECTOR MinPosition, VECTOR MaxPosition ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップに描画する範囲を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
	    SmHandle：描画する範囲を設定するシャドウマップのハンドル<br>
	    MinPosition：描画する範囲の座標値の小さいほうの頂点の座標<br>
	    MaxPosition：描画する範囲の座標値の大きいほうの頂点の座標
	    </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SmHandle が示すシャドウマップに対して、<b><a href="#R20N4">ShadowMap_DrawSetup</a></b> 〜 <b><a href="#R20N5">ShadowMap_DrawEnd</a></b> を使用してシャドウマップに描画する範囲を設定します。<br><br>

		    　シャドウマップによる影の表現では『シャドウマップによる影の表現を行いたい３Ｄモデル』をシャドウマップに描画する必要があります。<br>
		    　シャドウマップに対して３Ｄモデルを描画する手順は、<br><br><br>
		    
		    １．SetShadowMapDrawArea を使用して『シャドウマップによる影の表現を行いたい全ての３Ｄモデル』が<br>
		    　　存在する範囲を設定<br><br>

		    ２．<b><a href="#R20N4">ShadowMap_DrawSetup</a></b> を呼び出してシャドウマップへの描画の準備<br><br>
		    
		    ３．『シャドウマップによる影の表現を行いたい全ての３Ｄモデル』を <b><a href="#R2N1">MV1DrawModel</a></b> で描画<br><br>

		    ４．ShadowMap_DrawEnd でシャドウマップへの描画を終了<br><br><br>

		    　となります。<br><br>

		    　尚、SetShadowMapDrawArea は ShadowMap_DrawSetup を使用する前に呼んでおく必要がありますので注意してください。<br><br>

		    　また、描画範囲は必要最小限の大きさにする必要があります。<br>
		    何故かと言いますと、描画範囲が広くなれば広くなるほど実際にシャドウマップを使用して影を描画した際の影が粗くなるからです。<br>
		    ( シャドウマップの解像度は変化せずに、シャドウマップに描画する範囲が広くなるため、単位距離辺りに割かれるピクセル数が少なくなるからです )<br><br>

		    　この関数を使用して描画範囲を明示的に指定しない場合はカメラの設定から自動的に描画範囲を決定しますが、
		    大抵の場合カメラはかなり広い範囲を描画範囲としているので、影が凄く粗くなります。なので、必要な範囲をこの関数で設定することをお勧めします。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　シャドウマップに描画する範囲を変更した結果を確認するためのサンプルです。上下キーで描画の範囲を変更できます。
            <hr>
<pre>
#include "DxLib.h"

#define CHARA_POS_SPACE         (1500.0f)
#define CHARA_NUM               (4)
#define CHARA_POS_DISTANCE      ( ( CHARA_NUM - 1 ) * CHARA_POS_SPACE )

int StageModelHandle ;
int CharaModelHandle ;
int ShadowMapHandle ;

// キャラクターを描画する
void CharaDraw( void )
{
	int i ;
	int j ;
	VECTOR Position ;

	// キャラクターを１６体描画
	for( i = 0 ; i < CHARA_NUM ; i ++ )
	{
		for( j = 0 ; j < CHARA_NUM ; j ++ )
		{
			// 描画位置を設定
			Position.x = -CHARA_POS_DISTANCE / 2.0f + CHARA_POS_SPACE * j ;
			Position.y = 0.0f ;
			Position.z = -CHARA_POS_DISTANCE / 2.0f + CHARA_POS_SPACE * i ;
			MV1SetPosition( CharaModelHandle, Position ) ;

			// ３Ｄモデルを描画
			MV1DrawModel( CharaModelHandle ) ;
		}
	}
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	float DrawAreaSize ;
	VECTOR DrawAreaMinPos ;
	VECTOR DrawAreaMaxPos ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ステージモデルの読み込み
	StageModelHandle = MV1LoadModel( "Plane.mqo" ) ;

	// シャドウマップハンドルの作成
	ShadowMapHandle = MakeShadowMap( 1024, 1024 ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 3600.0f, -3400.0f ), VGet( 0.000f, 500.000f, -500.000f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 200.000f, 10000.000f );

	// ライトの方向を設定
	SetLightDirection( VGet( 0.5f, -0.5f, 0.5f ) );

	// シャドウマップが想定するライトの方向もセット
	SetShadowMapLightDirection( ShadowMapHandle, VGet( 0.5f, -0.5f, 0.5f ) ) ;

	// 描画するサイズを初期化
	DrawAreaSize = 1000.0f ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;


		// 上下キーで描画するサイズを変更
		if( CheckHitKey( KEY_INPUT_UP ) == 1 )
		{
			DrawAreaSize += 10.0f ;
		}

		if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
		{
			DrawAreaSize -= 10.0f ;
			if( DrawAreaSize < 1.0f )
			{
				DrawAreaSize = 1.0f ;
			}
		}

		// シャドウマップに描画する範囲を設定
		DrawAreaMinPos = VGet( -DrawAreaSize,   -1.0f, -DrawAreaSize ) ;
		DrawAreaMaxPos = VGet(  DrawAreaSize, 1000.0f,  DrawAreaSize ) ;
		SetShadowMapDrawArea( ShadowMapHandle, DrawAreaMinPos, DrawAreaMaxPos ) ;

		// シャドウマップへの描画の準備
		ShadowMap_DrawSetup( ShadowMapHandle ) ;

		// シャドウマップへステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// シャドウマップへキャラクターモデルの描画
		CharaDraw() ;

		// シャドウマップへの描画を終了
		ShadowMap_DrawEnd() ;


		// 描画に使用するシャドウマップを設定
		SetUseShadowMap( 0, ShadowMapHandle ) ;

		// ステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// キャラクターモデルの描画
		CharaDraw() ;

		// 描画に使用するシャドウマップの設定を解除
		SetUseShadowMap( 0, -1 ) ;


		// 画面に現在のサイズと範囲を描画
		DrawFormatString( 0,  0, GetColor( 255,255,255 ), "AreaSize:%.1f", DrawAreaSize ) ;
		DrawFormatString( 0, 16, GetColor( 255,255,255 ), "MinPos( %.1f, %.1f, %.1f )",
			DrawAreaMinPos.x, DrawAreaMinPos.y, DrawAreaMinPos.z ) ;
		DrawFormatString( 0, 32, GetColor( 255,255,255 ), "MaxPos( %.1f, %.1f, %.1f )",
			DrawAreaMaxPos.x, DrawAreaMaxPos.y, DrawAreaMaxPos.z ) ;

		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// シャドウマップの削除
	DeleteShadowMap( ShadowMapHandle ) ;

	// ステージモデルの削除
	MV1DeleteModel( StageModelHandle ) ;

	// キャラクターモデルの削除
	MV1DeleteModel( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>







        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N8">宣言</a></b></td><td><font color="#000088"><b>int SetShadowMapAdjustDepth( int SmHandle, float Depth ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップを使用した３Ｄモデル描画時の深度判定の補正値を設定する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
	    SmHandle：深度判定の補正値を変更するシャドウマップのハンドル<br>
	    Depth：深度判定の補正値( デフォルト：0.002f )
	    </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SmHandle が示すシャドウマップを使用して影の表現をする際に行われる<br><br>
		『シャドウマップに記録されている深度値と影判定用の深度値との比較』<br><br>
		で使用される深度値の補正値を設定します。<br><br>

		    　補正値の詳しい説明をしようとするとシャドウマップによる影表現の仕組みを１から説明しなければならないので、
		    この補正値を変更するとどのようなことになるかをサンプルプログラムで確認してみてください。<br><br>

		    　因みに、概ね問題の無い補正値( 0.002f )をデフォルト値として設定していますので、変更しなければ正常な描画結果を得られない場合のみこの関数を使用するようにしてください。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　シャドウマップを使用して影を表現するサンプルに、上下キーで深度判定の補正値を変更できるようにしたもの。
            <hr>
<pre>
#include "DxLib.h"

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int StageModelHandle ;
	int CharaModelHandle ;
	int ShadowMapHandle ;
	float Adjust ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ステージモデルの読み込み
	StageModelHandle = MV1LoadModel( "Plane.mqo" ) ;

	// シャドウマップハンドルの作成
	ShadowMapHandle = MakeShadowMap( 1024, 1024 ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 800.0f, -800.0f ), VGet( 0.000f, 500.000f, 0.000f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 40.000f, 2000.000f );

	// ライトの方向を設定
	SetLightDirection( VGet( 0.5f, -0.5f, 0.5f ) );

	// シャドウマップが想定するライトの方向もセット
	SetShadowMapLightDirection( ShadowMapHandle, VGet( 0.5f, -0.5f, 0.5f ) ) ;

	// シャドウマップに描画する範囲を設定
	SetShadowMapDrawArea( ShadowMapHandle, VGet( -1000.0f, -1.0f, -1000.0f ), VGet( 1000.0f, 1000.0f, 1000.0f ) ) ;

	// 補正値を初期化
	Adjust = 0.002f ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;


		// 上下キーで補正値を変更
		if( CheckHitKey( KEY_INPUT_UP ) == 1 )
		{
			Adjust += 0.001f ;
		}

		if( CheckHitKey( KEY_INPUT_DOWN ) == 1 )
		{
			Adjust -= 0.001f ;
		}
		SetShadowMapAdjustDepth( ShadowMapHandle, Adjust ) ;


		// シャドウマップへの描画の準備
		ShadowMap_DrawSetup( ShadowMapHandle ) ;

		// シャドウマップへステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// シャドウマップへキャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// シャドウマップへの描画を終了
		ShadowMap_DrawEnd() ;


		// 描画に使用するシャドウマップを設定
		SetUseShadowMap( 0, ShadowMapHandle ) ;

		// ステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// キャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// 描画に使用するシャドウマップの設定を解除
		SetUseShadowMap( 0, -1 ) ;


		// 現在の補正値を画面に描画
		DrawFormatString( 0, 0, GetColor( 255,255,255 ), "Adjust Depth:%f", Adjust ) ;


		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// シャドウマップの削除
	DeleteShadowMap( ShadowMapHandle ) ;

	// ステージモデルの削除
	MV1DeleteModel( StageModelHandle ) ;

	// キャラクターモデルの削除
	MV1DeleteModel( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>








        <tr><td><table align="center" width="800"  cellspacing="0" cellpadding="0">
            <tr><td valign="top" width="100"><b><a name="R20N9">宣言</a></b></td><td><font color="#000088"><b>int TestDrawShadowMap( int SmHandle, int x1, int y1, int x2, int y2 ) ;</b></font><br><br></td></tr>
            <tr><td valign="top" width="100"><b>概略</b></td><td>シャドウマップを画面にテスト描画する<br><br></td></tr>
            <tr><td valign="top" width="100"><b>引数</b></td>
            <td>
	    SmHandle：テスト描画するシャドウマップのハンドル<br>
	    x1, y1：テスト描画をする画面の左上座標<br>
	    x2, y2：テスト描画をする画面の右下座標
	    </td></tr>
            <tr><td valign="top" width="100"><b>戻り値</b></td><td>　０：成功</td></tr>
            <tr><td width="100">　</td><td>−１：エラー発生<br><br></td></tr>
            <tr>
                <td valign="top" width="100"><b>解説</b></td>
                <td>　SmHandle が示すシャドウマップを画面に描画します。<br>
		    　主に『意図通りにシャドウマップに対して描画ができているのか』を確認するために使用するデバッグ用の関数です。<br><br>
                </td>
            </tr>
        </table>
        </td></tr>

        <tr><td>
            <b>サンプル</b><br><br>
            　　<a href="#R20N3">SetShadowMapLightDirection</a> のサンプルに TestDrawShadowMap を使用して画面左上にシャドウマップのテスト描画を加えたもの。
            <hr>
<pre>
#include "DxLib.h"
#include &lt;math.h&gt;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
	int StageModelHandle ;
	int CharaModelHandle ;
	int ShadowMapHandle ;
	float Angle ;
	VECTOR LightDirection ;

	// ウインドウモードで起動する
	ChangeWindowMode( TRUE ) ;

	// ＤＸライブラリの初期化
	if( DxLib_Init() < 0 )
	{
		// エラーが発生したら終了
		return -1 ;
	}

	// 描画先を裏画面に変更
	SetDrawScreen( DX_SCREEN_BACK ) ;

	// キャラクターモデルの読み込み
	CharaModelHandle = MV1LoadModel( "DxChara.x" ) ;

	// ステージモデルの読み込み
	StageModelHandle = MV1LoadModel( "Plane.mqo" ) ;

	// シャドウマップハンドルの作成
	ShadowMapHandle = MakeShadowMap( 1024, 1024 ) ;

	// カメラの位置と向きを設定
	SetCameraPositionAndTarget_UpVecY( VGet( 0.0f, 800.0f, -800.0f ), VGet( 0.000f, 500.000f, 0.000f ) );

	// 描画する奥行き方向の範囲を設定
	SetCameraNearFar( 40.000f, 2000.000f );

	// シャドウマップに描画する範囲を設定
	SetShadowMapDrawArea( ShadowMapHandle, VGet( -1000.0f, -1.0f, -1000.0f ), VGet( 1000.0f, 1000.0f, 1000.0f ) ) ;

	// ライトの角度を初期化
	Angle = 0.0f ;

	// メインループ
	while( ProcessMessage() == 0 )
	{
		// 画面をクリア
		ClearDrawScreen() ;


		// ライトの角度を変更
		Angle += 0.0125f ;
		if( Angle > DX_PI_F * 2.0f )
		{
			Angle -= DX_PI_F * 2.0f ;
		}

		// ライトの方向ベクトルの算出
		LightDirection.x = sin( Angle ) ;
		LightDirection.z = cos( Angle ) ;
		LightDirection.y = -1.0f ;

		// ライトの方向を設定
		SetLightDirection( LightDirection );

		// シャドウマップが想定するライトの方向もセット
		SetShadowMapLightDirection( ShadowMapHandle, LightDirection ) ;


		// シャドウマップへの描画の準備
		ShadowMap_DrawSetup( ShadowMapHandle ) ;

		// シャドウマップへステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// シャドウマップへキャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// シャドウマップへの描画を終了
		ShadowMap_DrawEnd() ;


		// 描画に使用するシャドウマップを設定
		SetUseShadowMap( 0, ShadowMapHandle ) ;

		// ステージモデルの描画
		MV1DrawModel( StageModelHandle ) ;

		// キャラクターモデルの描画
		MV1DrawModel( CharaModelHandle ) ;

		// 描画に使用するシャドウマップの設定を解除
		SetUseShadowMap( 0, -1 ) ;


		// 画面左上にシャドウマップをテスト描画
		TestDrawShadowMap( ShadowMapHandle, 0, 0, 320, 240 ) ;


		// 裏画面の内容を表画面に反映
		ScreenFlip() ;
	}

	// シャドウマップの削除
	DeleteShadowMap( ShadowMapHandle ) ;

	// ステージモデルの削除
	MV1DeleteModel( StageModelHandle ) ;

	// キャラクターモデルの削除
	MV1DeleteModel( CharaModelHandle ) ;

	// ＤＸライブラリの後始末
	DxLib_End() ;

	// ソフトの終了
	return 0 ;
}
</pre>
            <hr>
            <br><br>
        </td></tr>







        
        <tr><td colspan="2">
            <hr>
            <font size="3"><b>
                <a href="../dxfunc.html">戻る</a>
            </b></font>
        </td></tr>
    </table>
    </body>
</html>
